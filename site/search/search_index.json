{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"跨链服务平台 BitXHub BitXHub 是由杭州趣链科技自主研发并完全开源的区块链跨链协作平台，支持应用与多链互操作、同/异构链间互操作等多维跨链交互。","text_tokens":["操作","服务平台","支持","交互","完全","链","同","趣链","bitxhub","研发"," ","协作","多链","开源","跨链","多维","、","区块","/","杭州","。","由","互操作","异构","的","与","自主","平台","，","服务","是","等","链间","应用","科技","并"],"title":"跨链服务平台 BitXHub","title_tokens":["平台","服务","服务平台","跨链","bitxhub"," "]},{"location":"#bitxhub","text":"BitXHub 是由杭州趣链科技自主研发并完全开源的区块链跨链协作平台，支持应用与多链互操作、同/异构链间互操作等多维跨链交互。","text_tokens":["操作","支持","交互","完全","链","同","趣链","bitxhub","协作","研发"," ","多链","开源","跨链","多维","、","区块","/","杭州","。","由","互操作","异构","的","与","自主","平台","，","是","等","链间","应用","科技","并"],"title":"跨链服务平台 BitXHub","title_tokens":["平台","服务","服务平台","跨链","bitxhub"," "]},{"location":"bitxhub/community_introduction/","text":"社区介绍 开源在区块链的发展历程中，发挥着至关重要的作用。开源的本质是共享技术，而技术是生产资料的组成部分，因此开源的社会意义实际上是实现了生产资料的共享。开源的商业意义则在于通过共享技术、推广技术标准从而打造了一个多方商业共同体。无论是对区块链行业，还是对趣链科技本身，开源都具有极为重要的意义，通过开源社区，我们希望： 可以更好地打造共同繁荣的技术社区； 各行各业都可以基于开源产品构建自己的生态，促进生态蓬勃发展； 促进协议标准化，形成区块链行业的事实标准； 开源社区是群体的自发进化，基于社区成长的技术具有更强的生命力。 趣链科技将区块链技术平台开源，希望**打造一个更加开放的架构，所有人都可以参与到跨链技术标准化和革新运动中**，一起继续丰富完善跨链标准，桥接更多类型各异的区块链平台，共同探索跨链的生态系统，真正实现区块链技术的商业闭环，从而推动中国开源运动更好、更快的发展。 BitXHub官网链接 https://bitxhub.hyperchain.cn/ BitXhub开源社区地址 https://github.com/meshplus/bitxhub","text_tokens":["从而","重要","协议","到","实际","各异","技术","；","生命力","共同体","通过","各行各业","区块","cn","所有","生产","无论","本质","类型","希望","蓬勃发展","：","是","科技","运动","商业","更快","官网","无论是","至关重要","因此","将","有人","探索",":","一起","在","发展","群体","自发","趣链","生产资料","各行","链接","丰富","极为","构建","形成","系统","蓬勃","历程","多方","/","。","社区","发挥","着","推动","的","各业","革新运动","架构","则","生态系统","闭环","促进","共同","所有人","实际上","而","打造","介绍","一个","进化","共享","基于","链","为重","生态系","实现","完善","开源","极为重要","繁荣","同体","还是","中国","革新","组成部分",".","成长","对趣","都","社会","事实标准","勃发","更强","生命","意义","平台","*","生态","推广","中","开放","https","github","在于","com","技术标准","参与","部分","更","对","事实","bitxhub","作用"," ","具有","meshplus","hyperchain","更加","可以","地","和","跨链","、","更好","组成","资料","我们","行业","真正","标准化","多","本身","产品","，","自己","标准","桥接","至关","地址","继续","了"],"title":"社区介绍","title_tokens":["介绍","社区"]},{"location":"bitxhub/community_introduction/#_1","text":"开源在区块链的发展历程中，发挥着至关重要的作用。开源的本质是共享技术，而技术是生产资料的组成部分，因此开源的社会意义实际上是实现了生产资料的共享。开源的商业意义则在于通过共享技术、推广技术标准从而打造了一个多方商业共同体。无论是对区块链行业，还是对趣链科技本身，开源都具有极为重要的意义，通过开源社区，我们希望： 可以更好地打造共同繁荣的技术社区； 各行各业都可以基于开源产品构建自己的生态，促进生态蓬勃发展； 促进协议标准化，形成区块链行业的事实标准； 开源社区是群体的自发进化，基于社区成长的技术具有更强的生命力。 趣链科技将区块链技术平台开源，希望**打造一个更加开放的架构，所有人都可以参与到跨链技术标准化和革新运动中**，一起继续丰富完善跨链标准，桥接更多类型各异的区块链平台，共同探索跨链的生态系统，真正实现区块链技术的商业闭环，从而推动中国开源运动更好、更快的发展。 BitXHub官网链接 https://bitxhub.hyperchain.cn/ BitXhub开源社区地址 https://github.com/meshplus/bitxhub","text_tokens":["从而","重要","协议","到","实际","各异","技术","；","生命力","共同体","通过","各行各业","区块","cn","所有","生产","无论","本质","类型","希望","蓬勃发展","：","是","科技","运动","商业","更快","官网","无论是","至关重要","因此","将","有人","探索",":","一起","在","发展","群体","自发","趣链","生产资料","各行","链接","丰富","极为","构建","形成","系统","蓬勃","历程","多方","/","。","发挥","着","社区","推动","的","各业","革新运动","架构","则","生态系统","闭环","促进","共同","所有人","实际上","而","打造","一个","进化","共享","基于","链","为重","生态系","实现","完善","开源","极为重要","繁荣","同体","还是","中国","革新","组成部分",".","成长","对趣","都","社会","事实标准","勃发","更强","生命","意义","平台","*","生态","推广","中","开放","https","github","在于","com","技术标准","参与","部分","更","对","事实","bitxhub","作用"," ","具有","meshplus","hyperchain","更加","可以","地","和","跨链","、","更好","组成","资料","我们","行业","真正","标准化","多","本身","产品","，","自己","标准","桥接","至关","地址","继续","了"],"title":"社区介绍","title_tokens":["介绍","社区"]},{"location":"bitxhub/faq/","text":"FAQ 跨链技术 1. 跨链的必要性 一是技术层面，区块链技术在单链架构下本身存在着性能、容量不足等问题 。单链由于受到目前共识速度的限制，节点的执行性能无法做到线性扩展，这限制了高交易吞吐量低延迟的商业场景的应用。除此之外，随着区块链运行时间的增长，其存储容量也将逐渐增长，且这种数据增长的速度甚至会超过单链存储介质的容量上限。目前的区块链共识算法、存储结构、和安全机制不同导致链与链之间缺乏统一的互联互通机制，这极大限制了区块链技术和应用生态的健康发展。 二是业务层面存在跨区块链业务的资产交换和信息交换需求 。在资产交换方面，一些区块链事实上仍处于互相隔离的状态，它们之间的资产交换主要依靠中心化的交易所来完成，中心化的交换方式既不安全规则也不透明。 而信息交换由于涉及链与链之间的数据同步和相应的跨链调用，实现更为复杂，目前各个区块链应用之间互通壁垒极高，无法有效地进行链上信息共享。 2. 跨链技术的可行性 目前区块链行业已经出现了很多的跨链技术产品，主要采用公证人机制(notary schemes)、侧链/中继(sidechains/relays)、哈希锁定(Hash-locking)等技术，已经在公链的场景中有很多应用例如：闪电网络，去中心化交易所等。 联盟链场景中采用类似技术及其增强技术，解决联盟链跨链需求，目前的产品已经能够解决跨链中的关键问题： 跨链交易的验证问题，如何确认记录交易发生的区块得到了足够的确认，即交易事务中各分布式网络间的数据一致性问题； 跨链事务的原子性问题，如何管理跨链事务中的各子交易确保跨链事务整体完整的原子性，即跨链事务的发生只存在两中状态完成或失败； 不同区块链之间的协议适配问题，如何对采用不同架构与协议的区块链之间进行适配，需要跨链协议中设计可以兼容多种异构区块链的数据结构、命名规范以及通信方式等。 产品功能 1. 产品简介 趣链科技跨链技术平台BitXHub，提出了一套完整的通用跨链传输协议IBTP(Inter-Blokcchain Transfer Protocol), 能够完美支持和兼容任意区块链系统，实现异构区块链的无缝连接。BitXHub采用先进的中继+网关的组合技术，解决了跨链中的交易捕获、传输以及验证的核心难题，所有关键技术均具有完全自主知识产权。同时，平台具备完善的跨链接口管理、异构链成员治理、联盟权限管控等联盟跨链专用机制，是目前业界最完备的异构联盟链跨链技术平台，已经在金融、政务等业务场景中进行了相关应用验证。 2. 实现原理 BitXHub提出一种可扩展的适应不同异构区块链系统之间的跨链方案，通过设计可插拔的跨链网关技术，实现区块链网络间的的协议转换，并支持异构区块链之间的交易验证，该方案支持异构区块链之间交易的可信验证和可靠传递。 应用基于插件机制的跨链网关，实现异构应用链的快速适配与统一管理，以动态加载插件的形式随时加入平台；应用基于智能合约的异构交易验证技术，将交易验证规则进行全生命周期的管理，实现统一、高效的跨链交易合法性验证；应用基于可信事件的跨链传输协议，消除异构区块链之间技术机制的差异性，实现跨链交易格式的通用化与标准化，达成区块链平台在应用级别的可扩展性。 3. 跨链交易基本流程 SDK 调用 具体的业务链A的合约方法； 合约方法被执行，抛出跨链事件T1； 业务链A的跨链网关监听到T1, 将其转换成IBTP结构，提交到中继链BitXHub上； BitXHub 依据相关规则对T1进行验证以及路由； 业务链B的跨链网关接受到T1并根据IBTP结构进行解析，转换成业务链B可识别的交易Tb B的跨链网关将Tb提交到业务链B上进行执行； 4. 跨链效率 跨链的完整流程所需时间： T = Ta + Thub + Tb 其中**Thub**是中继链的验证和共识所需的时间，可达到 5000TPS 左右；**Ta**和**Tb**分别是应用链A和应用链B的执行时间，其性能取决于应用链本身的执行效率。 5. 社区版与商业版有何区别？ 社区版和商业版都支持基础功能： - 中继服务（跨链交易验证与路由、跨链成员管理） - 网关服务（跨链交易捕获、解析与调用） - SDK组件（GO、JAVA） 其他对比如下： 6. 跨链平台目前适配了哪几种应用链？ 目前已适配趣链区块链平台和Hyperledger Fabric，其他类型区块链（包括公链）可以按需通过插件形式灵活接入。社区版目前已提供Fabric的插件。 7. 所有跨链交易都会经过中继链处理，是否会存在数据安全性问题？如何实现不同业务链跨链时的数据隔离和隐私性？ 中继链中的所有交易均以IBTP协议的数据结构进行存储、验证： 参数 说明 From 来源链ID To 目的链ID Version 协议版本号 Index 跨链交易索引 Payload 跨链调用内容编码 Timestamp 跨链事件发生的时间戳 Proof 跨链交易证明 Extra 自定义字段 其中的Payload是跨链交易的核心内容，BitXHub通过多种方式保证其安全性： - 采用特殊的编码机制，仅跨链双方可解； - 采用加密的方式，仅跨链双方持有秘钥； - 链上权限控制，非相关方无法读取相应交易（之后将核心代码开源以保证可信）； - 采用类似隐私交易的机制，仅相关控制的BitXHub节点中保存相关方跨链交易 8. 跨链转账交易如何保证事务性？如何做回滚或补偿呢？ 目前社区版本暂不支持，主要方案是跨链网关结合中继链中存储的跨链交易状态信息共同保障，预计于2020年9月上线，敬请期待！ 9. 通过DataSwapper相互传递的数据，如何保证真实性呢？ 验证引擎会对跨链交易、跨链交易执行结果采用SPV证明机制进行验证，来确保跨链交易和跨链交易的执行都是真实在链中发生的。 应用链中跨链的接口必须按照规定实现，验证引擎会对比跨链调用的接口以及通过SPV机制验证调用接口执行后返回的数据的有效性。 跨链准备 1. 中继链由谁维护？如何搭建？ 中继链本身就是一条联盟链，作为去中心化的可信中介，推荐的搭建方案是由参与跨链的各方共同维护节点来搭建中继链。 2. 跨链网关应该部署在哪里？ 跨链网关部署是由应用链方决定的，跨链网关只负责跨链交易的收集、跨链真实性凭证收集和跨链交易执行；整个跨链操作的可信是通过验证引擎对IBTP的验证实现的，如果跨链网关篡改数据，中继链的验证引擎将不会验证通过。 3. 对于未适配应用链需要做哪些开发工作，改造的工作量是多少？ 应用链适配工作包括： 1. 根据我们提供的模板撰写跨链路由合约broker, 主要一方面将自己的合约某些方法提供给其他方使用；二是提供接受来自其他方的交换的信息或资产接口 2. 对于需要跨链的方法，添加调用跨链的逻辑，就是调用我们提供的跨链合约接口 3. 部署跨链网关（常见区块链无需改造，特殊的区块链只需要提供和区块链相关的SDK基本就可以） 4. 将应用链的信息注册到BitXHub中，如链的ID，节点数量，共识算法类型等 5. 根据应用链的共识机制编写交易的验证规则，详见 验证规则编写文档 跨链操作 1. Fabric没有token，在跨链转账时使用的是什么资产模型？ wiki中给出的例子是一个模拟资产操作的一个合约，对资产模型没做特定的假设。 2. 对于已经存在业务的应用链，是不是需要更改原来的业务合约才能兼容新的资产类型？ 对于已有的业务合约需要进行一定的改造，即实现规定的几个接口，详见 业务合约改造文档","text_tokens":["说明","协议","各","信息","上","治理","金融","合法","一套","不","未","技术","合约","处理","侧链","通信","如果","区块","证人","场景","中心化","就是","中继","持有","以","inter","编码","更为","被","需","关键问题","极高","并","各子","操作","先进","读取","spv","吞吐量","政务","完全","必要性","发展","趣链","链接","链中","管控","随着","口","解决","=","捕获","生命周期","回滚","存储","新","。","中有","中介","t1","protocol","可","适应","！","架构","一致性","不同","双方","速度","有效","例如","已",",","能够","接口","知识","基于","完成","返回","原子","谁","已有","去","区别","开发","schemes","5000tps","或","插件","采用","中","例子","换成","链路","运行","高效","仅","隔离","确认","既","周期","参与","以及","多种","事务性","-","安全","敬请","对","之间","不会","bitxhub"," ","专用","3","原来","是不是","路由","命名","转换成","和","之后","公链","执行","必须","灵活","形式","可行性","数据结构","导致","行业","取决","增长","自己","（","哪些","有效性","管理","保存","凭证","业务","缺乏","暂","8","这种","index","broker","这","依据","到","sdk","部署","之外","隐私","来自","流程","简介","组合","锁定","公证","规范","分布","给","异构","保证","目前","文档","达到","失败","自主","timestamp","：","差异","跨区","是","作为","一致","上线","知识产权","规则","足够","壁垒","只","假设","在","增强","transfer","哪几种","其","产权","2020","from","类似","系统","加入","定义","一些","层面","社区","6","后","的","与","没有","依靠","一是","单链","链方","交易","传输","分别","使用","共同","而","所","同时","逐渐","一个","真实性","机制","心内","做","方跨","实现","调用","无法","？","+","经过","哈希","决定","不足","接入","包括","跨","由","连接","它们","最","生命","除此","更改","token","生态","内容","特定","哪几","非","低","期待","thub","其中","级别","go","负责","均","引擎","解析","难题","抛出","各方","具有","记录","详见","互通","也","出现","proof","方法","a","戳","索引","问题","健康","推荐","改造","仍","可信","1","吞吐","随时","locking","性能","其他","id","无需","互联","to","结合","相互","事件","具体","设计","什么","及其","组件","来","展性","是否","转账","全","年","几个","version","提出","类型","方","验证","关键技术","中心","统一","核心内容","共识","科技","段","）","9","商业","存在","会","可行","即","插拔","几种","发生","收集","对于","加密","延迟","需求","传递","方案","链上","容量","资产","/","监听","关键","一方面","状态","没","成员","如链","存储介质","布式","事务","预计","模拟","添加","限制","无缝","已经","且","必要","原理","支持","相应","链","任意","relays","逻辑","取决于","开源",")","高","事实上","联盟","hash","除此之外","提供","基础","如何","数量","间","通用","自定义","扩展性","可扩展性","等","处于","二是","公证人","功能","识别","多少","注册","b","保障","常见","ibtp","各个","4","格式","敬请期待","接受","商业版","可以","于","完美","秘钥","主要","时","整体","需要","撰写","编写","通用化","可靠","ta","blokcchain","产品","版","核心","hyperledger","基本","得到","标准","很多","自定","按照","来源","应用","极大","就","做到","目的","工作","超过","模板","复杂","准备","适配","篡改","t","；","给出","两中","工作量","一定","dataswapper","通过","达成","(","动态","faq","所有","方面","异性","应该","完整","5","呢","特殊","线性","性","整个","快速","合法性","真实","将","左右","结构","闪电","受到","介质","节点","tb","控制","哪里","相关","notary","加载","兼容","产品简介","结果","确保","互联互通","甚至","互相","payload","补偿","着","业界","交换","提交","不是","分布式","一种","一条","智能","透明","参数","规定","有何","存储容量","完备","共享","效率","涉及","方式","sidechains","完善","对比","fabric","进行","月","如下","wiki",".","根据","可解","搭建","都","7","差异性","块","*","平台","2","一方","下","时间","证明","字","模型","代码","算法","上限","按","事实","安全性","具备","扩展","消除","java","地","跨链","网络","由于","某些","、","版本号","才能","我们","权限","转换","标准化","extra","本身","同步","版本","，","网关","服务","维护","了","交易所","该","数据"],"title":"FAQ","title_tokens":["faq"]},{"location":"bitxhub/faq/#faq","text":"","text_tokens":[],"title":"FAQ","title_tokens":["faq"]},{"location":"bitxhub/faq/#_1","text":"","text_tokens":[],"title":"跨链技术","title_tokens":["跨链","技术"]},{"location":"bitxhub/faq/#1","text":"一是技术层面，区块链技术在单链架构下本身存在着性能、容量不足等问题 。单链由于受到目前共识速度的限制，节点的执行性能无法做到线性扩展，这限制了高交易吞吐量低延迟的商业场景的应用。除此之外，随着区块链运行时间的增长，其存储容量也将逐渐增长，且这种数据增长的速度甚至会超过单链存储介质的容量上限。目前的区块链共识算法、存储结构、和安全机制不同导致链与链之间缺乏统一的互联互通机制，这极大限制了区块链技术和应用生态的健康发展。 二是业务层面存在跨区块链业务的资产交换和信息交换需求 。在资产交换方面，一些区块链事实上仍处于互相隔离的状态，它们之间的资产交换主要依靠中心化的交易所来完成，中心化的交换方式既不安全规则也不透明。 而信息交换由于涉及链与链之间的数据同步和相应的跨链调用，实现更为复杂，目前各个区块链应用之间互通壁垒极高，无法有效地进行链上信息共享。","text_tokens":["做到","吞吐","这种","超过","这","复杂","信息","性能","之外","不","技术","互联","区块","场景","中心化","来","方面","目前","中心","线性","更为","统一","跨区","共识","极高","商业","存在","会","将","结构","规则","壁垒","吞吐量","在","发展","受到","延迟","需求","其","介质","随着","节点","链上","容量","资产","存储","互联互通","甚至","一些","互相","。","状态","层面","着","的","与","依靠","单链","一是","交换","交易","存储介质","架构","不同","速度","有效","透明","而","限制","存储容量","逐渐","且","共享","机制","相应","完成","链","涉及","实现","调用","方式","无法","进行","高","不足","事实上","它们","除此之外","块","除此","生态","等","下","时间","处于","二是","运行","低","隔离","既","算法","上限","安全","之间","各个","事实"," ","扩展","地","和","跨链","由于","、","主要","互通","执行","也","导致","本身","同步","问题","增长","，","健康","仍","了","应用","交易所","业务","缺乏","极大","数据"],"title":"1. 跨链的必要性","title_tokens":["必要","跨链","的","必要性",".","1"," "]},{"location":"bitxhub/faq/#2","text":"目前区块链行业已经出现了很多的跨链技术产品，主要采用公证人机制(notary schemes)、侧链/中继(sidechains/relays)、哈希锁定(Hash-locking)等技术，已经在公链的场景中有很多应用例如：闪电网络，去中心化交易所等。 联盟链场景中采用类似技术及其增强技术，解决联盟链跨链需求，目前的产品已经能够解决跨链中的关键问题： 跨链交易的验证问题，如何确认记录交易发生的区块得到了足够的确认，即交易事务中各分布式网络间的数据一致性问题； 跨链事务的原子性问题，如何管理跨链事务中的各子交易确保跨链事务整体完整的原子性，即跨链事务的发生只存在两中状态完成或失败； 不同区块链之间的协议适配问题，如何对采用不同架构与协议的区块链之间进行适配，需要跨链协议中设计可以兼容多种异构区块链的数据结构、命名规范以及通信方式等。","text_tokens":["协议","各","locking","适配","技术","锁定","；","两中","侧链","通信","公证","区块","证人","场景","设计","规范","(","分布","及其","中心化","异构","目前","中继","完整","失败","验证","中心","：","性","关键问题","一致","存在","即","各子","结构","只","足够","发生","闪电","在","增强","需求","类似","notary","兼容","解决","确保","/","关键","状态","。","中有","的","与","交易","分布式","一致性","架构","不同","布式","事务","例如","已经","能够","机制","完成","链","relays","sidechains","方式","原子",")","进行","哈希","去","联盟","hash","如何","schemes","间","或","采用","中","等","公证人","确认","以及","多种","-","对","之间"," ","命名","记录","可以","跨链","网络","主要","、","公链","整体","需要","出现","数据结构","行业","问题","产品","，","得到","很多","了","应用","管理","交易所","数据"],"title":"2. 跨链技术的可行性","title_tokens":["可行","技术","可行性","2","跨链","的","."," "]},{"location":"bitxhub/faq/#_2","text":"","text_tokens":[],"title":"产品功能","title_tokens":["产品","功能"]},{"location":"bitxhub/faq/#1_1","text":"趣链科技跨链技术平台BitXHub，提出了一套完整的通用跨链传输协议IBTP(Inter-Blokcchain Transfer Protocol), 能够完美支持和兼容任意区块链系统，实现异构区块链的无缝连接。BitXHub采用先进的中继+网关的组合技术，解决了跨链中的交易捕获、传输以及验证的核心难题，所有关键技术均具有完全自主知识产权。同时，平台具备完善的跨链接口管理、异构链成员治理、联盟权限管控等联盟跨链专用机制，是目前业界最完备的异构联盟链跨链技术平台，已经在金融、政务等业务场景中进行了相关应用验证。","text_tokens":["协议","治理","金融","一套","技术","组合","区块","场景","(","所有","异构","目前","中继","完整","提出","验证","自主","inter","关键技术","是","科技","知识产权","先进","政务","完全","在","趣链","transfer","产权","链接","管控","口","相关","系统","兼容","解决","捕获","关键","。","成员","的","protocol","业界","交易","传输","同时",",","能够","无缝","已经","知识","完备","支持","机制","任意","链","实现","完善","+",")","进行","联盟","跨","连接","最","通用","平台","采用","中","等","以及","-","均","ibtp","难题","bitxhub"," ","专用","具有","具备","完美","跨链","和","、","权限","blokcchain","，","核心","网关","了","管理","应用","业务"],"title":"1. 产品简介","title_tokens":["产品","简介","产品简介",".","1"," "]},{"location":"bitxhub/faq/#2_1","text":"BitXHub提出一种可扩展的适应不同异构区块链系统之间的跨链方案，通过设计可插拔的跨链网关技术，实现区块链网络间的的协议转换，并支持异构区块链之间的交易验证，该方案支持异构区块链之间交易的可信验证和可靠传递。 应用基于插件机制的跨链网关，实现异构应用链的快速适配与统一管理，以动态加载插件的形式随时加入平台；应用基于智能合约的异构交易验证技术，将交易验证规则进行全生命周期的管理，实现统一、高效的跨链交易合法性验证；应用基于可信事件的跨链传输协议，消除异构区块链之间技术机制的差异性，实现跨链交易格式的通用化与标准化，达成区块链平台在应用级别的可扩展性。","text_tokens":["随时","协议","合法","适配","技术","；","合约","通过","事件","区块","设计","达成","动态","展性","全","异构","异性","以","提出","验证","统一","差异","快速","合法性","并","将","插拔","规则","在","传递","方案","加入","系统","加载","生命周期","。","的","与","可","交易","传输","适应","一种","不同","智能","支持","机制","基于","链","实现","进行","差异性","通用","间","生命","平台","扩展性","可扩展性","插件","高效","级别","周期","之间","bitxhub"," ","格式","扩展","消除","和","跨链","网络","、","形式","通用化","转换","可靠","标准化","，","网关","标准","应用","管理","该","可信"],"title":"2. 实现原理","title_tokens":["实现","原理","2","."," "]},{"location":"bitxhub/faq/#3","text":"SDK 调用 具体的业务链A的合约方法； 合约方法被执行，抛出跨链事件T1； 业务链A的跨链网关监听到T1, 将其转换成IBTP结构，提交到中继链BitXHub上； BitXHub 依据相关规则对T1进行验证以及路由； 业务链B的跨链网关接受到T1并根据IBTP结构进行解析，转换成业务链B可识别的交易Tb B的跨链网关将Tb提交到业务链B上进行执行；","text_tokens":["将","结构","b",",","依据","规则","以及","到","上","链","对","ibtp","解析","sdk","抛出","bitxhub"," ","调用","其","；","接受","合约","路由","换成","转换成","tb","进行","跨链","事件","具体","相关","根据","监听","执行","转换","方法","的","t1","中继","可","a","提交","交易","验证","，","网关","被","业务","并","识别"],"title":"3. 跨链交易基本流程","title_tokens":["3","流程","基本","跨链",".","交易"," "]},{"location":"bitxhub/faq/#4","text":"跨链的完整流程所需时间： T = Ta + Thub + Tb 其中**Thub**是中继链的验证和共识所需的时间，可达到 5000TPS 左右；**Ta**和**Tb**分别是应用链A和应用链B的执行时间，其性能取决于应用链本身的执行效率。","text_tokens":["左右","thub","b","其中","效率","性能","链"," ","其","流程","取决于","t","；","+","tb","和","跨链","=","执行","。","ta","的","中继","可","达到","a","完整","取决","本身","5000tps","验证","*","，","分别","：","是","需","应用","共识","时间","所"],"title":"4. 跨链效率","title_tokens":["效率","跨链",".","4"," "]},{"location":"bitxhub/faq/#5","text":"社区版和商业版都支持基础功能： - 中继服务（跨链交易验证与路由、跨链成员管理） - 网关服务（跨链交易捕获、解析与调用） - SDK组件（GO、JAVA） 其他对比如下：","text_tokens":["go","支持","-","解析","sdk","其他"," ","调用","商业版","路由","java","对比","和","跨链","如下","、","捕获","组件","都","社区","成员","与","中继","基础","交易","版","验证","网关","（","服务","：","管理","）","功能","商业"],"title":"5. 社区版与商业版有何区别？","title_tokens":["有何","版","区别","？","商业版","社区","与","商业",".","5"," "]},{"location":"bitxhub/faq/#6","text":"目前已适配趣链区块链平台和Hyperledger Fabric，其他类型区块链（包括公链）可以按需通过插件形式灵活接入。社区版目前已提供Fabric的插件。","text_tokens":["链","按","趣链","其他","适配"," ","fabric","可以","和","通过","公链","区块","接入","包括","灵活","。","形式","社区","目前","的","提供","类型","版","，","平台","hyperledger","插件","（","需","已","）"],"title":"6. 跨链平台目前适配了哪几种应用链？","title_tokens":["平台","？","哪几种","几种","6","哪几","目前","跨链","了","应用","链",".","适配"," "]},{"location":"bitxhub/faq/#7","text":"中继链中的所有交易均以IBTP协议的数据结构进行存储、验证： 参数 说明 From 来源链ID To 目的链ID Version 协议版本号 Index 跨链交易索引 Payload 跨链调用内容编码 Timestamp 跨链事件发生的时间戳 Proof 跨链交易证明 Extra 自定义字段 其中的Payload是跨链交易的核心内容，BitXHub通过多种方式保证其安全性： - 采用特殊的编码机制，仅跨链双方可解； - 采用加密的方式，仅跨链双方持有秘钥； - 链上权限控制，非相关方无法读取相应交易（之后将核心代码开源以保证可信）； - 采用类似隐私交易的机制，仅相关控制的BitXHub节点中保存相关方跨链交易","text_tokens":["目的","index","说明","协议","隐私","id","；","to","通过","事件","所有","保证","中继","持有","以","version","特殊","方","验证","timestamp","编码","：","是","核心内容","段","）","将","结构","读取","发生","加密","其","链中","节点","控制","from","相关","链上","类似","定义","存储","payload","的","交易","双方","参数","机制","相应","心内","链","方跨","调用","方式","无法","开源","进行","可解","自定义","采用","中","内容","时间","证明","非","字","仅","其中","代码","多种","-","安全","均","ibtp","bitxhub"," ","安全性","跨链","秘钥","之后","、","版本号","权限","数据结构","proof","extra","戳","版本","索引","，","核心","（","自定","来源","保存","可信","数据"],"title":"7. 所有跨链交易都会经过中继链处理，是否会存在数据安全性问题？如何实现不同业务链跨链时的数据隔离和隐私性？","title_tokens":["会","隔离","安全","链"," ","安全性","实现","隐私","？","处理","经过","和","跨链",".","时","所有","都","是否","7","的","中继","如何","交易","问题","，","不同","性","业务","存在","数据"]},{"location":"bitxhub/faq/#8","text":"目前社区版本暂不支持，主要方案是跨链网关结合中继链中存储的跨链交易状态信息共同保障，预计于2020年9月上线，敬请期待！","text_tokens":["上线","期待","支持","保障","敬请","信息","敬请期待","不","方案","2020","链中","结合","于","跨链","月","主要","存储","状态","年","社区","目前","的","中继","交易","版本","！","，","网关","预计","是","共同","暂","9"],"title":"8. 跨链转账交易如何保证事务性？如何做回滚或补偿呢？","title_tokens":["8","回滚","或","？","补偿","事务","转账","事务性","保证","跨链","做",".","如何","交易","呢"," "]},{"location":"bitxhub/faq/#9-dataswapper","text":"验证引擎会对跨链交易、跨链交易执行结果采用SPV证明机制进行验证，来确保跨链交易和跨链交易的执行都是真实在链中发生的。 应用链中跨链的接口必须按照规定实现，验证引擎会对比跨链调用的接口以及通过SPV机制验证调用接口执行后返回的数据的有效性。","text_tokens":["真实","会","接口","以及","spv","发生","机制","引擎","对","在","链","返回"," ","实现","调用","链中","对比","进行","跨链","和","通过","结果","、","确保","执行","必须","来","。","都","后","的","规定","交易","验证","，","采用","按照","中","有效","是","有效性","应用","证明","数据"],"title":"9. 通过DataSwapper相互传递的数据，如何保证真实性呢？","title_tokens":["真实","传递","，","？","真实性","dataswapper","通过","相互","的","如何","保证",".","数据","9","呢"," "]},{"location":"bitxhub/faq/#_3","text":"","text_tokens":[],"title":"跨链准备","title_tokens":["准备","跨链"]},{"location":"bitxhub/faq/#1_2","text":"中继链本身就是一条联盟链，作为去中心化的可信中介，推荐的搭建方案是由参与跨链的各方共同维护节点来搭建中继链。","text_tokens":["参与","链","各方","方案","节点","跨链","去","联盟","就是","中心化","来","搭建","。","由","中介","的","中继","本身","一条","，","推荐","中心","维护","是","共同","作为","可信"],"title":"1. 中继链由谁维护？如何搭建？","title_tokens":["谁","？","搭建","维护","由","链","中继",".","如何","1"," "]},{"location":"bitxhub/faq/#2_2","text":"跨链网关部署是由应用链方决定的，跨链网关只负责跨链交易的收集、跨链真实性凭证收集和跨链交易执行；整个跨链操作的可信是通过验证引擎对IBTP的验证实现的，如果跨链网关篡改数据，中继链的验证引擎将不会验证通过。","text_tokens":["真实","将","操作","只","负责","真实性","收集","引擎","对","链","ibtp","不会","部署","篡改","实现","；","和","跨链","通过","决定","如果","、","执行","。","由","的","中继","链方","交易","验证","，","网关","是","应用","整个","凭证","可信","数据"],"title":"2. 跨链网关应该部署在哪里？","title_tokens":["？","网关","哪里","2","跨链","应该","在",".","部署"," "]},{"location":"bitxhub/faq/#3_1","text":"应用链适配工作包括： 1. 根据我们提供的模板撰写跨链路由合约broker, 主要一方面将自己的合约某些方法提供给其他方使用；二是提供接受来自其他方的交换的信息或资产接口 2. 对于需要跨链的方法，添加调用跨链的逻辑，就是调用我们提供的跨链合约接口 3. 部署跨链网关（常见区块链无需改造，特殊的区块链只需要提供和区块链相关的SDK基本就可以） 4. 将应用链的信息注册到BitXHub中，如链的ID，节点数量，共识算法类型等 5. 根据应用链的共识机制编写交易的验证规则，详见 验证规则编写文档","text_tokens":["工作","broker","模板","信息","到","sdk","其他","适配","部署","id","来自","无需","；","合约","区块","就是","方面","给","文档","5","类型","特殊","方","验证","：","共识","）","将","只","规则","对于","节点","相关","资产","一方面","如链","的","交换","交易","使用","添加",",","接口","机制","链","逻辑","调用",".","根据","包括","跨","由","提供","数量","或","中","等","一方","2","链路","二是","注册","算法","常见","4","bitxhub"," ","3","接受","可以","和","跨链","某些","详见","主要","撰写","我们","需要","编写","方法","，","自己","网关","（","基本","改造","应用","就","1"],"title":"3. 对于未适配应用链需要做哪些开发工作，改造的工作量是多少？","title_tokens":["工作","做","链","对于","适配"," ","3","未","？","工作量",".","需要","的","开发","，","改造","哪些","是","应用","多少"]},{"location":"bitxhub/faq/#_4","text":"","text_tokens":[],"title":"跨链操作","title_tokens":["跨链","操作"]},{"location":"bitxhub/faq/#1-fabrictoken","text":"wiki中给出的例子是一个模拟资产操作的一个合约，对资产模型没做特定的假设。","text_tokens":["操作","一个","做","对","假设","给出","合约","wiki","资产","。","没","的","，","中","模拟","是","特定","例子","模型"],"title":"1. Fabric没有token，在跨链转账时使用的是什么资产模型？","title_tokens":["什么","，","时","token","？","fabric","转账","使用","是","跨链","的","没有","在","资产",".","模型","1"," "]},{"location":"bitxhub/faq/#2_3","text":"对于已有的业务合约需要进行一定的改造，即实现规定的几个接口，详见 业务合约改造文档","text_tokens":["实现","，","即","需要","接口","合约","改造","一定","业务","的","进行","文档","详见","几个","对于","规定","已有"," "],"title":"2. 对于已经存在业务的应用链，是不是需要更改原来的业务合约才能兼容新的资产类型？","title_tokens":["已经","链","对于"," ","原来","？","是不是","合约","兼容",".","资产","才能","需要","新","的","不是","类型","，","更改","2","应用","业务","存在"]},{"location":"bitxhub/join_us/","text":"加入我们 我们提供了高质量的区块链跨链交流社群，社群内不仅可以与区块链行业大咖、区块链技术专家零距离交流，还会有不定期的小礼品等待着大家。欢迎各位朋友踊跃加入，让我们一起探讨和感受跨链的魅力。 BitXHub开源社区微信群·小助手 **趣链科技官方公共号 **","text_tokens":["距离","踊跃","和","一起","链","公共","号","趣链","bitxhub","高质"," ","感受","微信群","交流","技术","让","内","大家","开源","官方","可以","不仅","欢迎","跨链","加入","高质量","大","专家","各位","、","有","区块","社群","等待","还会","我们","探讨","不定期","。","小","着","咖","朋友","社区","的","与","行业","各位朋友","提供","质量","助手","·","礼品","，","*","定期","了","魅力","不定","科技","零距离"],"title":"加入我们","title_tokens":["加入","我们"]},{"location":"bitxhub/join_us/#_1","text":"我们提供了高质量的区块链跨链交流社群，社群内不仅可以与区块链行业大咖、区块链技术专家零距离交流，还会有不定期的小礼品等待着大家。欢迎各位朋友踊跃加入，让我们一起探讨和感受跨链的魅力。 BitXHub开源社区微信群·小助手 **趣链科技官方公共号 **","text_tokens":["距离","和","一起","链","公共","号","趣链","bitxhub","高质"," ","感受","微信群","交流","技术","让","内","大家","开源","官方","可以","不仅","欢迎","跨链","大","高质量","专家","各位","踊跃","、","有","区块","社群","加入","等待","还会","我们","探讨","不定期","。","小","着","咖","朋友","社区","的","与","行业","各位朋友","提供","质量","助手","·","礼品","，","*","定期","了","魅力","不定","科技","零距离"],"title":"加入我们","title_tokens":["加入","我们"]},{"location":"bitxhub/quick_start/","text":"快速开始 我们提供了Goduck运维小工具来快速体验跨链流程。 1 环境准备 Goduck快速开始依赖于Docker和Docker-Compose，需要提前准备好 docker环境 。 2 下载 Goduck ！！！注意： 执行上述命令的路径下应该没有goduck同名目录 在启动跨链网络过程中，如果遇到网络等问题，请运行以下命令： goduck playground clean 下载Goduck可执行二进制文件： curl https://raw.githubusercontent.com/meshplus/goduck/release-1.0/scripts/goduck.sh -L -o - | bash 查询goduck命令的路径： $ which goduck /usr/local/bin/goduck 3 初始化 初始化goduck配置文件，命令如下： goduck init 4 启动跨链网络 在本地启动一个solo版本的BitXHub节点、两条以太坊私有链以及相应的两个跨链网关，启动命令如下： goduck playground start 该命令执行的具体操作包括以下步骤 ： 获取相关镜像： 镜像拉取成功后将会打印日志如下： Creating network \"quick_start_default\" with the default driver Creating ethereum-1 ... done Creating bitxhub_solo ... done Creating ethereum-2 ... done Creating pier-ethereum-2 ... done Creating pier-ethereum-1 ... done Attaching to bitxhub_solo, ethereum-2, ethereum-1, pier-ethereum-1, pier-ethereum-2 启动两条以太坊私有链ethereum-1和ethereum-2： 以太坊私有链ethereum-1和ethereum-2启动成功后，最终会打印出日志如下： ethereum-2 | INFO [ 04 -02 | 02 :41:57.348 ] Sealing paused, waiting for transactions ethereum-1 | INFO [ 04 -02 | 02 :41:57.349 ] Sealing paused, waiting for transactions 启动中继链bitxhub_solo： 启动一条solo模式的中继链，启动成功后将会打印出BitXHub的logo如下： bitxhub_solo | ======================================================= bitxhub_solo | ____ _ __ _ __ __ __ __ bitxhub_solo | / __ ) ( _ ) / /_ | | / / / / / / __ __ / /_ bitxhub_solo | / __ | / / / __/ | / / /_/ / / / / / / __ \\ bitxhub_solo | / /_/ / / / / /_ / | / __ / / /_/ / / /_/ / bitxhub_solo | /_____/ /_/ \\_ _/ /_/ | _ | /_/ /_/ \\_ _,_/ /_.___/ bitxhub_solo | bitxhub_solo | ======================================================= 注册应用链： 创建两个与应用链对应的跨链网关，通过跨链网关向中继链注册应用链信息，注册成功后会打印出应用链id如下： pier-ethereum-1 | appchain register successfully, id is 0xb132702a7500507411f3bd61ab33d9d350d41a37 pier-ethereum-2 | appchain register successfully, id is 0x9f5cf4b97965ababe19fcf3f1f12bb794a7dc279 部署验证规则 跨链网关向中继链部署应用链的验证规则，部署成功后将打印日志如下： pier-ethereum-1 | Deploy rule to bitxhub successfully pier-ethereum-2 | Deploy rule to bitxhub successfully 启动跨链网关 跨链网关完成注册应用链、部署验证规则两步后即可启动，启动成功后跨链网关会打印出日志如下： pier-ethereum-1 | time = \"02:42:02.287\" level = info msg = \"Exchanger started\" module = exchanger pier-ethereum-2 | time = \"02:42:02.349\" level = info msg = \"Exchanger started\" module = exchanger 中继链会打印出日志如下： bitxhub_solo | time=\"02:42:02.291\" level=info msg=\"Add pier\" id=0xb132702a7500507411f3bd61ab33d9d350d41a37 module=router bitxhub_solo | time=\"02:42:02.353\" level=info msg=\"Add pier\" id=0x9f5cf4b97965ababe19fcf3f1f12bb794a7dc279 module=router 5 跨链交易 分别在两条以太坊应用链上发起跨链交易，执行命令如下： goduck playground transfer 该命令会调用以太坊上的合约（以太坊镜像上已经部署好合约）发起两笔跨链交易： - 从ethereum-1的Alice账户转账1到ethereum-2的Alice账户 - 从ethereum-2的Alice账户转账1到ethereum-1的Alice账户 信息打印出如下： // 查询账户余额 1 . Query original accounts in appchains // 以太坊1的Alice账户余额为10000 Query Alice account in ethereum-1 appchain ======= invoke function getBalance ======= call result: 10000 // 以太坊2的Alice账户余额为10000 Query Alice account in ethereum-2 appchain ======= invoke function getBalance ======= call result: 10000 // 从以太坊1的Alice账户转账1到以太坊2的Alice账户 2 . Send 1 coin from Alice in ethereum-1 to Alice in ethereum-2 ======= invoke function transfer ======= =============== Transaction hash is ============== 0xff42eb87410f7ed4c8bf394716b7f202d4f307191e5ac2ef3cfb77fabd8211a0 // 查询账户余额 3 . Query accounts after the first-round invocation // 以太坊1的Alice账户余额为9999 Query Alice account in ethereum-1 appchain ======= invoke function getBalance ======= call result: 9999 // 以太坊2的Alice账户余额为10001 Query Alice account in ethereum-2 appchain ======= invoke function getBalance ======= call result: 10001 // 从以太坊2的Alice账户转账1到以太坊1的Alice账户 4 . Send 1 coin from Alice in ethereum-2 to Alice in ethereum-1 ======= invoke function transfer ======= =============== Transaction hash is ============== 0x0c8042a3539cd49ce5d0570afbdb625697aadf71a040203f6bc03e3a43fb71b5 // 查询账户余额 5 . Query accounts after the second-round invocation // 以太坊1的Alice账户余额为10000 Query Alice account in ethereum-1 appchain ======= invoke function getBalance ======= call result: 10000 // 以太坊2的Alice账户余额为10000 Query Alice account in ethereum-2 appchain ======= invoke function getBalance ======= call result: 10000","text_tokens":["o","10000","time","1.0","准备","信息","started","遇到","上","到","send","为","创建","[","同名","请","id","register","部署","流程","]","deploy","两笔","bin","02","to","合约","l","0xff42eb87410f7ed4c8bf394716b7f202d4f307191e5ac2ef3cfb77fabd8211a0","如果","通过","具体","$","日志","is","add","____","9999","57.349","(","with","alice","来","attaching","转账","应该","赖于","中继","环境","_","体验","...","模式","5","验证","两步","：","rule","usr","快速","成功","获取","quick","02.349","）","会","将",":","工具","操作","clean","规则","sealing","02.287","在","sh","具体操作","msg","transfer","本地","0x0c8042a3539cd49ce5d0570afbdb625697aadf71a040203f6bc03e3a43fb71b5","配置文件","节点","from","init","体操","两条","相关","链上","account","=","注意","提前准备","/","。","02.291","local","ethereum","后","10001","paused","的","与","没有","启动","可","the","交易","！","一条","余额","对应","default","分别","playground","_____","拉取","module","pier","query","02.353","从","坊","appchain",",","driver","好","上述","一个","已经","goduck","first","相应","for","info","完成","链","solo","\"","compose","41","invoke","调用","依赖于","in","42","提前","done",")","即可","accounts","运维小","如下","过程",".","文件","exchanger","waiting","查询","依赖","包括","coin","network","出","04","hash","提供","57.348","命令","githubusercontent","两个","发起","私有","路径","transactions","result","中","等","transaction","2","\\","下","function","https","second","运行","start","注册","执行命令","com","0xb132702a7500507411f3bd61ab33d9d350d41a37","round","二进制","以及","call","目录","-","1","creating","配置","_.___","4","bitxhub","meshplus"," ","after","3","docker","router","getbalance","which","和","跨链","|","网络","链会","、","raw","logo","进制","执行","初始","需要","我们","release","步骤","original","打印","scripts","level","appchains","最终","以太","0x9f5cf4b97965ababe19fcf3f1f12bb794a7dc279","版本","下载","问题","__","，","网关","（","bash","invocation","successfully","向","curl","了","初始化","镜像","应用","该","以下","开始","账户"],"title":"快速开始","title_tokens":["快速","开始"]},{"location":"bitxhub/quick_start/#_1","text":"我们提供了Goduck运维小工具来快速体验跨链流程。","text_tokens":["流程","我们","工具","来","。","goduck","跨链","运维小","了","提供","快速","体验"],"title":"快速开始","title_tokens":["快速","开始"]},{"location":"bitxhub/quick_start/#1","text":"Goduck快速开始依赖于Docker和Docker-Compose，需要提前准备好 docker环境 。","text_tokens":["好","goduck","-","准备"," ","compose","依赖于","docker","提前","和","提前准备","需要","依赖","。","赖于","环境","，","快速","开始"],"title":"1 环境准备","title_tokens":["准备","环境","1"," "]},{"location":"bitxhub/quick_start/#2-goduck","text":"！！！注意： 执行上述命令的路径下应该没有goduck同名目录 在启动跨链网络过程中，如果遇到网络等问题，请运行以下命令： goduck playground clean 下载Goduck可执行二进制文件： curl https://raw.githubusercontent.com/meshplus/goduck/release-1.0/scripts/goduck.sh -L -o - | bash 查询goduck命令的路径： $ which goduck /usr/local/bin/goduck","text_tokens":["o",":","com","上述","clean","二进制","goduck","目录","-","1.0","在","遇到","sh","meshplus","同名"," ","请","bin","l","which","如果","跨链","|","网络","过程","$",".","文件","注意","raw","/","进制","执行","查询","release","local","scripts","的","应该","没有","启动","可","命令","githubusercontent","！","下载","问题","，","路径","bash","：","中","playground","等","curl","下","https","usr","以下","运行"],"title":"2 下载 Goduck","title_tokens":["下载","2","goduck"," "]},{"location":"bitxhub/quick_start/#3","text":"初始化goduck配置文件，命令如下： goduck init","text_tokens":["初始","，","文件","配置文件","：","goduck","init","初始化","如下","配置","命令"," "],"title":"3 初始化","title_tokens":["3","初始","初始化"," "]},{"location":"bitxhub/quick_start/#4","text":"在本地启动一个solo版本的BitXHub节点、两条以太坊私有链以及相应的两个跨链网关，启动命令如下： goduck playground start 该命令执行的具体操作包括以下步骤 ： 获取相关镜像： 镜像拉取成功后将会打印日志如下： Creating network \"quick_start_default\" with the default driver Creating ethereum-1 ... done Creating bitxhub_solo ... done Creating ethereum-2 ... done Creating pier-ethereum-2 ... done Creating pier-ethereum-1 ... done Attaching to bitxhub_solo, ethereum-2, ethereum-1, pier-ethereum-1, pier-ethereum-2 启动两条以太坊私有链ethereum-1和ethereum-2： 以太坊私有链ethereum-1和ethereum-2启动成功后，最终会打印出日志如下： ethereum-2 | INFO [ 04 -02 | 02 :41:57.348 ] Sealing paused, waiting for transactions ethereum-1 | INFO [ 04 -02 | 02 :41:57.349 ] Sealing paused, waiting for transactions 启动中继链bitxhub_solo： 启动一条solo模式的中继链，启动成功后将会打印出BitXHub的logo如下： bitxhub_solo | ======================================================= bitxhub_solo | ____ _ __ _ __ __ __ __ bitxhub_solo | / __ ) ( _ ) / /_ | | / / / / / / __ __ / /_ bitxhub_solo | / __ | / / / __/ | / / /_/ / / / / / / __ \\ bitxhub_solo | / /_/ / / / / /_ / | / __ / / /_/ / / /_/ / bitxhub_solo | /_____/ /_/ \\_ _/ /_/ | _ | /_/ /_/ \\_ _,_/ /_.___/ bitxhub_solo | bitxhub_solo | ======================================================= 注册应用链： 创建两个与应用链对应的跨链网关，通过跨链网关向中继链注册应用链信息，注册成功后会打印出应用链id如下： pier-ethereum-1 | appchain register successfully, id is 0xb132702a7500507411f3bd61ab33d9d350d41a37 pier-ethereum-2 | appchain register successfully, id is 0x9f5cf4b97965ababe19fcf3f1f12bb794a7dc279","text_tokens":["信息","创建","[","id","register","]","02","to","通过","具体","日志","is","____","57.349","(","with","attaching","中继","_","...","模式","：","成功","获取","quick","会","将",":","操作","sealing","在","具体操作","本地","节点","体操","相关","两条","=","/","ethereum","后","paused","的","与","启动","the","一条","对应","default","playground","_____","拉取","pier","坊","appchain",",","driver","一个","goduck","相应","for","info","链","solo","\"","41","done",")","如下","waiting","包括","network","出","04","57.348","命令","两个","私有","transactions","2","\\","start","注册","0xb132702a7500507411f3bd61ab33d9d350d41a37","以及","-","creating","_.___","bitxhub"," ","和","跨链","|","、","logo","执行","步骤","打印","最终","以太","0x9f5cf4b97965ababe19fcf3f1f12bb794a7dc279","版本","__","，","网关","successfully","向","镜像","应用","该","以下","1"],"title":"4 启动跨链网络","title_tokens":["跨链","启动","网络","4"," "]},{"location":"bitxhub/quick_start/#_2","text":"跨链网关向中继链部署应用链的验证规则，部署成功后将打印日志如下： pier-ethereum-1 | Deploy rule to bitxhub successfully pier-ethereum-2 | Deploy rule to bitxhub successfully","text_tokens":["将","pier","规则","-","链","部署","deploy"," ","bitxhub","to","跨链","|","如下","日志","打印","ethereum","后","的","中继","验证","，","网关","：","successfully","向","2","应用","rule","成功","1"],"title":"部署验证规则","title_tokens":["验证","部署","规则"]},{"location":"bitxhub/quick_start/#_3","text":"跨链网关完成注册应用链、部署验证规则两步后即可启动，启动成功后跨链网关会打印出日志如下： pier-ethereum-1 | time = \"02:42:02.287\" level = info msg = \"Exchanger started\" module = exchanger pier-ethereum-2 | time = \"02:42:02.349\" level = info msg = \"Exchanger started\" module = exchanger 中继链会打印出日志如下： bitxhub_solo | time=\"02:42:02.291\" level=info msg=\"Add pier\" id=0xb132702a7500507411f3bd61ab33d9d350d41a37 module=router bitxhub_solo | time=\"02:42:02.353\" level=info msg=\"Add pier\" id=0x9f5cf4b97965ababe19fcf3f1f12bb794a7dc279 module=router","text_tokens":["会","注册","pier",":","0xb132702a7500507411f3bd61ab33d9d350d41a37","time","规则","-","started","02.287","完成","链","info","solo","\"","部署","msg"," ","bitxhub","02.349","id","02","42","router","即可","跨链","|","如下","链会","日志","、","=","exchanger","add","打印","ethereum","02.291","后","level","出","启动","中继","_","0x9f5cf4b97965ababe19fcf3f1f12bb794a7dc279","验证","，","两步","网关","：","2","应用","module","成功","02.353","1"],"title":"启动跨链网关","title_tokens":["网关","跨链","启动"]},{"location":"bitxhub/quick_start/#5","text":"分别在两条以太坊应用链上发起跨链交易，执行命令如下： goduck playground transfer 该命令会调用以太坊上的合约（以太坊镜像上已经部署好合约）发起两笔跨链交易： - 从ethereum-1的Alice账户转账1到ethereum-2的Alice账户 - 从ethereum-2的Alice账户转账1到ethereum-1的Alice账户 信息打印出如下： // 查询账户余额 1 . Query original accounts in appchains // 以太坊1的Alice账户余额为10000 Query Alice account in ethereum-1 appchain ======= invoke function getBalance ======= call result: 10000 // 以太坊2的Alice账户余额为10000 Query Alice account in ethereum-2 appchain ======= invoke function getBalance ======= call result: 10000 // 从以太坊1的Alice账户转账1到以太坊2的Alice账户 2 . Send 1 coin from Alice in ethereum-1 to Alice in ethereum-2 ======= invoke function transfer ======= =============== Transaction hash is ============== 0xff42eb87410f7ed4c8bf394716b7f202d4f307191e5ac2ef3cfb77fabd8211a0 // 查询账户余额 3 . Query accounts after the first-round invocation // 以太坊1的Alice账户余额为9999 Query Alice account in ethereum-1 appchain ======= invoke function getBalance ======= call result: 9999 // 以太坊2的Alice账户余额为10001 Query Alice account in ethereum-2 appchain ======= invoke function getBalance ======= call result: 10001 // 从以太坊2的Alice账户转账1到以太坊1的Alice账户 4 . Send 1 coin from Alice in ethereum-2 to Alice in ethereum-1 ======= invoke function transfer ======= =============== Transaction hash is ============== 0x0c8042a3539cd49ce5d0570afbdb625697aadf71a040203f6bc03e3a43fb71b5 // 查询账户余额 5 . Query accounts after the second-round invocation // 以太坊1的Alice账户余额为10000 Query Alice account in ethereum-1 appchain ======= invoke function getBalance ======= call result: 10000 // 以太坊2的Alice账户余额为10000 Query Alice account in ethereum-2 appchain ======= invoke function getBalance ======= call result: 10000","text_tokens":["10000","信息","上","到","send","为","部署","alice","两笔","to","合约","0xff42eb87410f7ed4c8bf394716b7f202d4f307191e5ac2ef3cfb77fabd8211a0","is","9999","转账","5","：","）","会",":","在","transfer","0x0c8042a3539cd49ce5d0570afbdb625697aadf71a040203f6bc03e3a43fb71b5","from","链上","两条","account","=","/","10001","ethereum","的","the","交易","余额","分别","playground","query","从","坊","appchain","已经","好","goduck","first","invoke","调用","in","accounts","如下",".","查询","coin","出","hash","命令","发起","result","transaction","2","function","second","执行命令","round","call","-","4"," ","after","3","getbalance","跨链","执行","original","打印","appchains","以太","，","（","invocation","应用","镜像","该","1","账户"],"title":"5 跨链交易","title_tokens":["跨链","交易","5"," "]},{"location":"bitxhub/architecture/arch/","text":"技术架构 BitXHub中继链的技术架构自下而上分为物理层、基础层、跨链服务层、接口层四个部分。 TODO: 图片修改为IBTP1.0 第一层是物理层，中继链的设计为了满足不同场景下用户物理环境需求，支持在普通物理机、云主机或者嵌入式设备上稳定运行，兼顾多场景适用性。 第二层是基础层，这一层包含了联盟链本身需要具备的模块，比如网络模块、存储模块、共识模块、虚拟机、隐私安全模块。 P2P网络是节点之间共识和信息传递的通道，是平台的网络通信基础。目前平台采用Libp2p网络库，支持TCP和QUIC等不同的传输协议，满足不同网络条件下的稳定通信。 根据数据类型的不同，平台设计了符合相应类型的存储模式。用于保证数据操作的原子性和持久性，平台选用WAL(Write Ahead Log) 预写日志；针对随机性较强的Key/Value类型的区块链状态数据，平台选用高性能存储引擎LevelDB。 虚拟机模块整合了能够完成复杂逻辑验证的Webassembly虚拟机，对跨链交易进行验证。 采用可插拔的加密机制，对于业务完整生命周期所涉及的数据、通信传输、物理连接等方面都进行了不同策略的加密，通过多级加密保证平台数据的安全，而且完全支持国密算法。 第三层是跨链相关的服务层，包括应用链管理模块、执行模块、事务管理模块、验证引擎模块和隐私保护模块，各模块互相协作完成中继跨链流程。 链管理模块主要负责应用链注册、审核和冻结等操作； 执行模块负责跨链交易的检查、处理和验证工作； 事务管理模块负责跨链交易在整个系统处理的一致性； 验证引擎模块在Webassembly虚拟机之上实现了跨链交易存在性和有效性的验证逻辑； 隐私保护模块提供对于跨链数据本身的隐私保护功能。 第四层是接口层，中继链对外提供gRPC和Restful两种接口服务，支持不同场景下用户的使用。同时，为了能够支持异构区块链之间的跨链交易路由和可信验证，BitXHub设计了通用的跨链传输协议IBTP（InterBlockchain Transfer Protocol），允许异构资产、数据及服务进行跨链调用。","text_tokens":["ibtp1.0","工作","这","复杂","模块","协议","普通","包含","信息","上","性能","各","事务管理","为","用户","隐私","流程","技术","比如","；","处理","检查","物理","通信","通过","日志","嵌入式","区块","场景","设计","(","一层","方面","异构","保证","目前","满足","中继","之上","环境","完整","类型","模式","验证","自下而上","是","性","共识","多级","整个","一致","）","高性","存在","设备","针对",":","机","操作","随机","插拔","冻结","第三层","第四层","完全","第三","在","选用","对于","而且","保证数据","加密","transfer","需求","传递","第四","嵌入","节点","log","相关","系统","write","资产","稳定","图片","生命周期","/","网络通信","存储","状态","互相","第一层","物理层","。","存储模块","及","的","通道","整合","protocol","value","可","交易","传输","架构","层","一致性","对外","不同","事务","为了","第二","或者","有效","使用","条件","随机性","所","同时","两种","库","能够","接口","允许","todo","支持","相应","高性能","机制","完成","链","审核","协作","涉及","实现","逻辑","调用","ahead","原子","保护",")","第二层","进行","webassembly","根据","联盟","第一","包括","持久","都","连接","适用","wal","提供","基础","适用性","通用","生命","平台","采用","主机","tcp","兼顾","数据类型","等","四层","下","较强","功能","运行","二层","注册","interblockchain","周期","算法","部分","负责","安全","引擎","对","三层","之间","ibtp","bitxhub","restful"," ","云","具备","策略","路由","和","跨链","虚拟机","网络","、","主要","grpc","符合","执行","用于","leveldb","需要","四个","key","p2p","国密","多","本身","分为","，","修改","quic","libp2p","服务","（","预写","有效性","了","应用","虚拟","管理","业务","持久性","可信","数据"],"title":"技术架构","title_tokens":["架构","技术"]},{"location":"bitxhub/architecture/arch/#_1","text":"BitXHub中继链的技术架构自下而上分为物理层、基础层、跨链服务层、接口层四个部分。 TODO: 图片修改为IBTP1.0 第一层是物理层，中继链的设计为了满足不同场景下用户物理环境需求，支持在普通物理机、云主机或者嵌入式设备上稳定运行，兼顾多场景适用性。 第二层是基础层，这一层包含了联盟链本身需要具备的模块，比如网络模块、存储模块、共识模块、虚拟机、隐私安全模块。 P2P网络是节点之间共识和信息传递的通道，是平台的网络通信基础。目前平台采用Libp2p网络库，支持TCP和QUIC等不同的传输协议，满足不同网络条件下的稳定通信。 根据数据类型的不同，平台设计了符合相应类型的存储模式。用于保证数据操作的原子性和持久性，平台选用WAL(Write Ahead Log) 预写日志；针对随机性较强的Key/Value类型的区块链状态数据，平台选用高性能存储引擎LevelDB。 虚拟机模块整合了能够完成复杂逻辑验证的Webassembly虚拟机，对跨链交易进行验证。 采用可插拔的加密机制，对于业务完整生命周期所涉及的数据、通信传输、物理连接等方面都进行了不同策略的加密，通过多级加密保证平台数据的安全，而且完全支持国密算法。 第三层是跨链相关的服务层，包括应用链管理模块、执行模块、事务管理模块、验证引擎模块和隐私保护模块，各模块互相协作完成中继跨链流程。 链管理模块主要负责应用链注册、审核和冻结等操作； 执行模块负责跨链交易的检查、处理和验证工作； 事务管理模块负责跨链交易在整个系统处理的一致性； 验证引擎模块在Webassembly虚拟机之上实现了跨链交易存在性和有效性的验证逻辑； 隐私保护模块提供对于跨链数据本身的隐私保护功能。 第四层是接口层，中继链对外提供gRPC和Restful两种接口服务，支持不同场景下用户的使用。同时，为了能够支持异构区块链之间的跨链交易路由和可信验证，BitXHub设计了通用的跨链传输协议IBTP（InterBlockchain Transfer Protocol），允许异构资产、数据及服务进行跨链调用。","text_tokens":["ibtp1.0","工作","这","复杂","模块","协议","普通","包含","信息","上","性能","各","事务管理","为","用户","隐私","流程","技术","比如","；","处理","检查","物理","通信","通过","日志","嵌入式","区块","场景","设计","(","一层","方面","异构","保证","目前","满足","中继","之上","环境","完整","类型","模式","验证","自下而上","是","性","共识","多级","整个","一致","）","高性","存在","设备","针对",":","机","操作","随机","插拔","冻结","第三层","第四层","完全","第三","在","选用","对于","而且","保证数据","加密","transfer","需求","传递","第四","嵌入","节点","log","相关","系统","write","资产","稳定","图片","生命周期","/","网络通信","存储","状态","互相","第一层","物理层","。","存储模块","及","的","通道","整合","protocol","value","可","交易","传输","架构","层","一致性","对外","不同","事务","为了","第二","或者","有效","使用","条件","随机性","所","同时","两种","库","能够","接口","允许","todo","支持","相应","高性能","机制","完成","链","审核","协作","涉及","实现","逻辑","调用","ahead","原子","保护",")","第二层","进行","webassembly","根据","联盟","第一","包括","持久","都","连接","适用","wal","提供","基础","适用性","通用","生命","平台","采用","主机","tcp","兼顾","数据类型","等","四层","下","较强","功能","运行","二层","注册","interblockchain","周期","算法","部分","负责","安全","引擎","对","三层","之间","ibtp","bitxhub","restful"," ","云","具备","策略","路由","和","跨链","虚拟机","网络","、","主要","grpc","符合","执行","用于","leveldb","需要","四个","key","p2p","国密","多","本身","分为","，","修改","quic","libp2p","服务","（","预写","有效性","了","应用","虚拟","管理","业务","持久性","可信","数据"],"title":"技术架构","title_tokens":["架构","技术"]},{"location":"bitxhub/architecture/flexible_arch/","text":"中继链架构 中继链架构由中继链和跨链网关组成。对于简单跨链场景，如下图 1-1 中，应用链 A 和应用链 B 之间的跨链操作，中继链 A 负责跨链交易的验证和存证，跨链网关在中继链和应用链间负责跨链交易的监听、同步和执行。 但由于中继链接入应用链的数量有限，为了更好地满足大规模跨链场景，需要接入多个中继链进行跨链。中继链间跨链通过跨链网关组成的跨链交易路由网络进行路由。如图 1-1 所示，应用链 A 想发送跨链交易到应用链 D 时，首先需要把跨链交易提交到中继链 A 中，跨链网关 A 同步到该跨链交易后，发现目的链不在中继链 A 负责的应用链联盟里面，就把跨链交易同步到跨链交易路由网络中。跨链网关从路由网络中同步到该跨链交易后，提交到中继链 B，最后，由跨链网关提交到应用链 D 完成整个跨链操作。 中继链架构适用于安全性、可追溯性比较高的场景，可构建大规模异构区块链跨链网络。 链对链架构 对于安全性要求不高的场景，可以不借助中继链进行跨链操作，如图 1-2 是由跨链网关组成的链对链架构。如应用链 A 和应用链 B 的跨链互操作直接通过中间的跨链路由网络进行跨链交易的同步和传输，跨链交易的真实性验证也由跨链网关完成。 主侧链架构 如果参与方存在上下级的治理关系，可以选用主侧链架构。如图 1-3 中，中继链充当主链，负责侧链成员管理、数据一致性保障、核心数据存证等，且中继链的不可篡改特性可以方便实现跨链交易的原子性保障，中继链通过高性能智能合约的方式将跨链安全性验证规则化，方便实现异构区块链之间跨链交易验证的方法注入、升级；侧链通过跨链网关接入主链，负责承载具体的业务服务，形成可横向扩展的侧链集群。采用跨链网关的方式对接具体的应用侧链可以减少对具体数据治理链的侵入性，特别是针对异构数据治理链，网关可以将跨链交易转换成中继可解析验证的格式，对跨链互联服务屏蔽具体区块链的数据差异性；网关和中继链分离的方案可以保证中继链的稳定性。","text_tokens":["目的","屏蔽","到","性能","治理","篡改","不","如","；","互联","合约","侧链","通过","如果","上下级","具体","区块","场景","对接","异性","异构","保证","存证","满足","中继","图","所示","验证","简单","入","分离","差异","性","是","整个","一致","存在","高性","真实","充当","针对","将","操作","如图","主侧","横向","规则","在","选用","对于","方案","链接","该","构建","参与方","形成","稳定","下级","监听","里面","。","后","成员","的","可","提交","交易","传输","架构","一致性","为了","智能","侵入","从","特别","不可","想","上下","且","真实性","高性能","完成","链","规模","实现","特性","但","方式","原子","集群","发现","进行","如下","高","方便","转换成","大规","联盟","接入","借助","跨","由","主链","适用","要求","差异性","数量","首先","比较","采用","可追溯","关系","中","等","2","业务","多个","不高","换成","链路","减少","b","大规模","有限","参与","负责","保障","追溯","-","安全","直接","对","解析","之间","发送"," ","安全性","规则化","格式","3","注入","扩展","最后","路由","地","于","和","跨链","可以","升级","网络","由于","d","、","更好","承载","组成","执行","中间","也","时","需要","互操作","定性","转换","方法","稳定性","a","同步","，","核心","网关","服务","链间","应用","管理","把","就","1","数据"],"title":"产品架构","title_tokens":["产品","架构"]},{"location":"bitxhub/architecture/flexible_arch/#_1","text":"中继链架构由中继链和跨链网关组成。对于简单跨链场景，如下图 1-1 中，应用链 A 和应用链 B 之间的跨链操作，中继链 A 负责跨链交易的验证和存证，跨链网关在中继链和应用链间负责跨链交易的监听、同步和执行。 但由于中继链接入应用链的数量有限，为了更好地满足大规模跨链场景，需要接入多个中继链进行跨链。中继链间跨链通过跨链网关组成的跨链交易路由网络进行路由。如图 1-1 所示，应用链 A 想发送跨链交易到应用链 D 时，首先需要把跨链交易提交到中继链 A 中，跨链网关 A 同步到该跨链交易后，发现目的链不在中继链 A 负责的应用链联盟里面，就把跨链交易同步到跨链交易路由网络中。跨链网关从路由网络中同步到该跨链交易后，提交到中继链 B，最后，由跨链网关提交到应用链 D 完成整个跨链操作。 中继链架构适用于安全性、可追溯性比较高的场景，可构建大规模异构区块链跨链网络。","text_tokens":["目的","到","不","通过","区块","场景","异构","存证","满足","中继","图","所示","验证","简单","入","性","整个","操作","如图","在","对于","链接","该","构建","监听","里面","。","后","的","可","提交","交易","架构","为了","从","想","完成","链","规模","但","发现","进行","如下","高","大规","联盟","接入","由","适用","数量","首先","比较","可追溯","中","多个","b","大规模","有限","负责","追溯","-","安全","之间","发送"," ","安全性","最后","路由","地","于","和","跨链","网络","由于","d","、","更好","组成","执行","时","需要","a","同步","，","网关","链间","应用","把","就","1"],"title":"中继链架构","title_tokens":["架构","链","中继"]},{"location":"bitxhub/architecture/flexible_arch/#_2","text":"对于安全性要求不高的场景，可以不借助中继链进行跨链操作，如图 1-2 是由跨链网关组成的链对链架构。如应用链 A 和应用链 B 的跨链互操作直接通过中间的跨链路由网络进行跨链交易的同步和传输，跨链交易的真实性验证也由跨链网关完成。","text_tokens":["真实","b","操作","如图","真实性","-","安全","直接","完成","链","对","对于"," ","安全性","不","如","可以","进行","跨链","和","通过","网络","场景","组成","中间","也","借助","。","跨","由","互操作","的","要求","中继","a","交易","传输","同步","架构","验证","，","网关","是","2","应用","不高","链路","1"],"title":"链对链架构","title_tokens":["架构","对","链"]},{"location":"bitxhub/architecture/flexible_arch/#_3","text":"如果参与方存在上下级的治理关系，可以选用主侧链架构。如图 1-3 中，中继链充当主链，负责侧链成员管理、数据一致性保障、核心数据存证等，且中继链的不可篡改特性可以方便实现跨链交易的原子性保障，中继链通过高性能智能合约的方式将跨链安全性验证规则化，方便实现异构区块链之间跨链交易验证的方法注入、升级；侧链通过跨链网关接入主链，负责承载具体的业务服务，形成可横向扩展的侧链集群。采用跨链网关的方式对接具体的应用侧链可以减少对具体数据治理链的侵入性，特别是针对异构数据治理链，网关可以将跨链交易转换成中继可解析验证的格式，对跨链互联服务屏蔽具体区块链的数据差异性；网关和中继链分离的方案可以保证中继链的稳定性。","text_tokens":["屏蔽","性能","治理","篡改","；","互联","合约","侧链","如果","通过","上下级","具体","区块","对接","异性","异构","保证","存证","中继","验证","分离","差异","性","是","一致","高性","存在","充当","针对","将","如图","主侧","横向","规则","选用","方案","参与方","形成","稳定","下级","。","成员","的","可","交易","架构","一致性","智能","侵入","特别","不可","上下","且","高性能","链","实现","特性","方式","原子","集群","方便","接入","主链","差异性","采用","关系","中","等","换成","减少","参与","负责","保障","-","安全","对","解析","之间"," ","安全性","规则化","格式","3","注入","扩展","可以","转换成","和","跨链","升级","、","承载","定性","转换","方法","稳定性","，","核心","网关","服务","管理","应用","业务","1","数据"],"title":"主侧链架构","title_tokens":["主侧","链","架构"]},{"location":"bitxhub/architecture/tx_flow/","text":"跨链交易基本流程 一个典型的跨链交易流程如下图所示，图中各模块具体含义如下： Application A / Application B ：参与跨链的两条应用链A与应用链B。 App-chain A / App-chain B ：应用链插件A与应用链插件B，适配不同的应用链发出的跨链交易。 Pier A / Pier B ：网关A与网关B，用于转发跨链交易，是应用链与中继链的中转站。 BitXHub ：中继链，用于跨链交易验证。 具体的交易执行流程如下： 1. broker合约抛出跨链事件 以具体的跨链交易事件为例，如数据交换场景：应用链A想获取应用链B的某个数据。SDK 调用具体的应用链 A 的业务合约 data_swapper 合约的 get 方法，该方法需指定应用链B的 ChainID ，然后调用 broker 合约方法，抛出跨链事件TA。 2. 跨链网关监听跨链事件 跨链网关 A 通过应用链插件 A 监听到跨链事件Ta，应用链插件实质为跨链网关与应用链的交互模块，其设计思想参考 跨链网关设计方案 。 3. 跨链网关转发跨链事件 跨链网关 A 将跨链交易格式转换为中继链通用的 IBTP结构 ，并将IBTP封装为bxh交易类型 bxhTx1 提交到中继链BitXHub上，bxh交易类型如下图所示。 参数 说明 From 跨链网关 A 的地址，由跨链网关的私钥生成 To bitXHub处理跨链交易的合约地址 IBTP 跨链网关将跨链事件Ta封装为ibtp类型 Nonce ibtp的索引 Timestamp 跨链事件发生时间戳 ………… 4. 中继链处理跨链交易 BitXHub 收到跨链交易后，将进行以下处理： 对 bxhTx1 进行基本验证，如验证交易的Nonce与签名的合法性； 将交易交由共识模块处理，负责共识出块； 出块完成后，交由执行模块处理； 执行模块交由验证引擎验证区块的所有交易的有效性和存在性，并对交易根据发送的目的地址进行分类，处理完毕后交由路由模块； 路由模块根据地址将封装后的跨链交易bxhTxWrapper路由到对应的跨链网关，TxWrapper交易类型如下图所示。 参数 说明 L2Roots 不同的目的应用链的交易构成的merkleRoot集合 Transactions 验证后交易集合，valid字段表明交易是否验证通过 Height 交易所在的区块高度，与L2Roots一起用于跨链网关验证 5. 跨链网关监听中继链交易 验证跨链交易所在区块在中继链的存在性： 跨链网关 B 监听到来自中继链的交易bxhTxWrapper，跨链网关可以根据bxhTxWrapper的L2Roots字段构建当前区块的txRoot1； 与此同时，跨链网关将拉取中继链的区块头，根据bxhTxWrapper的区块高度获取相应的区块头txRoot2； 比较当前区块头的txRoot2与计算得到的txRoot1是否相等。如果相等，即验证了收到的bxhTxWrapper的L2Roots字段的真实性。 验证跨链交易在区块的有效性： 将bxhTxWrapper的交易集合构建交易哈希L2Root，判断L2Root是否存在于L2roots集合中。 如果存在，即验证了收到的bxhTxWrapper的Transactions字段的真实性。证明了交易存在中继链的真实性。 6. 解析中继链交易并转发给应用链执行 跨链网关 B 将根据IBTP结构对收到的ibtp1进行解析，转换成业务链 B 可识别的交易Tb，并提交到应用链 B 执行跨链交易。 7. 跨链网关构建跨链交易回执 应用链 B 调用broker合约的 invokeInterchain 方法处理收到交易Tb，然后调用具体的业务合约方法执行； broker合约将处理结果返回给应用链插件 B ，应用链插件 B 将返回的结果构建为IBTP类型的回执receiptB，之后发送给跨链网关 B。 8. 跨链网关转发跨链交易回执 由于回执也是ibtp类型的跨链交易，因此目的链发送回执给来源链的过程，与来源链发送跨链交易给目的链的过程一致。即跨链网关 B 转发receiptB给中继链，中继链转发至跨链网关 A ，最后跨链网关 A 将交易回执转发给应用链A。","text_tokens":["8","目的","broker","发给","说明","模块","bxhtx1","各","到","上","处理结果","为","sdk","合法","适配","get","来自","流程","如","；","to","合约","处理","通过","如果","事件","具体","将拉取","data","区块","场景","设计","思想","所有","设计方案","是否","计算","给","中继","l2root","至","完毕","以","_","图","所示","类型","5","验证","timestamp","chainid","集合","：","是","需","性","共识","一致","获取","并","合法性","存在","真实","判断","将","结构","即","因此","一起","生成","发生","高度","送给","在","表明","txwrapper","指定","其","方案","签名","构建","ibtp1","转站","from","tb","txroot1","回执","典型","两条","结果","/","交由","监听","bxhtxwrapper","。","交易类型","6","后","的","与","可","交换","提交","交易","数据交换","invokeinterchain","中转","与此同时","转发给","不同","出块","对应","有效","参数","valid","pier","同时","swapper","一个","想","相等","相应","真实性","完成","链","返回","调用","receiptb","nonce","某个","进行","height","如下","哈希","字段","过程",".","根据","中转站","txroot2","由","发出","当前","7","app","构成","头","封装","私钥","通用","比较","application","插件","transactions","中","2","实质","时间","证明","换成","转发","识别","为例","与此","b","参与","bxh","收到","负责","merkleroot","交互","-","引擎","对","解析","ibtp","发送","发送给","4","bitxhub","抛出"," ","格式","3","chain","图中","最后","路由","l2roots","可以","和","跨链","于","转换成","之后","由于","执行","理完","用于","也","处理完毕","转换","ta","方法","a","戳","索引","，","基本","网关","得到","然后","分类","含义","参考","地址","有效性","应用","了","…","来源","交易所","业务","该","以下","1","数据"],"title":"交易流","title_tokens":["交易","流"]},{"location":"bitxhub/architecture/tx_flow/#_1","text":"一个典型的跨链交易流程如下图所示，图中各模块具体含义如下： Application A / Application B ：参与跨链的两条应用链A与应用链B。 App-chain A / App-chain B ：应用链插件A与应用链插件B，适配不同的应用链发出的跨链交易。 Pier A / Pier B ：网关A与网关B，用于转发跨链交易，是应用链与中继链的中转站。 BitXHub ：中继链，用于跨链交易验证。 具体的交易执行流程如下：","text_tokens":["b","一个","模块","参与","各","-","链","bitxhub","适配"," ","流程","chain","图中","转站","跨链","典型","如下","具体","两条","中转站","/","执行","用于","。","发出","的","与","中继","app","a","交易","图","所示","中转","application","，","验证","不同","插件","网关","：","含义","是","应用","pier","转发"],"title":"跨链交易基本流程","title_tokens":["基本","跨链","交易","流程"]},{"location":"bitxhub/architecture/tx_flow/#1-broker","text":"以具体的跨链交易事件为例，如数据交换场景：应用链A想获取应用链B的某个数据。SDK 调用具体的应用链 A 的业务合约 data_swapper 合约的 get 方法，该方法需指定应用链B的 ChainID ，然后调用 broker 合约方法，抛出跨链事件TA。","text_tokens":["为例","swapper","broker","b","想","链","sdk","抛出"," ","指定","get","调用","如","合约","某个","该","跨链","事件","具体","data","场景","。","ta","方法","的","交换","a","交易","数据交换","以","_","，","chainid","：","然后","需","应用","业务","获取","数据"],"title":"1. broker合约抛出跨链事件","title_tokens":["broker","合约","跨链","事件",".","抛出","1"," "]},{"location":"bitxhub/architecture/tx_flow/#2","text":"跨链网关 A 通过应用链插件 A 监听到跨链事件Ta，应用链插件实质为跨链网关与应用链的交互模块，其设计思想参考 跨链网关设计方案 。","text_tokens":["模块","交互","到","链","为"," ","其","方案","通过","跨链","事件","思想","设计","监听","设计方案","。","ta","与","的","a","，","网关","插件","参考","应用","实质"],"title":"2. 跨链网关监听跨链事件","title_tokens":["监听","网关","2","跨链","事件","."," "]},{"location":"bitxhub/architecture/tx_flow/#3","text":"跨链网关 A 将跨链交易格式转换为中继链通用的 IBTP结构 ，并将IBTP封装为bxh交易类型 bxhTx1 提交到中继链BitXHub上，bxh交易类型如下图所示。 参数 说明 From 跨链网关 A 的地址，由跨链网关的私钥生成 To bitXHub处理跨链交易的合约地址 IBTP 跨链网关将跨链事件Ta封装为ibtp类型 Nonce ibtp的索引 Timestamp 跨链事件发生时间戳 …………","text_tokens":["将","结构","说明","生成","bxh","bxhtx1","发生","到","上","链","ibtp","为","bitxhub"," ","格式","nonce","to","合约","处理","戳","from","跨链","事件","如下","。","交易类型","由","转换","ta","的","中继","a","交易","封装","提交","通用","类型","图","所示","私钥","，","索引","timestamp","网关","地址","参数","…","时间","并"],"title":"3. 跨链网关转发跨链事件","title_tokens":["3","网关","跨链","事件",".","转发"," "]},{"location":"bitxhub/architecture/tx_flow/#4","text":"BitXHub 收到跨链交易后，将进行以下处理： 对 bxhTx1 进行基本验证，如验证交易的Nonce与签名的合法性； 将交易交由共识模块处理，负责共识出块； 出块完成后，交由执行模块处理； 执行模块交由验证引擎验证区块的所有交易的有效性和存在性，并对交易根据发送的目的地址进行分类，处理完毕后交由路由模块； 路由模块根据地址将封装后的跨链交易bxhTxWrapper路由到对应的跨链网关，TxWrapper交易类型如下图所示。 参数 说明 L2Roots 不同的目的应用链的交易构成的merkleRoot集合 Transactions 验证后交易集合，valid字段表明交易是否验证通过 Height 交易所在的区块高度，与L2Roots一起用于跨链网关验证","text_tokens":["目的","说明","模块","bxhtx1","到","合法","如","；","处理","通过","区块","所有","是否","完毕","图","类型","所示","验证","集合","：","性","共识","并","存在","合法性","将","一起","高度","在","表明","txwrapper","签名","交由","bxhtxwrapper","。","交易类型","后","的","与","交易","出块","对应","不同","有效","参数","valid","完成","链","nonce","进行","height","如下","字段","根据","构成","封装","transactions","负责","收到","merkleroot","引擎","对","发送","bitxhub"," ","路由","l2roots","和","跨链","执行","理完","用于","处理完毕","，","基本","网关","分类","地址","有效性","应用","交易所","以下"],"title":"4. 中继链处理跨链交易","title_tokens":["交易","处理","跨链","链","中继",".","4"," "]},{"location":"bitxhub/architecture/tx_flow/#5","text":"验证跨链交易所在区块在中继链的存在性： 跨链网关 B 监听到来自中继链的交易bxhTxWrapper，跨链网关可以根据bxhTxWrapper的L2Roots字段构建当前区块的txRoot1； 与此同时，跨链网关将拉取中继链的区块头，根据bxhTxWrapper的区块高度获取相应的区块头txRoot2； 比较当前区块头的txRoot2与计算得到的txRoot1是否相等。如果相等，即验证了收到的bxhTxWrapper的L2Roots字段的真实性。 验证跨链交易在区块的有效性： 将bxhTxWrapper的交易集合构建交易哈希L2Root，判断L2Root是否存在于L2roots集合中。 如果存在，即验证了收到的bxhTxWrapper的Transactions字段的真实性。证明了交易存在中继链的真实性。","text_tokens":["真实","将","与此","b","即","收到","高度","相等","相应","真实性","到","在","链"," ","来自","；","构建","可以","l2roots","如果","跨链","txroot1","哈希","于","字段","将拉取","根据","区块","监听","txroot2","bxhtxwrapper","。","是否","计算","当前","的","与","中继","l2root","头","交易","比较","与此同时","验证","，","集合","网关","得到","transactions","：","中","有效","性","有效性","了","交易所","证明","获取","存在","同时","判断"],"title":"5. 跨链网关监听中继链交易","title_tokens":["监听","网关","跨链","链","中继",".","交易","5"," "]},{"location":"bitxhub/architecture/tx_flow/#6","text":"跨链网关 B 将根据IBTP结构对收到的ibtp1进行解析，转换成业务链 B 可识别的交易Tb，并提交到应用链 B 执行跨链交易。","text_tokens":["将","b","结构","收到","到","对","解析","ibtp","链"," ","ibtp1","转换成","tb","进行","跨链","根据","执行","。","转换","的","可","提交","交易","，","网关","业务","应用","换成","并","识别"],"title":"6. 解析中继链交易并转发给应用链执行","title_tokens":["转发给","执行","发给","6","并","应用","中继","解析","链",".","交易","转发"," "]},{"location":"bitxhub/architecture/tx_flow/#7","text":"应用链 B 调用broker合约的 invokeInterchain 方法处理收到交易Tb，然后调用具体的业务合约方法执行； broker合约将处理结果返回给应用链插件 B ，应用链插件 B 将返回的结果构建为IBTP类型的回执receiptB，之后发送给跨链网关 B。","text_tokens":["broker","将","b","收到","送给","链","发送给","ibtp","处理结果","为","发送","返回"," ","调用","receiptb","；","合约","处理","构建","tb","跨链","回执","具体","之后","结果","执行","。","给","方法","的","invokeinterchain","交易","类型","，","插件","网关","然后","应用","业务"],"title":"7. 跨链网关构建跨链交易回执","title_tokens":["网关","构建","7","跨链","回执",".","交易"," "]},{"location":"bitxhub/architecture/tx_flow/#8","text":"由于回执也是ibtp类型的跨链交易，因此目的链发送回执给来源链的过程，与来源链发送跨链交易给目的链的过程一致。即跨链网关 B 转发receiptB给中继链，中继链转发至跨链网关 A ，最后跨链网关 A 将交易回执转发给应用链A。","text_tokens":["目的","将","因此","即","b","发给","链","ibtp","发送"," ","receiptb","最后","跨链","回执","过程","由于","也","。","给","的","与","中继","至","a","交易","类型","转发给","，","网关","是","来源","应用","一致","转发"],"title":"8. 跨链网关转发跨链交易回执","title_tokens":["8","网关","跨链","回执",".","交易","转发"," "]},{"location":"bitxhub/changelog/bitxhub_v1.0.0/","text":"BitXHub v1.0.0 中继链V1.0.0 新功能 接入区块链并适配 Ethereum； 添加Prometheus监控模块并且丰富相关埋点； 添加Solo版本的Dockerfile； 实现Docker Compose启动集群功能； 内置合约添加查询跨链索引的功能； 添加Rust验证规则模版； 完善区块头交易Merkle树的构造。 开发工具 新增了运维工具项目GoDuck，后续将持续进行优化； 添加快速启动Fabric网络和Ethereum网络的功能； 添加Prometheus+Grafana快速启动docker-compose的配置文件； 加入BitXHub和Pier配置快速生成功能； 实现二进制管理功能。 缺陷修复 修复验证规则无法解析的Bug； 修复应用链注册时ID未找到的Bug； 修复Dockerfile未编译raft共识算法插件的Bug； 跨链网关V1.0.0 重构跨链网关拉取中继链上的跨链交易时Wrapper的数据结构； 添加p2p ID 的命令行子命令； 缺陷修复 修复跨链网关和插件依赖库版本冲突的Bug； 修复验证来自中继链的跨链交易为空时处理的Bug。","text_tokens":["优化","模块","开发工具","为","适配","id","来自","未","；","合约","raft","处理","区块","中继","验证","监控","并且","共识","快速","并","将","prometheus","结构","工具","生成","规则","持续","0","dockerfile","丰富","配置文件","相关","merkle","加入","链上","新","。","ethereum","的","启动","命令行","交易","树","拉取","pier","添加","后续","新增","库","编译","rust","goduck","链","solo","compose","实现","无法","修复","内置","完善","fabric","+","集群","进行",".","文件","埋点","运维","bug","接入","查询","依赖","头","开发","缺陷","命令","子","未找到","插件","功能","注册","二进制","算法","wrapper","-","解析","配置","bitxhub"," ","docker","和","跨链","网络","冲突","进制","模版","时","重构","v1.0","数据结构","找到","项目","p2p","版本","索引","构造","，","网关","了","管理","应用","grafana","空时","数据"],"title":"BitXHub v1.0.0","title_tokens":["0","v1.0",".","bitxhub"," "]},{"location":"bitxhub/changelog/bitxhub_v1.0.0/#bitxhub-v100","text":"","text_tokens":[],"title":"BitXHub v1.0.0","title_tokens":["0","v1.0",".","bitxhub"," "]},{"location":"bitxhub/changelog/bitxhub_v1.0.0/#v100","text":"","text_tokens":[],"title":"中继链V1.0.0","title_tokens":["0","v1.0","链","中继","."]},{"location":"bitxhub/changelog/bitxhub_v1.0.0/#_1","text":"接入区块链并适配 Ethereum； 添加Prometheus监控模块并且丰富相关埋点； 添加Solo版本的Dockerfile； 实现Docker Compose启动集群功能； 内置合约添加查询跨链索引的功能； 添加Rust验证规则模版； 完善区块头交易Merkle树的构造。","text_tokens":["prometheus","rust","模块","规则","链","solo","适配"," ","compose","实现","；","dockerfile","丰富","docker","内置","合约","完善","集群","跨链","相关","merkle","区块","埋点","模版","接入","查询","。","ethereum","的","启动","功能","头","交易","版本","索引","树","构造","验证","监控","并且","添加","并"],"title":"新功能","title_tokens":["新","功能"]},{"location":"bitxhub/changelog/bitxhub_v1.0.0/#_2","text":"新增了运维工具项目GoDuck，后续将持续进行优化； 添加快速启动Fabric网络和Ethereum网络的功能； 添加Prometheus+Grafana快速启动docker-compose的配置文件； 加入BitXHub和Pier配置快速生成功能； 实现二进制管理功能。","text_tokens":["新增","将","prometheus","pier","工具","优化","后续","二进制","生成","goduck","-","配置","bitxhub"," ","compose","实现","持续","；","docker","fabric","+","配置文件","进行","和","加入","网络","文件","运维","进制","。","ethereum","的","启动","项目","grafana","，","了","管理","添加","快速","功能"],"title":"开发工具","title_tokens":["开发工具","开发","工具"]},{"location":"bitxhub/changelog/bitxhub_v1.0.0/#_3","text":"修复验证规则无法解析的Bug； 修复应用链注册时ID未找到的Bug； 修复Dockerfile未编译raft共识算法插件的Bug；","text_tokens":["注册","编译","规则","算法","链","解析"," ","id","未","无法","修复","；","dockerfile","raft","bug","时","的","找到","验证","未找到","插件","应用","共识"],"title":"缺陷修复","title_tokens":["缺陷","修复"]},{"location":"bitxhub/changelog/bitxhub_v1.0.0/#v100_1","text":"重构跨链网关拉取中继链上的跨链交易时Wrapper的数据结构； 添加p2p ID 的命令行子命令；","text_tokens":["结构","wrapper"," ","id","；","跨链","链上","时","重构","数据结构","的","中继","p2p","命令行","命令","交易","子","网关","拉取","添加","数据"],"title":"跨链网关V1.0.0","title_tokens":["0","网关","v1.0","跨链","."]},{"location":"bitxhub/changelog/bitxhub_v1.0.0/#_4","text":"修复跨链网关和插件依赖库版本冲突的Bug； 修复验证来自中继链的跨链交易为空时处理的Bug。","text_tokens":["库","链","为"," ","来自","修复","；","处理","和","跨链","冲突","bug","依赖","。","的","中继","交易","版本","验证","网关","插件","空时"],"title":"缺陷修复","title_tokens":["缺陷","修复"]},{"location":"bitxhub/changelog/bitxhub_v1.3.0/","text":"BitXHub v1.3.0 中继链V1.3.0 新功能 重构跨链验证 中继链PendingPool功能优化，提升性能； 中继链实现交易执行并行化； 中继链跨链验证去除IBTP的Proof，减少存储压力； 缺陷修复 无 跨链网关V1.3.0 新功能 适配中继链的PendingPool模式，维护发送跨链交易的Nonce并且顺序递增； 优化跨链网关直连模式的性能，实现IBTP异步发送和接收； 实现初版pier-client-fake以支持Pier直连模式测试； 缺陷修复 修复Pier在中继链和应用链跨链合约数据不一致情况下一直向中继链发交易的Bug 运维工具 新功能 Goduck添加根据版本远程部署BITXHUB和Pier的功能； Goduck支持prometheus监控启动； Goduck支持按版本启动playground 缺陷修复 修复linux系统上docker模式启动pier失败的bug； 修复key命令path参数无效的bug 修复info命令无响应的bug 其它 无","text_tokens":["优化","提升","上","性能","fake","部署","适配","一直","不","响应","；","合约","链发","直连","其它","中继","失败","以","模式","v1.3","验证","监控","并且","一致","prometheus","工具","在","无","0","pendingpool","测试","系统","存储","化","新","初版","递增","的","启动","交易","无效","异步","顺序","playground","参数","pier","添加","并行","goduck","支持","info","linux","链","实现","修复","nonce",".","根据","运维","bug","接收","缺陷","命令","下","功能","减少","client","-","ibtp","发送","远程","按","去除","bitxhub"," ","docker","和","跨链","情况","压力","执行","重构","key","path","proof","版本","，","网关","维护","向","应用","数据"],"title":"BitXHub v1.3.0","title_tokens":["v1.3","0",".","bitxhub"," "]},{"location":"bitxhub/changelog/bitxhub_v1.3.0/#bitxhub-v130","text":"","text_tokens":[],"title":"BitXHub v1.3.0","title_tokens":["v1.3","0",".","bitxhub"," "]},{"location":"bitxhub/changelog/bitxhub_v1.3.0/#v130","text":"","text_tokens":[],"title":"中继链V1.3.0","title_tokens":["v1.3","0","链","中继","."]},{"location":"bitxhub/changelog/bitxhub_v1.3.0/#_1","text":"重构跨链验证 中继链PendingPool功能优化，提升性能； 中继链实现交易执行并行化； 中继链跨链验证去除IBTP的Proof，减少存储压力；","text_tokens":["减少","优化","提升","性能","链","ibtp","去除"," ","实现","；","pendingpool","跨链","压力","执行","存储","化","重构","proof","的","中继","交易","验证","，","并行","功能"],"title":"新功能","title_tokens":["新","功能"]},{"location":"bitxhub/changelog/bitxhub_v1.3.0/#_2","text":"无","text_tokens":["无"],"title":"缺陷修复","title_tokens":["缺陷","修复"]},{"location":"bitxhub/changelog/bitxhub_v1.3.0/#v130_1","text":"","text_tokens":[],"title":"跨链网关V1.3.0","title_tokens":["v1.3","0","网关","跨链","."]},{"location":"bitxhub/changelog/bitxhub_v1.3.0/#_3","text":"适配中继链的PendingPool模式，维护发送跨链交易的Nonce并且顺序递增； 优化跨链网关直连模式的性能，实现IBTP异步发送和接收； 实现初版pier-client-fake以支持Pier直连模式测试；","text_tokens":["优化","支持","client","-","性能","链","fake","ibtp","发送","适配"," ","实现","；","nonce","pendingpool","和","跨链","测试","直连","接收","初版","递增","的","中继","交易","以","模式","，","网关","异步","维护","顺序","并且","pier"],"title":"新功能","title_tokens":["新","功能"]},{"location":"bitxhub/changelog/bitxhub_v1.3.0/#_4","text":"修复Pier在中继链和应用链跨链合约数据不一致情况下一直向中继链发交易的Bug","text_tokens":["pier","链","在","一直","不","修复","合约","链发","和","跨链","情况","bug","的","中继","交易","向","应用","下","一致","数据"],"title":"缺陷修复","title_tokens":["缺陷","修复"]},{"location":"bitxhub/changelog/bitxhub_v1.3.0/#_5","text":"","text_tokens":[],"title":"运维工具","title_tokens":["运维","工具"]},{"location":"bitxhub/changelog/bitxhub_v1.3.0/#_6","text":"Goduck添加根据版本远程部署BITXHUB和Pier的功能； Goduck支持prometheus监控启动； Goduck支持按版本启动playground","text_tokens":["prometheus","goduck","支持","按","远程","部署","bitxhub"," ","；","和","根据","添加","的","启动","版本","监控","playground","pier","功能"],"title":"新功能","title_tokens":["新","功能"]},{"location":"bitxhub/changelog/bitxhub_v1.3.0/#_7","text":"修复linux系统上docker模式启动pier失败的bug； 修复key命令path参数无效的bug 修复info命令无响应的bug","text_tokens":["上","linux","info","无"," ","修复","；","响应","docker","系统","bug","path","key","的","启动","命令","失败","模式","无效","参数","pier"],"title":"缺陷修复","title_tokens":["缺陷","修复"]},{"location":"bitxhub/changelog/bitxhub_v1.3.0/#_8","text":"无","text_tokens":["无"],"title":"其它","title_tokens":["其它"]},{"location":"bitxhub/changelog/bitxhub_v1.4.0/","text":"BitXHub v1.4.0 中继链V1.4.0 新功能 中继链接入了强鲁棒拜占庭容错算法RBFT，其失效数据恢复、动态节点增删等机制保证了中继链天然的高可用性； 增加Sync Protocol节点恢复机制，保证中继链节点状态的一致性； 中继链DID内置合约开发及优化； 新增事务管理模块，提供多链消息表和中继多签资产交换两种跨链事务。使用多链消息表技术实现一对一和一对多跨链； 中继链的GRPC通信增加TLS加密功能； 中继链mempool实现，添加交易池的超时处理机制 缺陷修复 修复创建私钥必须在已有目录的bug； 修复中继链Solo模式下不支持交易池的bug； 修复bitxhub client validators命令返回错误的Bug； 修复raft选举异常的bug 跨链网关V1.4.0 新功能 跨链网关的GRPC通信增加TLS加密功能； 重构跨链网关执行、监听和同步等模块； 跨链网关主备模块化； 适配BCOS； 缺陷修复 修复Pier中继模式启动依赖应用链的Bug； 修复fabric插件中轮询chaincode交易过多的bug； 修复删除跨链网关存储重启导致Get out Message not found的Bug； 修复Pier重启恢复过程中生成IBTP回执时IBTP参数设置错误的Bug 运维工具 新功能 Goduck命令格式调整优化； Goduck添加远程部署pier和bitxhub的结果检查； Goduck的status命令开发，添加docker组件信息； 缺陷修复 修复Goduck pier config命令中id参数无效的bug； 修复Goduck info命令中判断已退出但配置目录仍存在的组件状态错误的bug； 修复Goduck远程重复部署pier时出现的文件名不一致的bug； 修复Goduck pier直连模式peers信息错误的bug； 其它 无","text_tokens":["增删","主备","优化","模块","过多","信息","事务管理","一对","创建","适配","部署","get","id","不","技术","容错","；","合约","处理","raft","检查","通信","天然","直连","动态","组件","其它","保证","中继","模块化","bcos","模式","入","out","可用","message","一致","tls","存在","判断","工具","生成","在","无","加密","多链","其","0","链接","节点","可用性","回执","超时","资产","结果","一对一","监听","did","存储","状态","新","及","。","高可用性","的","启动","protocol","交换","交易","一致性","无效","重复","事务","rbft","使用","参数","已","添加","pier","两种","新增","v1.4","goduck","支持","机制","异常","info","错误","链","solo","返回","实现","但","修复","内置","消息","fabric","sync","status","失效","过程",".","已有","文件","运维","参数设置","bug","选举","依赖","恢复","拜占庭","提供","开发","缺陷","命令","私钥","config","mempool","增加","插件","表","中","等","下","功能","设置","删除","算法","validators","目录","client","chaincode","调整","ibtp","远程","配置","文件名","bitxhub"," ","格式","not","docker","数据恢复","和","跨链","轮询","、","found","grpc","多签","执行","peers","必须","时","重构","出现","导致","多","同步","强鲁棒","，","网关","重启","退出","仍","了","管理","应用","池","数据"],"title":"BitXHub v1.4.0","title_tokens":["0","v1.4",".","bitxhub"," "]},{"location":"bitxhub/changelog/bitxhub_v1.4.0/#bitxhub-v140","text":"","text_tokens":[],"title":"BitXHub v1.4.0","title_tokens":["0","v1.4",".","bitxhub"," "]},{"location":"bitxhub/changelog/bitxhub_v1.4.0/#v140","text":"","text_tokens":[],"title":"中继链V1.4.0","title_tokens":["0","v1.4","链","中继","."]},{"location":"bitxhub/changelog/bitxhub_v1.4.0/#_1","text":"中继链接入了强鲁棒拜占庭容错算法RBFT，其失效数据恢复、动态节点增删等机制保证了中继链天然的高可用性； 增加Sync Protocol节点恢复机制，保证中继链节点状态的一致性； 中继链DID内置合约开发及优化； 新增事务管理模块，提供多链消息表和中继多签资产交换两种跨链事务。使用多链消息表技术实现一对一和一对多跨链； 中继链的GRPC通信增加TLS加密功能； 中继链mempool实现，添加交易池的超时处理机制","text_tokens":["新增","增删","优化","模块","算法","机制","两种","链","事务管理","一对","加密"," ","实现","多链","其","技术","容错","链接","；","内置","合约","消息","处理","节点","数据恢复","可用性","sync","和","跨链","通信","失效","资产","、","超时","grpc","天然","多签","动态","did","一对一","添加","状态","及","。","恢复","保证","拜占庭","的","高可用性","protocol","中继","提供","开发","交换","交易","多","一致性","强鲁棒","，","mempool","增加","入","事务","rbft","表","使用","可用","等","了","管理","一致","tls","功能","池","数据"],"title":"新功能","title_tokens":["新","功能"]},{"location":"bitxhub/changelog/bitxhub_v1.4.0/#_2","text":"修复创建私钥必须在已有目录的bug； 修复中继链Solo模式下不支持交易池的bug； 修复bitxhub client validators命令返回错误的Bug； 修复raft选举异常的bug","text_tokens":["validators","目录","支持","client","异常","错误","在","链","solo","创建","bitxhub"," ","返回","不","修复","；","raft","已有","bug","选举","必须","的","中继","命令","交易","私钥","模式","下","池"],"title":"缺陷修复","title_tokens":["缺陷","修复"]},{"location":"bitxhub/changelog/bitxhub_v1.4.0/#v140_1","text":"","text_tokens":[],"title":"跨链网关V1.4.0","title_tokens":["0","v1.4","网关","跨链","."]},{"location":"bitxhub/changelog/bitxhub_v1.4.0/#_3","text":"跨链网关的GRPC通信增加TLS加密功能； 重构跨链网关执行、监听和同步等模块； 跨链网关主备模块化； 适配BCOS；","text_tokens":["主备","模块","加密"," ","适配","；","通信","和","跨链","、","grpc","监听","执行","重构","的","模块化","同步","bcos","网关","增加","等","tls","功能"],"title":"新功能","title_tokens":["新","功能"]},{"location":"bitxhub/changelog/bitxhub_v1.4.0/#_4","text":"修复Pier中继模式启动依赖应用链的Bug； 修复fabric插件中轮询chaincode交易过多的bug； 修复删除跨链网关存储重启导致Get out Message not found的Bug； 修复Pier重启恢复过程中生成IBTP回执时IBTP参数设置错误的Bug","text_tokens":["删除","生成","过多","chaincode","错误","链","ibtp"," ","get","not","修复","；","fabric","跨链","回执","过程","轮询","found","参数设置","bug","存储","时","依赖","恢复","导致","的","启动","中继","交易","模式","插件","网关","out","中","重启","参数","应用","message","pier","设置"],"title":"缺陷修复","title_tokens":["缺陷","修复"]},{"location":"bitxhub/changelog/bitxhub_v1.4.0/#_5","text":"","text_tokens":[],"title":"运维工具","title_tokens":["运维","工具"]},{"location":"bitxhub/changelog/bitxhub_v1.4.0/#_6","text":"Goduck命令格式调整优化； Goduck添加远程部署pier和bitxhub的结果检查； Goduck的status命令开发，添加docker组件信息；","text_tokens":["优化","goduck","信息","调整","远程","部署","bitxhub"," ","格式","；","docker","检查","和","status","结果","添加","组件","的","开发","命令","，","pier"],"title":"新功能","title_tokens":["新","功能"]},{"location":"bitxhub/changelog/bitxhub_v1.4.0/#_7","text":"修复Goduck pier config命令中id参数无效的bug； 修复Goduck info命令中判断已退出但配置目录仍存在的组件状态错误的bug； 修复Goduck远程重复部署pier时出现的文件名不一致的bug； 修复Goduck pier直连模式peers信息错误的bug；","text_tokens":["goduck","目录","信息","info","错误","远程","配置","文件名","部署"," ","id","但","不","修复","；","文件","直连","bug","peers","组件","状态","时","出现","的","命令","config","模式","无效","重复","中","参数","退出","仍","一致","已","pier","存在","判断"],"title":"缺陷修复","title_tokens":["缺陷","修复"]},{"location":"bitxhub/changelog/bitxhub_v1.4.0/#_8","text":"无","text_tokens":["无"],"title":"其它","title_tokens":["其它"]},{"location":"bitxhub/changelog/bitxhub_v1.5.0/","text":"BitXHub v1.5.0 中继链V1.5.0 新功能 中继链提供链间跨链功能； 中继链Mempool交易超时转发功能； 实现libp2p-cert库，重构节点间证书验证功能； DID模块整合IPFS存储功能； 实现StateUpdate功能，解决落后节点数据同步功能； 实现Minifile模块，减轻共识存储压力； 缺陷修复 修复中继链订阅 nil 的地址导致 Panic 的Bug； 修复中继链 GOSDK 中和宕机节点异步建立连接导致后续使用连接时出错的Bug； 修复 RAFT mempool 未持久化 pending nonce 的Bug； 修复中继链命令行显示的Bug。 跨链网关V1.5.0 新功能 跨链网关重构（优化序号异常处理方式、重构Monitor、Executor、Syncer等模块）； 支持配置多个中继链节点并自动切换的功能，优化在弱网环境下的跨链转发能力； 跨链网关增加跨中继链路由的Union 模式下的跨链消息传递功能，适应大规模跨链场景下的需求； 跨链网关适配业务合约功能； 缺陷修复 修复 Pier executor 地址大小写不敏感的Bug； 修复executor 执行跨链交易后改变 IBTP 内容等Bug； 修复重构跨链网关无法配置插件名和打印版本信息不完善的Bug； 修复跨链网关主备节点切换时错误关闭插件进程的Bug； 运维工具 新功能 Goduck适配1.5.0版本的pier和bitxhub； 缺陷修复 无 其它 无","text_tokens":["主备","优化","模块","落后","信息","网","适配","executor","未","不","cert","；","合约","raft","处理","1.5","v1.5","能力","场景","其它","pending","中继","环境","模式","验证","共识","minifile","）","并","工具","改变","证书","在","无","需求","传递","0","建立","节点","超时","解决","did","存储","化","新","。","syncer","敏感","后","的","整合","大小写","命令行","交易","适应","小写","异步","弱","使用","进程","pier","后续","库","nil","关闭","panic","名","goduck","支持","异常","错误","链","规模","实现","方式","无法","修复","nonce","自动","消息","完善","序号",".","union","运维","大规","bug","订阅","跨","ipfs","持久","由","连接","提供","缺陷","命令","间","版本信息","mempool","增加","插件","中","内容","等","下","多个","大小","链路","功能","转发","大规模","monitor","-","消息传递","ibtp","配置","bitxhub"," ","和","跨链","gosdk","、","压力","执行","切换","时","打印","重构","减轻","导致","显示","同步","stateupdate","版本","，","网关","libp2p","（","地址","链间","出错","宕机","业务","数据"],"title":"BitXHub v1.5.0","title_tokens":["0","v1.5",".","bitxhub"," "]},{"location":"bitxhub/changelog/bitxhub_v1.5.0/#bitxhub-v150","text":"","text_tokens":[],"title":"BitXHub v1.5.0","title_tokens":["0","v1.5",".","bitxhub"," "]},{"location":"bitxhub/changelog/bitxhub_v1.5.0/#v150","text":"","text_tokens":[],"title":"中继链V1.5.0","title_tokens":["0","链","v1.5","中继","."]},{"location":"bitxhub/changelog/bitxhub_v1.5.0/#_1","text":"中继链提供链间跨链功能； 中继链Mempool交易超时转发功能； 实现libp2p-cert库，重构节点间证书验证功能； DID模块整合IPFS存储功能； 实现StateUpdate功能，解决落后节点数据同步功能； 实现Minifile模块，减轻共识存储压力；","text_tokens":["库","模块","证书","-","落后","链"," ","实现","cert","；","节点","跨链","超时","解决","压力","did","存储","ipfs","重构","减轻","整合","提供","中继","交易","同步","间","stateupdate","验证","，","mempool","libp2p","链间","共识","minifile","功能","转发","数据"],"title":"新功能","title_tokens":["新","功能"]},{"location":"bitxhub/changelog/bitxhub_v1.5.0/#_2","text":"修复中继链订阅 nil 的地址导致 Panic 的Bug； 修复中继链 GOSDK 中和宕机节点异步建立连接导致后续使用连接时出错的Bug； 修复 RAFT mempool 未持久化 pending nonce 的Bug； 修复中继链命令行显示的Bug。","text_tokens":["nil","panic","链"," ","未","修复","；","建立","nonce","raft","节点","和","gosdk","bug","订阅","时","化","。","持久","连接","pending","导致","的","中继","命令行","命令","显示","mempool","异步","中","使用","地址","出错","宕机","后续"],"title":"缺陷修复","title_tokens":["缺陷","修复"]},{"location":"bitxhub/changelog/bitxhub_v1.5.0/#v150_1","text":"","text_tokens":[],"title":"跨链网关V1.5.0","title_tokens":["0","网关","跨链","v1.5","."]},{"location":"bitxhub/changelog/bitxhub_v1.5.0/#_3","text":"跨链网关重构（优化序号异常处理方式、重构Monitor、Executor、Syncer等模块）； 支持配置多个中继链节点并自动切换的功能，优化在弱网环境下的跨链转发能力； 跨链网关增加跨中继链路由的Union 模式下的跨链消息传递功能，适应大规模跨链场景下的需求； 跨链网关适配业务合约功能；","text_tokens":["优化","大规模","模块","monitor","支持","异常","消息传递","链","在","配置","网","适配"," ","规模","executor","需求","传递","方式","；","自动","合约","处理","消息","节点","跨链","能力","序号","、","union","大规","场景","切换","syncer","跨","由","重构","的","中继","功能","环境","适应","模式","，","网关","（","增加","弱","等","链路","下","多个","业务","）","并","转发"],"title":"新功能","title_tokens":["新","功能"]},{"location":"bitxhub/changelog/bitxhub_v1.5.0/#_4","text":"修复 Pier executor 地址大小写不敏感的Bug； 修复executor 执行跨链交易后改变 IBTP 内容等Bug； 修复重构跨链网关无法配置插件名和打印版本信息不完善的Bug； 修复跨链网关主备节点切换时错误关闭插件进程的Bug；","text_tokens":["主备","关闭","改变","名","信息","错误","ibtp","配置"," ","executor","不","无法","修复","；","完善","节点","和","跨链","bug","执行","切换","时","打印","重构","敏感","后","大小写","的","交易","版本","版本信息","小写","网关","插件","内容","进程","地址","等","大小","pier"],"title":"缺陷修复","title_tokens":["缺陷","修复"]},{"location":"bitxhub/changelog/bitxhub_v1.5.0/#_5","text":"","text_tokens":[],"title":"运维工具","title_tokens":["运维","工具"]},{"location":"bitxhub/changelog/bitxhub_v1.5.0/#_6","text":"Goduck适配1.5.0版本的pier和bitxhub；","text_tokens":["0","pier","；","1.5","goduck","和","的",".","bitxhub","适配","版本"],"title":"新功能","title_tokens":["新","功能"]},{"location":"bitxhub/changelog/bitxhub_v1.5.0/#_7","text":"无","text_tokens":["无"],"title":"缺陷修复","title_tokens":["缺陷","修复"]},{"location":"bitxhub/changelog/bitxhub_v1.5.0/#_8","text":"无","text_tokens":["无"],"title":"其它","title_tokens":["其它"]},{"location":"bitxhub/design/consensus_plugin/","text":"共识算法插件 在本教程中，你将构建一个完整功能的共识服务。过程中能学习基本的概念和具体使用细节。该示例将展示如何快速、轻松地**接入自己的共识算法到BitXHub中来**。 1. 开发要求 安装 go1.13+ 设置好$GOPATH等环境 2. 准备 为了更加便捷的开发共识服务接入到 BitXHub 中来，我们提供了一些接口和参数。 2.1 Order接口 我们规定了下面一些必要的接口，这些接口是 BitXHub 与共识服务的交互接口。 type Order interface { //开启共识服务 Start () error //停止共识服务，关闭共识服务资源 Stop () //交易发送到共识服务，共识服务将处理并打包该交易 Prepare ( tx * pb . Transaction ) error //返回打包的区块 Commit () chan * pb . Block //从网络接收到的共识消息 Step ( ctx context . Context , msg [] byte ) error //集群中产生了新Leader，系统通过该接口判断共识服务是否正常 Ready () bool //系统会通知该接口已经持久化的区块， ReportState ( height uint64 , hash types . Hash ) //集群中可以正常工作的最少节点数量，如在raft中要求正常节点数是N/2+1 Quorum () uint64 //获取账户最新的nonce GetPendingNonceByAccount ( account string ) uint64 //根据哈希获取指定的交易 GetPendingTxByHash ( hash * types . Hash ) pb . Transaction //从共识删除指定的节点 DelNode ( delID uint64 ) error //订阅交易事件的通道 SubscribeTxEvent ( events chan <- pb . Transactions ) event . Subscription } 2.2 Config参数 我们规定了下面一些参数可以从BitXHub传递给共识服务。 type Config struct { Id uint64 //节点ID IsNew bool //是否是新加入的节点 RepoRoot string //根路径 StoragePath string //存储文件路径 OrderType string // 共识类型 PeerMgr peermgr . PeerManager //网络模块组件 PrivKey crypto . PrivateKey //节点私钥 Logger logrus . FieldLogger //日志组件 Nodes map [ uint64 ] types . Address //集群节点网络地址 Applied uint64 //当前区块高度 Digest string //当前区块哈希 GetTransactionFunc func ( hash types . Hash ) ( * pb . Transaction , error ) // 获取已经持久化的交易函数 GetBlockByHeight func ( height uint64 ) ( * pb . Block , error ) // 获取指定高度的区块 GetAccountNonce func ( address * types . Address ) uint64 // 获取指定账户的nonce } 3. 程序目的 本教程以开发一个简单Solo版本的共识算法为例。 3.1 开始编写你的程序 首先选择你的工程目录，按照正常的GO程序的流程建立项目 $ go version // 确认你安装的GO版本 $ mkdir ${ YOUR_PROJECT } $ cd ${ YOUR_PROJECT } $ go mod init 3.2 Node对象 首先创建一个 node.go 文件，这个文件是共识Plugin的核心和入口，来看看 Node 具体结构 type Node struct { ID uint64 commitC chan * pb . CommitEvent // block channel logger logrus . FieldLogger // logger mempool mempool . MemPool // transaction pool proposeC chan * raftproto . RequestBatch // proposed listenReadyBlock, input channel stateC chan * mempool . ChainState txCache * mempool . TxCache // cache the transactions received from api batchMgr * etcdraft . BatchTimer lastExec uint64 // the index of the last-applied block packSize int // maximum number of transaction packages blockTick time . Duration // block packed period peerMgr peermgr . PeerManager // network manager ctx context . Context cancel context . CancelFunc sync . RWMutex } 然后应该提供一个 Order 的实例化的接口（类似于构造函数），具体代码如下： func NewNode ( opts ... order . Option ) ( order . Order , error ) { //处理Order参数 config , err := order . GenerateConfig ( opts ... ) if err != nil { return nil , fmt . Errorf ( \"generate config: %w\" , err ) } ctx , cancel := context . WithCancel ( context . Background ()) //读取mempool相关配置，batchTimeout出块时间，memConfig配置 batchTimeout , memConfig , err := generateSoloConfig ( config . RepoRoot ) mempoolConf := & mempool . Config { ID : config . ID , //节点ID ChainHeight : config . Applied , //当前区块高度 Logger : config . Logger , //日志组件 StoragePath : config . StoragePath , //存储路径 GetAccountNonce : config . GetAccountNonce , // 获取账户nonce BatchSize : memConfig . BatchSize , //区块最大交易数 PoolSize : memConfig . PoolSize , //交易池容纳最大交易数 TxSliceSize : memConfig . TxSliceSize , //单次广播最大交易数 TxSliceTimeout : memConfig . TxSliceTimeout , //单次广播交易间隔 } batchC := make ( chan * raftproto . RequestBatch ) //实例化mempool，mempool的作用是交易排序 mempoolInst , err := mempool . NewMempool ( mempoolConf ) if err != nil { return nil , fmt . Errorf ( \"create mempool instance: %w\" , err ) } //实例化txCache交易池 txCache := mempool . NewTxCache ( mempoolConf . TxSliceTimeout , mempoolConf . TxSliceSize , config . Logger ) batchTimerMgr := etcdraft . NewTimer ( batchTimeout , config . Logger ) soloNode := & Node { ID : config . ID , commitC : make ( chan * pb . CommitEvent , 1024 ), stateC : make ( chan * mempool . ChainState ), lastExec : config . Applied , mempool : mempoolInst , txCache : txCache , batchMgr : batchTimerMgr , peerMgr : config . PeerMgr , proposeC : batchC , logger : config . Logger , ctx : ctx , cancel : cancel , } soloNode . logger . Infof ( \"SOLO lastExec = %d\" , soloNode . lastExec ) soloNode . logger . Infof ( \"SOLO batch timeout = %v\" , batchTimeout ) return soloNode , nil } 3.3 Node主要方法 通过描述Node的主要方法，介绍pending的交易是如何被打包到区块中以及如何与 BitXHub 系统进行交互。 3.3.1 Start方法 功能：定时在交易池中扫描交易并出块。 func ( n * Node ) Start () error { //交易池打包区块 go n . txCache . ListenEvent () //solo监听新区块 go n . listenReadyBlock () return nil } // Schedule to collect txs to the listenReadyBlock channel func ( n * Node ) listenReadyBlock () { go func () { for { select { case proposal := <- n . proposeC : n . logger . WithFields ( logrus . Fields { \"proposal_height\" : proposal . Height , \"tx_count\" : len ( proposal . TxList ), }). Debugf ( \"Receive proposal from mempool\" ) if proposal . Height != n . lastExec + 1 { n . logger . Warningf ( \"Expects to execute seq=%d, but get seq=%d, ignore it\" , n . lastExec + 1 , proposal . Height ) return } n . logger . Infof ( \"======== Call execute, height=%d\" , proposal . Height ) block := & pb . Block { BlockHeader : & pb . BlockHeader { Version : [] byte ( \"1.0.0\" ), Number : proposal . Height , Timestamp : time . Now (). UnixNano (), }, Transactions : proposal . TxList , } localList := make ([] bool , len ( proposal . TxList )) for i := 0 ; i < len ( proposal . TxList ); i ++ { localList [ i ] = true } executeEvent := & pb . CommitEvent { Block : block , LocalList : localList , } n . commitC <- executeEvent n . lastExec ++ } } }() for { select { case <- n . ctx . Done (): n . logger . Info ( \"----- Exit listen ready block loop -----\" ) return case txSet := <- n . txCache . TxSetC : // start batch timer when this node receives the first transaction if ! n . batchMgr . IsBatchTimerActive () { n . batchMgr . StartBatchTimer () } if batch := n . mempool . ProcessTransactions ( txSet . TxList , true , true ); batch != nil { n . batchMgr . StopBatchTimer () n . proposeC <- batch } case state := <- n . stateC : //每十个区块做一个Check Point if state . Height % 10 == 0 { n . logger . WithFields ( logrus . Fields { \"height\" : state . Height , \"hash\" : state . BlockHash . String (), }). Info ( \"Report checkpoint\" ) } n . mempool . CommitTransactions ( state ) case <- n . batchMgr . BatchTimeoutEvent (): n . batchMgr . StopBatchTimer () n . logger . Debug ( \"Batch timer expired, try to create a batch\" ) if n . mempool . HasPendingRequest () { if batch := n . mempool . GenerateBlock (); batch != nil { n . postProposal ( batch ) } } else { n . logger . Debug ( \"The length of priorityIndex is 0, skip the batch timer\" ) } } } } 3.3.2 Stop方法 功能：停止共识，释放共识相关资源。 func ( n * Node ) Stop () { n . cancel () } 3.3.3 Prepare方法 功能：从 BitXHub 系统中传入交易，收集进交易池。 func ( n * Node ) Prepare ( tx * pb . Transaction ) error { //判断当前共识是否正常 if err := n . Ready (); err != nil { return err } //交易进入交易池 n . txCache . RecvTxC <- tx return nil } 3.3.4 Commit方法 功能：返回新区块的 channel 。 func ( n * Node ) Commit () chan * pb . Block { return n . commitC } 3.3.5 Step方法 功能：通过该接口接收共识的网络消息。 //由于示例是Solo的版本，故具体不实现该方法 func ( n * Node ) Step ( ctx context . Context , msg [] byte ) error { return nil } 3.3.6 Ready方法 功能：判断共识是否完成，Leader是否完成选举。 //由于示例是Solo的版本，单节点直接返回True func ( n * Node ) Ready () bool { return true } 3.3.7 ReportState方法 功能：新区块被持久化后， BitXHub 会调用该接口通知共识服务 func ( n * Node ) ReportState ( height uint64 , blockHash * types . Hash , txHashList [] * types . Hash ) { state := & mempool . ChainState { Height : height , BlockHash : blockHash , TxHashList : txHashList , } //结合listenReadyBlock()，账本落盘区块后通知共识清理相关资源 n . stateC <- state } 3.3.8 Quorum方法 功能：集群中可以正常工作的最少节点数量（比如在raft中要求正常节点数是N/2+1）。 //由于示例是Solo的版本，直接返回1 func ( n * Node ) Quorum () uint64 { return 1 } 3.3.9 GetPendingNonceByAccount方法 功能：获取指定账户最新的nonce值。 func ( n * Node ) GetPendingNonceByAccount ( account string ) uint64 { // 直接从交易池中获取当前账户的最新nonce，由于交易池中可能有该账号的多笔交易， // 需要把符合条件的nonce刷选出。 return n . mempool . GetPendingNonceByAccount ( account ) } 3.3.10 DelNode方法 功能：删除指定的共识节点。 //由于示例是Solo的版本，直接返回nil func ( n * Node ) DelNode ( delID uint64 ) error { return nil } 4. 接入共识算法 4.1 配置文件 可以通过配置 order.toml 文件，自定义你的共识算法。 [solo] batch_timeout = \"0.3s\" # Block packaging time period. [solo.mempool] batch_size = 200 # How many transactions should the primary pack. pool_size = 50000 # How many transactions could the txPool stores in total. tx_slice_size = 10 # How many transactions should the node broadcast at once tx_slice_timeout = \"0.1s\" # Node broadcasts transactions if there are cached transactions, although set_size isn't reached yet 4.2 项目结构 在 bitxhub/pkg/order 目录下开发对应的共识算法，目录结构与solo、raft模式类似 ./ ├── config.go ├── node.go ├── node_test.go 4.3 新增共识算法 bitxhub-core 项目下定义了共识类型的注册方法。 // 注册对应的共识算法，在共识算法init中指定 func RegisterRegistryConstructor ( typ string , f RegistryConstructor ) { RegisterConstructorM [ typ ] = f } // 根据bitxhub.toml文件的共识类型，加载对应的共识算法 func GetRegistryConstructor ( typ string ) ( RegistryConstructor , error ) { registry , ok := RegisterConstructorM [ typ ] if ! ok { return nil , fmt . Errorf ( \"type %s registry is unsupported\" , typ ) } return registry , nil } 在构造节点共识算法时，只需要在init方法中指定家在的具体newNode构造器即可，如solo模式下： func init () { agency . RegisterOrderConstructor ( \"solo\" , NewNode ) }","text_tokens":["go1.13","debugf","commit","池中","create","chainstate","get","select","不","比如","处理","$","区块","debug","轻松","checkpoint","now","%","logrus","yet","以","_","generate","被","blocktick","并","raftproto","return","容纳","打包","选出","option","locallist","读取","collect","msg","mkdir","进入","exit","but","=","warningf","tx","withcancel","存储","unixnano","新","。","停止","'","家","total","subscribetxevent","mempoolconf","reporoot","新增","ordertype","digest","关闭",",","好","接口","when","完成","solo","state","返回","in","your","即可","test","stores","产生","events","cancel","选举","broadcasts","isnew","are","memconfig","number","开发","int","插件",";","prepare","中","core","should","block","设置","start","确认","listenevent","账本","删除","以及","newtimer","call","startbatchtimer","-","间隔","bitxhub","string"," ","3","更加","和","cached","stopbatchtimer","it","logger","execute","符合","batchtimer","point","primary","2.2","构造","getpendingnoncebyaccount","自己","（","数是","listenreadyblock","batchtimermgr","skip","账户","8","index","排序","period","proposed","proposec","1.0","2.1","到","[","流程","delnode","storagepath","plugin","raft","timeout","扫描","开启","ok","ready","给","pending","4.2","timestamp","etcdraft","：","isn","是","getpendingtxbyhash","solonode","发送到","context","registryconstructor",":","api","txlist","只","在","typ","struct","指定","0","下定义","could","刷","pool","getregistryconstructor","from","加入","系统","类似","fields","account","定义","根","一些","len","6","后","的","与","交易","50000","对应","清理","为了","使用","条件","txslicesize","lastexec","nil","stop","4.1","一个","batchtimeout","for","info","做","实现","调用","nonce","batchsize","+","本","集群","received","资源","done","哈希","过程","count","接入","当前","最新","config","私钥","首先","mempool","路径","report","postproposal","expects","crypto","try","广播","v","go","配置","作用","故","cd","mod","once","peermanager","方法","项目","这个","privkey","a","3.1","然后","requestbatch","地址","定时","看看","工程","batchc","下定","1","通知","txslicetimeout","单","可能","time","创建","id","peermgr","delid","!","如","十个","to","结合","registerconstructorm","事件","具体","{","日志","registerregistryconstructor","单次","is","选择","txs","reportstate","组件","来","priorityindex","是否","pack","newtxcache","version","类型","event","简单","error","txhashlist","共识","address","++","）","获取","9","判断","会","expired","收集","网络地址","程序","对象","传递","建立","描述","processtransactions","init","w","/","监听","getaccountnonce","化","chan","送到","set","#","通道","the","下面","展示","pkg","化后","出块","传入","many","commitc","broadcast","func","of","介绍","1024","已经","必要","registerorderconstructor","first","中来","bool","\"","10","withfields","ignore","background","generateblock","-----","txpool","txsetc",")","实例","学习","leader","height","chainheight","文件","&","opts","订阅","network","seq","hash","要求","释放","提供","byte","如何","packed","数量","infof","200","自定义","toml","transactions","账号","等","数","功能","unsupported","order","how","注册","batchtimeoutevent","fmt","isbatchtimeractive","落盘","值","packages","发送","4","mempoolinst","getblockbyheight","cancelfunc","函数","ctx","packsize","可以","于","最大","executeevent","d","主要","多笔","input","duration","时","需要","编写","agency","quorum","manager","核心","基本","length","按照","自定","types","把","每","池","0.3","last","工作","目的","模块","else","示例","准备","true","]","t","}","haspendingrequest","receive","通过","i","recvtxc","(","size","应该","there","完整","环境","5","...","txcache","模式","type","at","privatekey","subscription","proposal","n","快速","最少","将","结构","maximum","errorf","高度","fieldlogger","0.1","├","3.2","cache","case","构建","配置文件","节点","nodes","相关","加载","教程","有","pb","if","s","poolsize","receives","batchmgr","<","reached","参数","batch","规定","txset","从","blockhash","make","instance","便捷","check","generateconfig","4.3","although","概念","packaging","细节","committransactions","你","消息","sync","进行","listen","如下","this",".","能","根据","3.3","applied","安装","err","接收","持久","这些","7","node","map","slice","gopath","project","newmempool","*","interface","transaction","f","2","构造函数","下","时间","为例","入口","代码","算法","目录","交互","直接","newnode","─","rwmutex","正常","地","器","step","loop","网络","由于","、","schedule","commitevent","我们","registry","是否是","channel","gettransactionfunc","符合条件","uint64","statec","版本","，","服务","了","进","blockheader","该","generatesoloconfig","开始","timer"],"title":"共识算法插件方案","title_tokens":["插件","算法","共识","方案"]},{"location":"bitxhub/design/consensus_plugin/#_1","text":"在本教程中，你将构建一个完整功能的共识服务。过程中能学习基本的概念和具体使用细节。该示例将展示如何快速、轻松地**接入自己的共识算法到BitXHub中来**。","text_tokens":["将","一个","算法","中来","示例","到","在","bitxhub","概念","细节","你","构建","本","该","地","学习","和","具体","过程","教程","能","、","轻松","接入","。","的","如何","完整","展示","，","*","基本","自己","服务","中","使用","共识","快速","功能"],"title":"共识算法插件","title_tokens":["插件","算法","共识"]},{"location":"bitxhub/design/consensus_plugin/#1","text":"安装 go1.13+ 设置好$GOPATH等环境","text_tokens":["go1.13","设置","好","+","等","环境","安装","$","gopath"," "],"title":"1. 开发要求","title_tokens":["要求",".","开发","1"," "]},{"location":"bitxhub/design/consensus_plugin/#2","text":"为了更加便捷的开发共识服务接入到 BitXHub 中来，我们提供了一些接口和参数。","text_tokens":["接口","便捷","中来","到","bitxhub"," ","更加","和","接入","一些","我们","。","的","提供","开发","，","服务","为了","参数","了","共识"],"title":"2. 准备","title_tokens":[".","2","准备"," "]},{"location":"bitxhub/design/consensus_plugin/#21-order","text":"我们规定了下面一些必要的接口，这些接口是 BitXHub 与共识服务的交互接口。 type Order interface { //开启共识服务 Start () error //停止共识服务，关闭共识服务资源 Stop () //交易发送到共识服务，共识服务将处理并打包该交易 Prepare ( tx * pb . Transaction ) error //返回打包的区块 Commit () chan * pb . Block //从网络接收到的共识消息 Step ( ctx context . Context , msg [] byte ) error //集群中产生了新Leader，系统通过该接口判断共识服务是否正常 Ready () bool //系统会通知该接口已经持久化的区块， ReportState ( height uint64 , hash types . Hash ) //集群中可以正常工作的最少节点数量，如在raft中要求正常节点数是N/2+1 Quorum () uint64 //获取账户最新的nonce GetPendingNonceByAccount ( account string ) uint64 //根据哈希获取指定的交易 GetPendingTxByHash ( hash * types . Hash ) pb . Transaction //从共识删除指定的节点 DelNode ( delID uint64 ) error //订阅交易事件的通道 SubscribeTxEvent ( events chan <- pb . Transactions ) event . Subscription }","text_tokens":["工作","通知","到","commit","[","delid","]","delnode","如","}","处理","raft","通过","事件","开启","区块","(","reportstate","ready","是否","event","type","是","subscription","error","getpendingtxbyhash","共识","n","context","并","发送到","判断","获取","会","打包","将","最少","在","msg","指定","节点","系统","account","pb","/","tx","一些","化","chan","送到","。","新","停止","的","与","通道","下面","交易","<","subscribetxevent","规定","从","关闭","stop",",","已经","接口","必要","bool","返回","nonce","消息","+",")","集群","资源","leader","height","哈希",".","根据","产生","events","订阅","接收","持久","这些","hash","要求","byte","最新","数量","*","interface","transactions","prepare","中","transaction","block","2","order","start","删除","交互","-","1","发送","bitxhub","string"," ","ctx","正常","可以","step","网络","我们","uint64","quorum","，","getpendingnoncebyaccount","服务","数是","了","types","该","{","账户"],"title":"2.1 Order接口","title_tokens":["order","接口","2.1"," "]},{"location":"bitxhub/design/consensus_plugin/#22-config","text":"我们规定了下面一些参数可以从BitXHub传递给共识服务。 type Config struct { Id uint64 //节点ID IsNew bool //是否是新加入的节点 RepoRoot string //根路径 StoragePath string //存储文件路径 OrderType string // 共识类型 PeerMgr peermgr . PeerManager //网络模块组件 PrivKey crypto . PrivateKey //节点私钥 Logger logrus . FieldLogger //日志组件 Nodes map [ uint64 ] types . Address //集群节点网络地址 Applied uint64 //当前区块高度 Digest string //当前区块哈希 GetTransactionFunc func ( hash types . Hash ) ( * pb . Transaction , error ) // 获取已经持久化的交易函数 GetBlockByHeight func ( height uint64 ) ( * pb . Block , error ) // 获取指定高度的区块 GetAccountNonce func ( address * types . Address ) uint64 // 获取指定账户的nonce }","text_tokens":["模块","[","id","peermgr","]","storagepath","}","日志","区块","(","组件","给","是否","logrus","类型","type","privatekey","error","共识","address","获取","高度","网络地址","fieldlogger","struct","指定","传递","节点","nodes","加入","pb","/","根","getaccountnonce","一些","存储","化","新","。","的","下面","交易","参数","reporoot","规定","从","func","ordertype","digest",",","已经","bool","nonce","集群",")","哈希","height",".","文件","applied","持久","isnew","当前","hash","map","config","私钥","*","路径","transaction","block","crypto","bitxhub","string"," ","getblockbyheight","函数","可以","网络","logger","我们","是否是","gettransactionfunc","peermanager","uint64","privkey","服务","地址","了","types","{","账户"],"title":"2.2 Config参数","title_tokens":["参数","2.2","config"," "]},{"location":"bitxhub/design/consensus_plugin/#3","text":"本教程以开发一个简单Solo版本的共识算法为例。","text_tokens":["为例","简单","一个","。","算法","本","教程","的","共识","solo","开发","以","版本"],"title":"3. 程序目的","title_tokens":["目的","3","程序","."," "]},{"location":"bitxhub/design/consensus_plugin/#31","text":"首先选择你的工程目录，按照正常的GO程序的流程建立项目 $ go version // 确认你安装的GO版本 $ mkdir ${ YOUR_PROJECT } $ cd ${ YOUR_PROJECT } $ go mod init","text_tokens":["确认","go","目录","程序"," ","mkdir","流程","建立","}","your","你","cd","正常","init","$","选择","/","安装","mod","的","项目","version","_","首先","版本","project","，","按照","工程","{"],"title":"3.1 开始编写你的程序","title_tokens":["3.1","编写","你","的","程序","开始"," "]},{"location":"bitxhub/design/consensus_plugin/#32-node","text":"首先创建一个 node.go 文件，这个文件是共识Plugin的核心和入口，来看看 Node 具体结构 type Node struct { ID uint64 commitC chan * pb . CommitEvent // block channel logger logrus . FieldLogger // logger mempool mempool . MemPool // transaction pool proposeC chan * raftproto . RequestBatch // proposed listenReadyBlock, input channel stateC chan * mempool . ChainState txCache * mempool . TxCache // cache the transactions received from api batchMgr * etcdraft . BatchTimer lastExec uint64 // the index of the last-applied block packSize int // maximum number of transaction packages blockTick time . Duration // block packed period peerMgr peermgr . PeerManager // network manager ctx context . Context cancel context . CancelFunc sync . RWMutex } 然后应该提供一个 Order 的实例化的接口（类似于构造函数），具体代码如下： func NewNode ( opts ... order . Option ) ( order . Order , error ) { //处理Order参数 config , err := order . GenerateConfig ( opts ... ) if err != nil { return nil , fmt . Errorf ( \"generate config: %w\" , err ) } ctx , cancel := context . WithCancel ( context . Background ()) //读取mempool相关配置，batchTimeout出块时间，memConfig配置 batchTimeout , memConfig , err := generateSoloConfig ( config . RepoRoot ) mempoolConf := & mempool . Config { ID : config . ID , //节点ID ChainHeight : config . Applied , //当前区块高度 Logger : config . Logger , //日志组件 StoragePath : config . StoragePath , //存储路径 GetAccountNonce : config . GetAccountNonce , // 获取账户nonce BatchSize : memConfig . BatchSize , //区块最大交易数 PoolSize : memConfig . PoolSize , //交易池容纳最大交易数 TxSliceSize : memConfig . TxSliceSize , //单次广播最大交易数 TxSliceTimeout : memConfig . TxSliceTimeout , //单次广播交易间隔 } batchC := make ( chan * raftproto . RequestBatch ) //实例化mempool，mempool的作用是交易排序 mempoolInst , err := mempool . NewMempool ( mempoolConf ) if err != nil { return nil , fmt . Errorf ( \"create mempool instance: %w\" , err ) } //实例化txCache交易池 txCache := mempool . NewTxCache ( mempoolConf . TxSliceTimeout , mempoolConf . TxSliceSize , config . Logger ) batchTimerMgr := etcdraft . NewTimer ( batchTimeout , config . Logger ) soloNode := & Node { ID : config . ID , commitC : make ( chan * pb . CommitEvent , 1024 ), stateC : make ( chan * mempool . ChainState ), lastExec : config . Applied , mempool : mempoolInst , txCache : txCache , batchMgr : batchTimerMgr , peerMgr : config . PeerMgr , proposeC : batchC , logger : config . Logger , ctx : ctx , cancel : cancel , } soloNode . logger . Infof ( \"SOLO lastExec = %d\" , soloNode . lastExec ) soloNode . logger . Infof ( \"SOLO batch timeout = %v\" , batchTimeout ) return soloNode , nil }","text_tokens":["last","index","txslicetimeout","排序","period","time","proposed","proposec","create","创建","id","chainstate","peermgr","!","storagepath","plugin","}","处理","timeout","具体","日志","单次","区块","(","组件","来","%","应该","logrus","newtxcache","...","txcache","type","etcdraft","：","generate","是","error","blocktick","共识","solonode","）","context","获取","raftproto","return","容纳","结构","option","maximum",":","api","errorf","读取","高度","fieldlogger","struct","cache","pool","节点","from","类似","相关","w","=","pb","if","/","poolsize","getaccountnonce","withcancel","存储","化","chan","batchmgr","的","the","交易","出块","参数","mempoolconf","commitc","txslicesize","batch","reporoot","lastexec","func","of","nil","make","1024",",","一个","接口","instance","batchtimeout","generateconfig","solo","\"","background","nonce","batchsize","received",")","sync","实例","如下","chainheight",".","文件","&","applied","cancel","opts","err","network","当前","node","number","memconfig","提供","packed","config","首先","newmempool","infof","*","mempool","int","路径","transactions","transaction","block","数","构造函数","时间","order","入口","fmt","代码","广播","v","go","newtimer","-","newnode","packages","间隔","配置","mempoolinst"," ","作用","cancelfunc","rwmutex","函数","ctx","packsize","于","最大","和","d","logger","input","duration","commitevent","batchtimer","channel","peermanager","uint64","这个","manager","statec","构造","池","，","核心","（","然后","requestbatch","listenreadyblock","batchtimermgr","看看","batchc","generatesoloconfig","{","账户"],"title":"3.2 Node对象","title_tokens":["node","3.2","对象"," "]},{"location":"bitxhub/design/consensus_plugin/#33-node","text":"通过描述Node的主要方法，介绍pending的交易是如何被打包到区块中以及如何与 BitXHub 系统进行交互。","text_tokens":["打包","介绍","以及","交互","到","bitxhub"," ","描述","通过","进行","系统","主要","区块","。","pending","node","的","方法","与","如何","交易","，","中","被","是"],"title":"3.3 Node主要方法","title_tokens":["node","方法","主要","3.3"," "]},{"location":"bitxhub/design/consensus_plugin/#331-start","text":"功能：定时在交易池中扫描交易并出块。 func ( n * Node ) Start () error { //交易池打包区块 go n . txCache . ListenEvent () //solo监听新区块 go n . listenReadyBlock () return nil } // Schedule to collect txs to the listenReadyBlock channel func ( n * Node ) listenReadyBlock () { go func () { for { select { case proposal := <- n . proposeC : n . logger . WithFields ( logrus . Fields { \"proposal_height\" : proposal . Height , \"tx_count\" : len ( proposal . TxList ), }). Debugf ( \"Receive proposal from mempool\" ) if proposal . Height != n . lastExec + 1 { n . logger . Warningf ( \"Expects to execute seq=%d, but get seq=%d, ignore it\" , n . lastExec + 1 , proposal . Height ) return } n . logger . Infof ( \"======== Call execute, height=%d\" , proposal . Height ) block := & pb . Block { BlockHeader : & pb . BlockHeader { Version : [] byte ( \"1.0.0\" ), Number : proposal . Height , Timestamp : time . Now (). UnixNano (), }, Transactions : proposal . TxList , } localList := make ([] bool , len ( proposal . TxList )) for i := 0 ; i < len ( proposal . TxList ); i ++ { localList [ i ] = true } executeEvent := & pb . CommitEvent { Block : block , LocalList : localList , } n . commitC <- executeEvent n . lastExec ++ } } }() for { select { case <- n . ctx . Done (): n . logger . Info ( \"----- Exit listen ready block loop -----\" ) return case txSet := <- n . txCache . TxSetC : // start batch timer when this node receives the first transaction if ! n . batchMgr . IsBatchTimerActive () { n . batchMgr . StartBatchTimer () } if batch := n . mempool . ProcessTransactions ( txSet . TxList , true , true ); batch != nil { n . batchMgr . StopBatchTimer () n . proposeC <- batch } case state := <- n . stateC : //每十个区块做一个Check Point if state . Height % 10 == 0 { n . logger . WithFields ( logrus . Fields { \"height\" : state . Height , \"hash\" : state . BlockHash . String (), }). Info ( \"Report checkpoint\" ) } n . mempool . CommitTransactions ( state ) case <- n . batchMgr . BatchTimeoutEvent (): n . batchMgr . StopBatchTimer () n . logger . Debug ( \"Batch timer expired, try to create a batch\" ) if n . mempool . HasPendingRequest () { if batch := n . mempool . GenerateBlock (); batch != nil { n . postProposal ( batch ) } } else { n . logger . Debug ( \"The length of priorityIndex is 0, skip the batch timer\" ) } } } }","text_tokens":["time","proposec","else","1.0","debugf","池中","create","[","get","true","select","!","]","十个","}","to","haspendingrequest","receive","扫描","{","is","区块","txs","i","debug","(","ready","priorityindex","checkpoint","now","%","logrus","version","_","txcache","timestamp","：","error","proposal","n","++","并","return","打包","expired",":","locallist","txlist","collect","在","0","exit","case","but","processtransactions","from","fields","=","pb","if","/","warningf","监听","tx","unixnano","len","receives","新","。","batchmgr","the","交易","<","出块","commitc","batch","lastexec","txset","func","nil","make","blockhash","of",",","一个","check","when","first","for","info","做","solo","bool","\"","state","10","withfields","ignore","generateblock","committransactions","-----","+","txsetc",")","done","height","listen","this",".","&","count","seq","node","number","hash","byte","infof","*","mempool",";","report","transactions","transaction","block","postproposal","expects","功能","start","listenevent","batchtimeoutevent","try","isbatchtimeractive","go","call","startbatchtimer","-","string"," ","ctx","executeevent","loop","stopbatchtimer","d","it","logger","execute","schedule","commitevent","point","channel","a","statec","length","listenreadyblock","定时","blockheader","skip","每","池","1","timer"],"title":"3.3.1 Start方法","title_tokens":["start","方法",".","3.3","1"," "]},{"location":"bitxhub/design/consensus_plugin/#332-stop","text":"功能：停止共识，释放共识相关资源。 func ( n * Node ) Stop () { n . cancel () }","text_tokens":["func","stop"," ","}",")","资源","相关",".","cancel","(","。","停止","node","释放","，","*","：","共识","n","功能","{"],"title":"3.3.2 Stop方法","title_tokens":["stop","2","方法",".","3.3"," "]},{"location":"bitxhub/design/consensus_plugin/#333-prepare","text":"功能：从 BitXHub 系统中传入交易，收集进交易池。 func ( n * Node ) Prepare ( tx * pb . Transaction ) error { //判断当前共识是否正常 if err := n . Ready (); err != nil { return err } //交易进入交易池 n . txCache . RecvTxC <- tx return nil }","text_tokens":["return","func","nil",":","-","收集","bitxhub"," ","进入","!","从","}",")","正常","系统",".","=","pb","if","/","recvtxc","(","tx","ready","err","。","是否","当前","node","交易","txcache","<","，","*","传入",";","prepare","：","中","transaction","error","共识","进","n","功能","池","{","判断"],"title":"3.3.3 Prepare方法","title_tokens":["3","prepare","方法",".","3.3"," "]},{"location":"bitxhub/design/consensus_plugin/#334-commit","text":"功能：返回新区块的 channel 。 func ( n * Node ) Commit () chan * pb . Block { return n . commitC }","text_tokens":["return","func","commit","返回"," ","}",")",".","pb","区块","(","新","chan","。","channel","node","的","*","：","block","commitc","n","功能","{"],"title":"3.3.4 Commit方法","title_tokens":["4","方法","commit",".","3.3"," "]},{"location":"bitxhub/design/consensus_plugin/#335-step","text":"功能：通过该接口接收共识的网络消息。 //由于示例是Solo的版本，故具体不实现该方法 func ( n * Node ) Step ( ctx context . Context , msg [] byte ) error { return nil }","text_tokens":["context","func","return","nil",",","接口","示例","solo","msg"," ","[","实现","不","]","ctx","故","}","消息",")","通过","step","具体","网络","由于",".","/","(","接收","。","方法","的","node","功能","byte","版本","，","*","：","是","error","共识","n","该","{"],"title":"3.3.5 Step方法","title_tokens":["方法","step",".","3.3","5"," "]},{"location":"bitxhub/design/consensus_plugin/#336-ready","text":"功能：判断共识是否完成，Leader是否完成选举。 //由于示例是Solo的版本，单节点直接返回True func ( n * Node ) Ready () bool { return true }","text_tokens":["return","func","单","直接","示例","完成","solo","bool","返回"," ","true","}",")","节点","leader","由于","/","(","选举","ready","。","是否","node","的","版本","，","*","：","是","共识","n","功能","{","判断"],"title":"3.3.6 Ready方法","title_tokens":["ready","6","方法",".","3.3"," "]},{"location":"bitxhub/design/consensus_plugin/#337-reportstate","text":"功能：新区块被持久化后， BitXHub 会调用该接口通知共识服务 func ( n * Node ) ReportState ( height uint64 , blockHash * types . Hash , txHashList [] * types . Hash ) { state := & mempool . ChainState { Height : height , BlockHash : blockHash , TxHashList : txHashList , } //结合listenReadyBlock()，账本落盘区块后通知共识清理相关资源 n . stateC <- state }","text_tokens":["会","func","通知","blockhash",":",",","接口","账本","落盘","-","state","bitxhub","["," ","chainstate","调用","]","}","结合",")","资源","height","相关",".","=","区块","&","/","(","reportstate","新","types","持久","后","node","hash","uint64","功能","statec","<","，","化后","*","mempool","服务","清理","：","被","listenreadyblock","txhashlist","共识","n","该","{"],"title":"3.3.7 ReportState方法","title_tokens":["reportstate","7","方法",".","3.3"," "]},{"location":"bitxhub/design/consensus_plugin/#338-quorum","text":"功能：集群中可以正常工作的最少节点数量（比如在raft中要求正常节点数是N/2+1）。 //由于示例是Solo的版本，直接返回1 func ( n * Node ) Quorum () uint64 { return 1 }","text_tokens":["return","最少","工作","func","直接","示例","在","solo","返回"," ","比如","}","raft","+","集群","可以","正常","节点",")","{","由于","/","(","。","node","的","要求","uint64","quorum","数量","版本","，","*","（","数是","中","：","是","2","n","）","功能","1"],"title":"3.3.8 Quorum方法","title_tokens":["8","方法","quorum",".","3.3"," "]},{"location":"bitxhub/design/consensus_plugin/#339-getpendingnoncebyaccount","text":"功能：获取指定账户最新的nonce值。 func ( n * Node ) GetPendingNonceByAccount ( account string ) uint64 { // 直接从交易池中获取当前账户的最新nonce，由于交易池中可能有该账号的多笔交易， // 需要把符合条件的nonce刷选出。 return n . mempool . GetPendingNonceByAccount ( account ) }","text_tokens":["return","func","选出","可能","直接","值","池中","string"," ","指定","nonce","}","刷","该",")","由于","多笔","account","有",".","/","(","符合","需要","。","当前","获取","node","的","符合条件","uint64","最新","交易","*","getpendingnoncebyaccount","，","mempool","：","账号","条件","n","把","功能","从","{","账户"],"title":"3.3.9 GetPendingNonceByAccount方法","title_tokens":["getpendingnoncebyaccount","3.3","方法",".","9"," "]},{"location":"bitxhub/design/consensus_plugin/#3310-delnode","text":"功能：删除指定的共识节点。 //由于示例是Solo的版本，直接返回nil func ( n * Node ) DelNode ( delID uint64 ) error { return nil }","text_tokens":["return","nil","func","删除","直接","示例","solo","返回"," ","指定","delid","delnode","}",")","节点","由于","/","(","。","node","的","uint64","版本","，","*","：","是","error","共识","n","功能","{"],"title":"3.3.10 DelNode方法","title_tokens":["delnode","方法","10",".","3.3"," "]},{"location":"bitxhub/design/consensus_plugin/#4","text":"","text_tokens":[],"title":"4. 接入共识算法","title_tokens":["接入","算法","共识",".","4"," "]},{"location":"bitxhub/design/consensus_plugin/#41","text":"可以通过配置 order.toml 文件，自定义你的共识算法。 [solo] batch_timeout = \"0.3s\" # Block packaging time period. [solo.mempool] batch_size = 200 # How many transactions should the primary pack. pool_size = 50000 # How many transactions could the txPool stores in total. tx_slice_size = 10 # How many transactions should the node broadcast at once tx_slice_timeout = \"0.1s\" # Node broadcasts transactions if there are cached transactions, although set_size isn't reached yet","text_tokens":["order","how","period",",","time","算法","0.1","solo","配置","\"","10","although","["," ","packaging","]","t","in","could","你","pool","txpool","可以","通过","cached","timeout","stores",".","文件","定义","=","s","if","once","tx","broadcasts","。","set","are","#","size","primary","的","pack","node","'","the","slice","total","there","yet","_","50000","200","自定义","，","toml","mempool","at","reached","transactions","自定","many","isn","should","block","共识","batch","broadcast","0.3"],"title":"4.1 配置文件","title_tokens":["4.1","文件","配置文件","配置"," "]},{"location":"bitxhub/design/consensus_plugin/#42","text":"在 bitxhub/pkg/order 目录下开发对应的共识算法，目录结构与solo、raft模式类似 ./ ├── config.go ├── node.go ├── node_test.go","text_tokens":["order","结构","算法","go","目录","在","solo","├","bitxhub","─"," ","raft","test","类似","、",".","/","node","的","与","开发","config","_","模式","pkg","，","对应","下","共识"],"title":"4.2 项目结构","title_tokens":["项目","4.2","结构"," "]},{"location":"bitxhub/design/consensus_plugin/#43","text":"bitxhub-core 项目下定义了共识类型的注册方法。 // 注册对应的共识算法，在共识算法init中指定 func RegisterRegistryConstructor ( typ string , f RegistryConstructor ) { RegisterConstructorM [ typ ] = f } // 根据bitxhub.toml文件的共识类型，加载对应的共识算法 func GetRegistryConstructor ( typ string ) ( RegistryConstructor , error ) { registry , ok := RegisterConstructorM [ typ ] if ! ok { return nil , fmt . Errorf ( \"type %s registry is unsupported\" , typ ) } return registry , nil } 在构造节点共识算法时，只需要在init方法中指定家在的具体newNode构造器即可，如solo模式下： func init () { agency . RegisterOrderConstructor ( \"solo\" , NewNode ) }","text_tokens":["[","]","!","如","}","registerconstructorm","registerregistryconstructor","具体","is","ok","(","%","类型","模式","type","：","error","共识","return","registryconstructor",":","errorf","只","在","typ","指定","下定义","getregistryconstructor","节点","init","加载","=","定义","if","s","/","。","的","家","对应","func","nil",",","registerorderconstructor","solo","\"",")","即可",".","根据","文件","toml","中","core","f","下","unsupported","注册","fmt","算法","-","newnode","bitxhub","string"," ","器","时","registry","需要","agency","方法","项目","构造","，","了","下定","{"],"title":"4.3 新增共识算法","title_tokens":["新增","算法","共识","4.3"," "]},{"location":"bitxhub/design/erc20_interchian/","text":"ERC20资产跨链 1. 概述 解决ERC20资产跨链问题，支持任意ERC20资产的跨链交易。 2.详细设计 ERC20资产跨链方案采用中继节点多签的资产交换方案，中继链每个节点是应用链托管合约的成员，节点需同步对应应用链的区块头信息，通过这种方式验证跨链交易的有效性，关于验证的过程可以放在验证规则内，同时在用户充值和提现的流程中保证跨链交易的原子性，达到跨链资产与锚定资产的一致性。这里以三个方面来解决ERC20的跨链问题： 如何同步可靠的应用链区块头； 如何设计托管合约，同时兼顾其安全性； 如何设计用户的充值、提现流程，尽量简化用户操作； 2.1 同步区块头 同步区块头有两种方案，一种是Oracle预言机的方式，一种是系统内置集成同步区块头模块。 方案一： 通过Oracle可信预言机(跨链网关)，向中继链区块头合约注入应用链的区块头，区块头合约包含验证跨链交易和增加区块的功能。该方案的优点是可以灵活适配各个应用链，缺点是依赖外部的可信数据源。 区块头合约的主要接口如下： func AppendAppchainBlockHeader ( appchainId , blockHeader ) func VerifyInterchainTxProof ( originTx , proof , blockHeight ) 方案二： 跨链平台内置集成同步区块头模块，该方案的优点是去中心化，缺点是耦合性强，每接入新的应用链需要加入新的同步区块头模块；同步区块头是中继链节点主动获取，还需要考虑网络问题。 区块头模块的主要接口如下： func FetchAppchainBlockHeader ( blockHeader ) func VerifyInterchainTxProof ( originTx , proof , blockHeight ) 2.2 托管合约 ERC20包含如下接口： interface IERC20 { function totalSupply () external view returns ( uint256 ); function balanceOf ( address account ) external view returns ( uint256 ); function transfer ( address recipient , uint256 amount ) external returns ( bool ); function allowance ( address owner , address spender ) external view returns ( uint256 ); function approve ( address spender , uint256 amount ) external returns ( bool ); function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ); event Transfer ( address indexed from , address indexed to , uint256 value ); event Approval ( address indexed owner , address indexed spender , uint256 value ); } 在跨链充值过程中我们需要用到ERC20合约中的**approve**授权方法和**transferFrom**转账方法， 同时还需要提供**name**和**decimal**的元信息。 function approve ( address spender , uint256 amount ) external returns ( bool ); function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ); 在跨链提现过程中我们需要用到ERC20合约中的**transfer**转账方法。 function transfer ( address recipient , uint256 amount ) external returns ( bool ); 托管合约主要接口如下： event lock ( address erc20Token , uint256 amount , string relay_addr ) event unlock ( address unlock , uint256 amount , string ralay_tx_hash ,) // 添加中继链多签节点地址 func addRelayAdmin ( address relay_admin ) onlyAdmin external returns ( bool ) // 移除中继链多签节点地址 func removeRelayAdmin ( address relay_admin ) onlyAdmin external returns ( bool ) // 用户授权托管合约可以使用ERC20的代币 function approve ( address erc20Token , address spender , uint256 amount ) external returns ( bool ) // 用户发起跨链交易,将ERC20代币锁仓进托管合约 function lock ( address erc20Token , uint256 amount , string relay_addr ) external returns ( bool ); // 中继链解锁跨链资产，将ERC20代币归还用户 // 该接口需要接收quorum个中继链节点的签名后才可归还资产 function unlock ( address erc20Token , uint256 amount , address unlocker , string ralay_tx_hash , r [][] byte , s [][] byte , v [][] byte ) external returns ( bool ); 2.3 充值、提现流程设计 用户充值流程： 用户调用托管合约，授权托管合约允许使用指定ERC20的资产； 用户调用托管合约发起跨链交易； 托管合约接收到ERC20资产，抛出跨链事件（ERC20_Contract、ERC20_Name、ERC20_Decimal、ERC20_Amount、Relay_Addr）; 跨链网关监听到跨链事件，封装IBTP（原应用链Tx、跨链交易证明、中继链地址、跨链金额等等）； 跨链网关发送跨链交易给中继链； 中继链接收到跨链交易后，验证跨链交易的有效性； 验证失败后会在跨链网关诚信合约惩罚对应的跨链网关（待定）； 验证成功后检查资产列表，如果是新增资产则新建对应的ERC20资产托管合约； 通过跨链交易的（Amount、Addr）增发等额的锚定资产，用户完成跨链充值操作； 用户提现流程： 用户在中继链上发起提现请求（目的链地址，ERC20地址，金额，用户应用链地址）； 中继链接收到交易，冻结用户在中继链等额的锚定资产； 中继链发起跨链交易，抛出跨链事件（目的链地址，ERC20地址，金额，用户应用链地址）； 跨链网关监听到跨链事件，构造对应应用链的交易； 跨链网关将应用链的交易发往中继链； 中继链解析并校验应用链的交易，包括地址，金额等等； 中继链验证通过后签名，发完其它中继链要求其签名； 跨链网关获取到中继链节点的多重签名数据，调用应用链的托管合约； 应用链归还资产，抛出解锁事件； 跨链网关监听到解锁事件，发往中继链； 中继链验证通过后销毁对应的锚定资产；","text_tokens":["这种","目的","2.3","关于","模块","包含","信息","2.1","到","性强","链多签","授权","每","适配","用户","[","流程","]","；","to","合约","内","}","decimal","indexed","检查","通过","如果","事件","{","relay","区块","设计","(","增发","列表","中心化","来","请求","其它","方面","简化","转账","给","新建","保证","校验","中继","allowance","达到","verifyinterchaintxproof","以","_","失败","event","验证","才","中心","：","详细","是","需","性","这里","address","一致","transferfrom","）","获取","等等","成功","并","销毁","将","原","机","操作","冻结","规则","在","unlocker","unlock","二","transfer","指定","其","方案","balanceof","blockheight","签名","链接","节点","from","erc20token","代币","预言","系统","加入","惩罚","资产","解决","account","待定","s","链上","/","监听","tx","新","。","放在","后","成员","考虑","的","与","value","交换","个","交易","一种","onlyadmin","一致性","则","对应","托管","使用","有效","添加","用到","name","同时","两种","func","新增",",","view","优点","接口","允许","支持","contract","完成","任意","链","bool","移除","数据源","发","调用","方式","returns","原子","内置",")","后会","如下","元","过程",".","ierc20","appchainid","去","提现","addrelayadmin","一","接入","解锁","依赖","external","接收","包括","addr","充值","三个","appendappchainblockheader","hash","概述","提供","要求","头","amount","如何","origintx","锁仓进","byte","封装","往","缺点","*","平台","interface","发起","增加","采用",";","金额","多重","兼顾","中","2","admin","头有","function","证明","owner","功能","spender","尽量","v","耦合","等额","诚信","收到","安全","锚定","sender","erc20","解析","lock","ibtp","各个","外部","发送","string","ralay"," ","安全性","抛出","注入","主动","approve","可以","和","跨链","还","网络","、","主要","完","多签","需要","我们","灵活","可靠","proof","approval","方法","oracle","quorum","recipient","2.2","r","同步","removerelayadmin","归还","问题","可归还","构造","，","网关","（","totalsupply","每个","fetchappchainblockheader","向","地址","有效性","应用","集成","uint256","blockheader","该","可信","1","数据"],"title":"ERC20资产跨链","title_tokens":["资产","跨链","erc20"]},{"location":"bitxhub/design/erc20_interchian/#erc20","text":"","text_tokens":[],"title":"ERC20资产跨链","title_tokens":["资产","跨链","erc20"]},{"location":"bitxhub/design/erc20_interchian/#1","text":"解决ERC20资产跨链问题，支持任意ERC20资产的跨链交易。","text_tokens":["问题","，","。","支持","跨链","的","erc20","任意","资产","解决","交易"],"title":"1. 概述","title_tokens":[".","概述","1"," "]},{"location":"bitxhub/design/erc20_interchian/#2","text":"ERC20资产跨链方案采用中继节点多签的资产交换方案，中继链每个节点是应用链托管合约的成员，节点需同步对应应用链的区块头信息，通过这种方式验证跨链交易的有效性，关于验证的过程可以放在验证规则内，同时在用户充值和提现的流程中保证跨链交易的原子性，达到跨链资产与锚定资产的一致性。这里以三个方面来解决ERC20的跨链问题： 如何同步可靠的应用链区块头； 如何设计托管合约，同时兼顾其安全性； 如何设计用户的充值、提现流程，尽量简化用户操作；","text_tokens":["这种","尽量","操作","关于","规则","信息","锚定","安全","erc20","链","在","兼顾","用户"," ","安全性","其","流程","方案","方式","；","原子","合约","内","节点","可以","通过","跨链","和","过程","资产","解决","、","区块","提现","多签","设计","来","。","方面","简化","放在","可靠","成员","充值","的","保证","与","三个","中继","交换","头","达到","交易","以","同步","如何","问题","一致性","验证","，","对应","采用","每个","托管","有效","是","需","中","有效性","应用","性","这里","：","一致","同时"],"title":"2.详细设计","title_tokens":["详细",".","2","设计"]},{"location":"bitxhub/design/erc20_interchian/#21","text":"同步区块头有两种方案，一种是Oracle预言机的方式，一种是系统内置集成同步区块头模块。 方案一： 通过Oracle可信预言机(跨链网关)，向中继链区块头合约注入应用链的区块头，区块头合约包含验证跨链交易和增加区块的功能。该方案的优点是可以灵活适配各个应用链，缺点是依赖外部的可信数据源。 区块头合约的主要接口如下： func AppendAppchainBlockHeader ( appchainId , blockHeader ) func VerifyInterchainTxProof ( originTx , proof , blockHeight ) 方案二： 跨链平台内置集成同步区块头模块，该方案的优点是去中心化，缺点是耦合性强，每接入新的应用链需要加入新的同步区块头模块；同步区块头是中继链节点主动获取，还需要考虑网络问题。 区块头模块的主要接口如下： func FetchAppchainBlockHeader ( blockHeader ) func VerifyInterchainTxProof ( originTx , proof , blockHeight )","text_tokens":["模块","包含","性强","适配","；","合约","通过","区块","(","中心化","中继","verifyinterchaintxproof","验证","中心","：","是","获取","机","二","方案","blockheight","该","节点","预言","系统","加入","新","。","考虑","的","交易","一种","两种","func",",","优点","接口","链","数据源","方式","内置",")","如下","appchainid","去","一","接入","依赖","appendappchainblockheader","头","origintx","缺点","平台","增加","头有","功能","耦合","各个","外部"," ","注入","主动","可以","和","跨链","还","网络","主要","需要","灵活","proof","oracle","同步","问题","，","网关","fetchappchainblockheader","向","集成","应用","blockheader","每","可信","数据"],"title":"2.1 同步区块头","title_tokens":["2.1","头","区块","同步"," "]},{"location":"bitxhub/design/erc20_interchian/#22","text":"ERC20包含如下接口： interface IERC20 { function totalSupply () external view returns ( uint256 ); function balanceOf ( address account ) external view returns ( uint256 ); function transfer ( address recipient , uint256 amount ) external returns ( bool ); function allowance ( address owner , address spender ) external view returns ( uint256 ); function approve ( address spender , uint256 amount ) external returns ( bool ); function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ); event Transfer ( address indexed from , address indexed to , uint256 value ); event Approval ( address indexed owner , address indexed spender , uint256 value ); } 在跨链充值过程中我们需要用到ERC20合约中的**approve**授权方法和**transferFrom**转账方法， 同时还需要提供**name**和**decimal**的元信息。 function approve ( address spender , uint256 amount ) external returns ( bool ); function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ); 在跨链提现过程中我们需要用到ERC20合约中的**transfer**转账方法。 function transfer ( address recipient , uint256 amount ) external returns ( bool ); 托管合约主要接口如下： event lock ( address erc20Token , uint256 amount , string relay_addr ) event unlock ( address unlock , uint256 amount , string ralay_tx_hash ,) // 添加中继链多签节点地址 func addRelayAdmin ( address relay_admin ) onlyAdmin external returns ( bool ) // 移除中继链多签节点地址 func removeRelayAdmin ( address relay_admin ) onlyAdmin external returns ( bool ) // 用户授权托管合约可以使用ERC20的代币 function approve ( address erc20Token , address spender , uint256 amount ) external returns ( bool ) // 用户发起跨链交易,将ERC20代币锁仓进托管合约 function lock ( address erc20Token , uint256 amount , string relay_addr ) external returns ( bool ); // 中继链解锁跨链资产，将ERC20代币归还用户 // 该接口需要接收quorum个中继链节点的签名后才可归还资产 function unlock ( address erc20Token , uint256 amount , address unlocker , string ralay_tx_hash , r [][] byte , s [][] byte , v [][] byte ) external returns ( bool );","text_tokens":["包含","信息","链多签","授权","[","用户","]","to","}","合约","decimal","indexed","relay","(","转账","allowance","中继","_","event","才","：","transferfrom","address","将","在","unlocker","unlock","transfer","balanceof","签名","节点","from","erc20token","代币","资产","account","s","/","tx","。","后","的","value","个","交易","onlyadmin","托管","使用","添加","用到","name","同时","func",",","view","接口","链","bool","移除","returns",")","如下","元","过程","ierc20","addrelayadmin","提现","解锁","external","接收","addr","充值","hash","提供","amount","byte","锁仓进","*","interface","发起",";","中","admin","function","owner","spender","v","sender","erc20","lock","string","ralay"," ","approve","可以","和","跨链","还","主要","需要","我们","approval","方法","quorum","recipient","r","可归还","removerelayadmin","归还","，","totalsupply","地址","uint256","该","{"],"title":"2.2 托管合约","title_tokens":["合约","2.2","托管"," "]},{"location":"bitxhub/design/erc20_interchian/#23","text":"用户充值流程： 用户调用托管合约，授权托管合约允许使用指定ERC20的资产； 用户调用托管合约发起跨链交易； 托管合约接收到ERC20资产，抛出跨链事件（ERC20_Contract、ERC20_Name、ERC20_Decimal、ERC20_Amount、Relay_Addr）; 跨链网关监听到跨链事件，封装IBTP（原应用链Tx、跨链交易证明、中继链地址、跨链金额等等）； 跨链网关发送跨链交易给中继链； 中继链接收到跨链交易后，验证跨链交易的有效性； 验证失败后会在跨链网关诚信合约惩罚对应的跨链网关（待定）； 验证成功后检查资产列表，如果是新增资产则新建对应的ERC20资产托管合约； 通过跨链交易的（Amount、Addr）增发等额的锚定资产，用户完成跨链充值操作； 用户提现流程： 用户在中继链上发起提现请求（目的链地址，ERC20地址，金额，用户应用链地址）； 中继链接收到交易，冻结用户在中继链等额的锚定资产； 中继链发起跨链交易，抛出跨链事件（目的链地址，ERC20地址，金额，用户应用链地址）； 跨链网关监听到跨链事件，构造对应应用链的交易； 跨链网关将应用链的交易发往中继链； 中继链解析并校验应用链的交易，包括地址，金额等等； 中继链验证通过后签名，发完其它中继链要求其签名； 跨链网关获取到中继链节点的多重签名数据，调用应用链的托管合约； 应用链归还资产，抛出解锁事件； 跨链网关监听到解锁事件，发往中继链； 中继链验证通过后销毁对应的锚定资产；","text_tokens":["目的","到","授权","用户","流程","；","合约","decimal","检查","如果","通过","事件","relay","增发","列表","其它","请求","给","新建","校验","中继","失败","_","验证","：","是","成功","等等","）","并","获取","销毁","原","将","操作","冻结","在","指定","其","链接","签名","节点","待定","链上","惩罚","资产","监听","tx","后","的","交易","则","对应","托管","使用","有效","name","新增","允许","contract","完成","链","发","调用","后会","提现","解锁","包括","接收","addr","充值","要求","amount","往","封装","发起","多重","金额",";","证明","等额","诚信","收到","锚定","erc20","解析","ibtp","发送","抛出"," ","跨链","、","完","构造","归还","，","网关","（","地址","有效性","应用","数据"],"title":"2.3 充值、提现流程设计","title_tokens":["提现","设计","流程","2.3","充值","、"," "]},{"location":"bitxhub/design/interchain_transaction/","text":"跨链事务方案 跨链需要保证跨链交易的原子性和一致性，即来源链和目的链上的交易要么都成功，要么都失败回滚。 为此，中继链提供了事务管理机制，通过内置的事务管理合约，来保证不同业务场景下跨链交易的事务性。 多链消息表事务方案是针对非资产交换类业务场景的事务方案，它可以支持一对一跨链和一对多跨链。 一对一跨链 当来源链业务合约发起跨链交易时，除了提供目的链的目标业务合约中要调用的方法和参数外，还可以提供来源链的回调方法和回滚方法。 来源链跨链网关捕获跨链事件封装成IBTP提交到中继链，并由中继链跨链事务合约进行处理。跨链事务合约将初始化该跨链交易所对应的跨链事务， 在跨链事务合约中以KV形式记录跨链事务ID和事务状态信息，其中跨链事务ID由**来源链ID || 目的链ID || IBTP index**组成，初始的跨链状态信息为TransactionStatus_BEGIN。 当目的链执行完跨链交易时，由目的链跨链网关得到执行的结果（成功或失败），并将该信息封装成IBTP receipt提交给中继链。 中继链跨链事务合约根据其中的回执信息，更新跨链事务ID的状态，如果成功，则状态更新为TransactionStatus_SUCCESS，否则为TransactionStatus_FAILURE。 如果跨链事务最终状态是成功，则来源链跨链网关调用来源链业务合约注册的回调函数进行回调；如果跨链事务状态为失败，则来源链跨链网关将调用来源链业务合约注册的回滚函数进行回滚操作。 一对多跨链 一对多跨链是指，在一个来源链的业务合约的交易中，抛出了多个指向不同目的链的跨链事件。 一对多跨链和一对一跨链的整体流程一样，只是其中事务分为全局事务和子事务的概念： 子事务：指来源链和某个目的链的跨链事务 全局事务：综合各个子事务的整体事务 因此在中继链的跨链事务合约中，为一对多跨链事务特别设计了一个事务信息结构来支持该场景下的跨链事务状态记录和更新。该结构如下： type txInfo struct { // 全局事务状态 globalState string // 子事务信息，key为子事务ID，即各目的链的地址，value为子事务状态 childTxInfo map < string , string > } 其中，全局事务状态和子事务初始状态为BEGIN。之后，各目的链的跨链网关获取跨链交易并提交给各目的链执行，目的链执行完子事务后由跨链网关根据执行结果向中继链反馈子事务状态，中继链事务管理合约将进行相应的更新： 如果交易执行成功，则将对应的子事务状态设置为SUCCESS，当所有子事务状态均为SUCCESS时，跨链事务管理合约将该全局事务ID对应的事务状态更新为SUCCESS 如果交易执行失败，则将对应的子事务状态设置为FAILURE，并将该全局事务ID对应的事务状态更新为FAILURE， 之后，各个应用链（包含来源链和目的链）的跨链网关可以获取中继链的全局事务和子事务的状态， 来对应用链进行业务上的“回调”操作或“回滚”操作。 跨链事务合约设计 中继链上的跨链事务管理合约接口设计如下： // 一对一跨链事务初始化 Begin ( txId string ) // 一对多跨链事务初始化 BeginMultiTXs ( globalId string , childTxIds ... string ) // 报告事务执行结果 Report ( txId string , result int32 ) // 获取事务状态 GetStatus ( txId string )","text_tokens":["目的","index","transactionstatus","各","信息","到","包含","上","事务管理","为","一对","id","流程","为此","begin","；","}","合约","处理","通过","如果","事件","管理机制","一样","场景","设计","(","反馈","failure","来","完跨","kv","所有","给","receipt","保证","中继","失败","_","...","type","目标","中要","：","性","是","指","成功","一致","）","并","获取","针对","将","即","因此","操作","结构","”","否则","综合","“","在","struct","多链","方案","中以","globalid","回执","链上","初始状态","资产","结果","外","捕获","成","回滚","/","一对一","状态","。","后","的","要么","value","交换","提交","交易","一致性","<","则","不同","对应","为子","事务","参数","特别","类",",","一个","接口",">","支持","机制","相应","链","除了","概念","调用","原子","内置","消息","某个","txinfo",")","进行","如下","根据","都","由","map","提供","封装","int32","子","childtxids","发起","*","或","report","表","beginmultitxs","result","中","全局","getstatus","下","多个","非","回调","指向","设置","注册","其中","更新","和子","事务性","信息结构","均","完子","对","ibtp","txid","各个","抛出","string"," ","函数","它","报告","可以","记录","和","跨链","|","还","之后","组成","执行","初始","时","需要","整体","childtxinfo","只是","当","形式","success","globalstate","key","方法","最终","多","分为","，","网关","（","得到","向","地址","来源","了","管理","初始化","应用","交易所","业务","该","{"],"title":"跨链事务方案","title_tokens":["跨链","方案","事务"]},{"location":"bitxhub/design/interchain_transaction/#_1","text":"跨链需要保证跨链交易的原子性和一致性，即来源链和目的链上的交易要么都成功，要么都失败回滚。 为此，中继链提供了事务管理机制，通过内置的事务管理合约，来保证不同业务场景下跨链交易的事务性。 多链消息表事务方案是针对非资产交换类业务场景的事务方案，它可以支持一对一跨链和一对多跨链。","text_tokens":["针对","目的","即","类","事务性","机制","支持","链","事务管理","一对"," ","多链","为此","方案","它","原子","内置","合约","消息","可以","和","跨链","通过","链上","管理机制","资产","非","回滚","场景","一对一","需要","来","。","都","保证","的","要么","中继","提供","交换","交易","失败","多","一致性","，","不同","表","事务","性","一致","是","来源","了","管理","下","成功","业务"],"title":"跨链事务方案","title_tokens":["跨链","方案","事务"]},{"location":"bitxhub/design/interchain_transaction/#_2","text":"当来源链业务合约发起跨链交易时，除了提供目的链的目标业务合约中要调用的方法和参数外，还可以提供来源链的回调方法和回滚方法。 来源链跨链网关捕获跨链事件封装成IBTP提交到中继链，并由中继链跨链事务合约进行处理。跨链事务合约将初始化该跨链交易所对应的跨链事务， 在跨链事务合约中以KV形式记录跨链事务ID和事务状态信息，其中跨链事务ID由**来源链ID || 目的链ID || IBTP index**组成，初始的跨链状态信息为TransactionStatus_BEGIN。 当目的链执行完跨链交易时，由目的链跨链网关得到执行的结果（成功或失败），并将该信息封装成IBTP receipt提交给中继链。 中继链跨链事务合约根据其中的回执信息，更新跨链事务ID的状态，如果成功，则状态更新为TransactionStatus_SUCCESS，否则为TransactionStatus_FAILURE。 如果跨链事务最终状态是成功，则来源链跨链网关调用来源链业务合约注册的回调函数进行回调；如果跨链事务状态为失败，则来源链跨链网关将调用来源链业务合约注册的回滚函数进行回滚操作。","text_tokens":["目的","index","transactionstatus","信息","到","为","id","begin","；","合约","处理","如果","事件","failure","完跨","kv","给","receipt","中继","失败","_","目标","中要","是","成功","）","并","将","操作","否则","在","中以","回执","结果","外","捕获","成","回滚","状态","。","的","提交","交易","则","对应","事务","参数","链","除了","调用","进行","根据","由","提供","封装","或","发起","*","回调","注册","其中","更新","ibtp"," ","函数","可以","记录","和","跨链","|","还","组成","执行","初始","时","当","形式","success","方法","最终","，","网关","（","得到","来源","初始化","交易所","业务","该"],"title":"一对一跨链","title_tokens":["一对一","跨链","一对"]},{"location":"bitxhub/design/interchain_transaction/#_3","text":"一对多跨链是指，在一个来源链的业务合约的交易中，抛出了多个指向不同目的链的跨链事件。 一对多跨链和一对一跨链的整体流程一样，只是其中事务分为全局事务和子事务的概念： 子事务：指来源链和某个目的链的跨链事务 全局事务：综合各个子事务的整体事务 因此在中继链的跨链事务合约中，为一对多跨链事务特别设计了一个事务信息结构来支持该场景下的跨链事务状态记录和更新。该结构如下： type txInfo struct { // 全局事务状态 globalState string // 子事务信息，key为子事务ID，即各目的链的地址，value为子事务状态 childTxInfo map < string , string > } 其中，全局事务状态和子事务初始状态为BEGIN。之后，各目的链的跨链网关获取跨链交易并提交给各目的链执行，目的链执行完子事务后由跨链网关根据执行结果向中继链反馈子事务状态，中继链事务管理合约将进行相应的更新： 如果交易执行成功，则将对应的子事务状态设置为SUCCESS，当所有子事务状态均为SUCCESS时，跨链事务管理合约将该全局事务ID对应的事务状态更新为SUCCESS 如果交易执行失败，则将对应的子事务状态设置为FAILURE，并将该全局事务ID对应的事务状态更新为FAILURE， 之后，各个应用链（包含来源链和目的链）的跨链网关可以获取中继链的全局事务和子事务的状态， 来对应用链进行业务上的“回调”操作或“回滚”操作。","text_tokens":["目的","各","信息","包含","上","事务管理","为","一对","id","流程","begin","}","合约","如果","事件","一样","场景","设计","反馈","failure","来","所有","给","中继","失败","type","：","是","指","成功","）","获取","并","将","因此","结构","即","操作","”","综合","“","在","struct","初始状态","结果","/","回滚","一对一","状态","。","后","的","value","提交","交易","<","则","不同","为子","对应","事务","特别",",","一个",">","支持","相应","链","概念","某个","txinfo","进行","如下","根据","由","map","子","或","中","全局","下","多个","回调","指向","设置","其中","更新","和子","信息结构","均","完子","对","各个","抛出","string"," ","记录","可以","和","跨链","之后","执行","初始","时","整体","childtxinfo","只是","globalstate","success","当","key","多","分为","，","网关","（","向","地址","来源","了","管理","应用","业务","该","{"],"title":"一对多跨链","title_tokens":["跨链","一对","多"]},{"location":"bitxhub/design/interchain_transaction/#_4","text":"中继链上的跨链事务管理合约接口设计如下： // 一对一跨链事务初始化 Begin ( txId string ) // 一对多跨链事务初始化 BeginMultiTXs ( globalId string , childTxIds ... string ) // 报告事务执行结果 Report ( txId string , result int32 ) // 获取事务状态 GetStatus ( txId string )","text_tokens":[",","接口","txid","事务管理","一对","string"," ","begin","globalid","合约","报告",")","跨链","链上","如下","结果","/","设计","一对一","(","执行","初始","状态","的","中继","多","int32","...","childtxids","report","result","事务","beginmultitxs","：","getstatus","管理","初始化","获取"],"title":"跨链事务合约设计","title_tokens":["设计","合约","跨链","事务"]},{"location":"bitxhub/design/pier/","text":"跨链网关设计方案 整体架构 在中继链的设计中，对于跨链网关的主要功能作了简要的介绍。本文主要详细介绍跨链网关的主要设计架构思想。 从跨链网关的**功能**上来说，设计上需要解决的难点包括以下几点： 跨链网关需要对接不同架构的区块链，如何简化跨链网关接入不同区块链的跨链网关设计上需要考虑的问题。 跨链网关需要支持中继模式（直接和中继链连接）和直连模式（直接和其他的跨链网关进行连接），如何在不同模式间切换时设计上需要考虑的问题。 从总体架构来说，跨链网关根据不同的功能采取了模块划分的方式，主要的功能模块有Monitor，Executor，Exchanger ，Validate Engine，Appchain Manager，Network等。 处理流程 一次完整的跨链交易的处理过程如下： A．Monitor监听 跨链网关PA启动之后，Appchain A发起一笔跨链交易，Monitor模块监听到该跨链交易，跨链网关对于该跨链交易做出检查之后，保存相应的跨链交易。 B．Exchanger转发 Exchanger获取Monitor收到的跨链交易，作相应的检查后，进行转发。转发过程中，根据跨链交易的目的链ID以及连接的是中继链还是直连的其他跨链网关等信息，转发到正确的路由路径。 中继链模式 通过中继链的SDK，提交跨链交易到中继链的内置合约上，中继链记录并执行验证，转发等操作。 直连模式 通过P2P网络连接其他跨链网关，通过跨链交易的目的链ID来转发到相应的跨链网关。 C. Exchanger接受外部跨链交易 中继链模式 Exchanger 的子模块Lite和Syncer负责同步中继链的区块头和跨链交易的信息，对于验证通过的跨链交易，Exchanger进行转送到Executor中。 直连模式 Exchanger通过P2P网络收到对方跨链网关发送的跨链交易，并作出相应的验证操作。验证通过的跨链交易转送到Executor中。 Executor提交跨链交易到应用链上，并根据执行的结果，构造返回的回执类型的IBTP包，转送到Exchanger进行下一步的转发工作。 C．跨链交易在目的链执行之后，返回回执信息。 中继链模式 Exchanger 的子模块Lite和Syncer负责同步中继链的区块头和跨链交易的信息，对于验证通过的跨链交易和回执信息，Exchanger进行转送到Executor中。 直连模式 Exchanger通过P2P网络收到对方跨链网关发送的跨链交易，并作出相应的验证操作。验证通过的跨链交易或者回执转送到Executor中。 以上，就是一次完整的跨链交易的执行过程。 模块依赖关系 在中继链模式下 在直连模式下 错误场景处理 在我们的设计中，极端情况下，跨链网关可以在没有保存任何跨链相关的数据就能正确启动。当然这需要不断的恢复之前的数据，重启的网络通信代价比较大。为了减少网络传输的启动负担，我们在对于一些关键的跨链信息还是进行了数据库的保存操作。 Executor 开源版本错误分析 中继链清除数据 中继链清除数据之后： 如果A链的跨链网关不重启，再从其他链（如B链）发来交易B-1。Exchanger 模块必定是忽略这些交易的。这种情况下只需多发几条交易覆盖前面序号的跨链交易即可。 但是如果从该跨链网关发送新的跨链交易到中继链，中继链会有序号不对的报错。但是跨链网关对这部分还没有相应的错误处理机制。 如果A链的跨链网关重启 执行模块对比两边的最新序号，无法进行有效操作。因为已经有跨链交易写入应用链的账本了，再次执行的话可能会有潜在的风险（比如转账的操作） 合约清除数据 合约清除数据之后 如果跨链网关不重启，执行模块内存中还是正确的序号。 接受其他链的交易，执行模块会认为正常——但是提交到合约上时会有序号错误的出错情况，从而执行模块构造跨链交易失败的回执（来源链上可能会采取回滚操作）。后续的执行全部都会是这种失败的情况。 如果跨链网关重启 执行模块查询的最新序号为 0 ，“其他方”可能为5。该种情况会重新上链执行，但是发回的回执信息会**因为序号错乱被“其他方”拒绝**。（潜在风险是重新执行的结果和之前的不一致）但是覆盖完之前的序号之后，能够正常跨链。 Monitor 模块错误场景分析 中继链清除数据 中继链清除数据之后，分两种情况分析 如果跨链网关不重启，插件出现新的交易的话，Monitor 正常抛给其他模块，发送到中继链，会因为 IBTP的 Index 被拒绝执行。 按照现在的情况，会不断重试 如果跨链网关重启，中继链记录的 Index 值清零。Monitor 按照应用链记录的交易全部重发。如果目的链的记录没有清空的话，之前处理过的会被应用链拒绝，后续可以正常工作；如果目的链记录清空的话，会造成交易重复执行（看场景能不能接受重复执行） 合约清除数据 合约清空 Pier 不重启，新的交易过来的话，会被Monitor 模块拒绝（可能需要多发几笔无用交易覆盖），之后能够重新工作。 Pier 重启的话，Monitor 查询的交易为空，中继链却有记录，Monitor 没有有效的处理手段，必须有外部来推送新交易。 Exchanger 模块设计 在新的设计中，统一由Exchanger模块维护 Index 相关的信息，需要满足以下的几个功能点。 接受来自 Monitor模块的交易并校验index，校验成功后交与 Syncer 模块提交给中继链执行IBTP； 接受来自 Syncer 模块的交易并校验 index，校验成功交与Excuter模块提交给应用链执行IBTP； 然后处理IBTP回执。 对于丢失的IBTP交易，要求 Syncer 和 Monitor 提供按照 IBTP_ID 的查询方式； 对于丢失的IBTP回执，要求 Executor 提供按照 IBTP_ID 的查询方式； 错误处理 由于Exchanger作为中继链和应用链的模块中的转发模块，对Index的校验的要求非常高，要求一定要根据From按序进行。 中继链 -> 跨链网关 如果Exchanger模块收到了Sycner来的跨链交易，执行以下操作： 比较收到的IBTP的序号 Index1 和内存中维护的序号信息 Index2 ： Index1 = Index2 + 1，是正常处理的逻辑 Index1 < Index2 + 1 说明Agent重复提交了该IBTP，直接抛弃该IBTP即可。 Index1 > Index2 + 1 说明Sycner漏掉了某些IBTP没有发送，按照漏掉的 IBTP 的 IBTP_ID ，调用Agent的查询接口恢复漏掉的 IBTP 即可。 跨链网关 -> 中继链 如果Exchanger模块收到了从Monitor来的跨链交易，执行以下操作： 比较收到的IBTP的序号 Index1 和内存中维护的序号信息 Index2 ： Index1 = Index2 + 1，是正常处理的逻辑 Index1 < Index2 + 1 说明Monitor重复提交了该IBTP，直接抛弃该IBTP即可。 Index1 > Index2 + 1 说明Monitor漏掉了某些IBTP没有发送，按照漏掉的 IBTP 的 IBTP_ID ，调用Monitor的查询接口恢复漏掉的 IBTP 即可。 如果在恢复IBTP的过程中出错，则交由相应模块一直retry（不考虑中继链和应用链删除数据的情况）。 架构图 恢复机制 未提交的跨链交易 pier在宕机重启后，需要把应用链中未提交到中继链的跨链交易提交到中继链，那么需要进行以下步骤： 从Monitor模块获取应用链当前的跨链交易信息，合约中使用outterMeta保存 从Sync模块中获取已经提交到中继链的跨链交易信息，中继链中使用interchainMeta保存 遍历outterMeta和interchainMeta对比还没提交到中继链的跨链交易，然后调用Monitor模块获取相应的跨链交易并提交到中继链 未执行的跨链交易 在 pier 宕机重启之后，有三种类型的未执行交易： 从其他链发过来的跨链交易未执行 由于网关都是按照中继链高度顺序执行的，这部分不用特殊的恢复机制。重启之后 Syncer 从上次记录的高度重新执行。 已经执行的跨链交易，但是回执未发回去 通过 Executor 模块获取 InnerMeta，再从 Syncer 获取 SourceReceiptCounter 遍历 InnerMeta 和 SourceReceiptCounter 对比能够知道那些交易已经执行但是回执还没返回给中继链，并通过 Executor 模块去应用链获取IBTP 回执。 还未执行的Callback 交易（对应自己已经发出的带Callback的跨链交易） 由于跨链交易回执也是一种**跨链交易，中继链会打包在 InterchainWrapper中，跨链网关按照顺序来自然会执行到，不用额外的恢复机制。** Monitor 模块设计 Monitor不再维护index相关的信息，由Exchanger统一进行维护。需要满足一下的几个功能点： 通过插件监听区块链上的跨链交易 提供查询IBTP的接口（根据ibtp id） 提供查询应用链上跨链交易Meta信息的接口 接口设计 type Monitor interface { // Start starts the service of monitor Start () error // Stop stops the service of monitor Stop () error // listen on interchain ibtp from appchain ListenIBTP () <- chan * pb . IBTP // query historical ibtp by its id QueryIBTP ( id string ) ( * pb . IBTP , error ) // QueryOuterMeta queries latest index map of ibtps throwed on appchain QueryOuterMeta () map [ string ] uint64 } 错误处理 应用链监听出问题 查询IBTP可能出现以下错误： 输入的IBTP ID格式有误 index不存在（只要合约不动，就不会出现这个情况） 合约调用出错，比如合约地址不对，方法名出错等（重试，需要打log进行排查或者更换配置） 调用时网络出错（需要重试） 查询meta出错，需要retry 主备模块设计 在新的设计中，主备高可用将会成为一个单独的模块，并且在Pier的配置文件中移除主备节点编号的配置项，改为再主备节点启动时随机生成序号的方案。需要满足以下的几个功能点： 能够在启动时自主发现自己是主节点还是备用节点 备用节点能够在主节点宕机的情况下主动升级成为主节点，继续完成跨链请求 主备节点之间不会互相干扰，不会出现跨链交易的重复执行 接口设计 type HAMng interface { Start () error // 启动Pier的主从模式 Stop () error // 停止Pier的主从模式 IsMain () <- chan bool // 判断是主节点还是备用节点 } 错误处理 同时有两个主节点： 如果主备两个节点同时连接中继链的一个节点，同时有两个主节点的错误不会产生； 如果主备两个节点连接中继链的两个不同节点，有极低概率产生同时有两个主节点的错误。 解决方案 ：针对该问题，新的设计将会在中继链节点收到广播询问后查询本地的主节点列表通道，如果有通道请求将会返回已有主节点的回复，并且缓冲回复给Pier，让Pier的主备节点发起新一轮的竞争。 Executor模块设计 在新的设计中，Executor 不再维护 Index 相关的信息，只是作为单纯的执行器。需要满足以下的几个功能点。 接受来自 Exchanger 模块的交易，并提交到插件执行 对于执行的结果，构造出新的IBTP，发回给 Exchanger 模块 对于丢失的IBTP交易，提供按照 From + Index 的查询方式 重启之后查询应用了上最新的已执行的 Meta 信息 接口设计 type Executor interface { Start () error // 启动Executor模块 Stop () error // 停止Executor模块 // 执行IBTP并返回结果，如果没有执行结果，返回 nil ExecuteIBTP ( ibtp * pb . IBTP ) ( * pb . IBTP , error ) // 查询最新的链上已执行的 Meta 信息 QueryInterchainMeta () map [ string ] uint64 // 查询最新的链上已收到回调的 Meta 信息 QueryCallbackMeta () map [ string ] uint64 // 查询历史跨链交易的执行结果的回执 QueryIBTPReceipt ( from string , index uint64 , originalIBTP * pb . IBTP ) ( * pb . IBTP , error ) } 错误处理 执行模块相信执行传进来的IBTP是有序的，序号的维护由其他模块维护。现在该模块只需要提交交易上链即可。 提交交易到应用链 因为跨链网关提交交易到应用链也可能会有很多情况出现，不同场景下的处理方式不一致。 - 因为网络出错导致提交交易无法成功（其他类型需要重试的情况） 这种情况执行重试即可 （但是必须确定是网络错误） - 因为跨链交易参数设置出错 - 函数或者函数参数出错，或者ABI文件配置出错 这种情况下调用合约的专门的出错函数，使得该 Index 被消耗。 - 函数参数都正确，但是合约执行时目的合约不存在等错误 直接在合约记录该交易为失败，并返回，Index 被消耗。 - 提交上链成功，但是构造回执失败（Core打印错误） 由于回执IBTP是由插件进行构造的，所以跨链网关需要预设插件一定会构造回执返回出来。（跨链网关**需要对插件返回的东西进行检查，防止不必要的Panic**） Syncer 模块设计 Syncer 模块负责和中继链的交互，Exchanger 有任何从中继链获取信息的需求都是通过 Syncer 模块进行。Syncer 需要提供的功能： 监听中继链上的跨链交易，并推送跨链交易到 Exchanger 中 根据应用链 ID 查询中继链上的Meta信息 根据 IBTP ID 查询中继链上跨链交易 发送跨链交易到中继链上 向中继链查询资产交换类型跨链交易的多签信息 接口设计 结合现在 Exchanger 的设计，Syncer 需要提供以下的接口 type Syncer interface { // 启动Syncer模块 Start () error // 停止Syncer模块 Stop () error // 查询中继链上已收到的跨链交易的最新 Index 的Meta信息 QueryInterchainMeta () map [ string ] uint64 // 根据 IBTP 的 ID 查询中继链上的记录 QueryIBTP ( ibtpID string ) ( * pb . IBTP , error ) // 监听链上抛出的跨链交易 ListenIBTP () <- chan * pb . IBTP // 发送其他链的 IBTP 到应用链上执行。 SendIBTP ( ibtp * pb . IBTP ) error // 从中继链获取资产交换的多签信息 GetAssetExchangeSigns ( id string ) ([] byte , error ) // 从中继链集群获取IBTP的多签信息 GetIBTPSigns ( ibtp * pb . IBTP ) ([] byte , error ) // 从中继链获取已注册的应用链组 GetAppchains () ([] * rpcx . Appchain , error ) // 通过appchain id获取 interchain meta信息 GetInterchainById ( from string ) * pb . Interchain // 注册Union模式下的recover处理器 RegisterRecoverHandler ( RecoverUnionHandler ) error // 注册可拉取appchains信息的处理器 RegisterAppchainHandler ( handler AppchainHandler ) error } 恢复处理 Syncer 从中继链同步到的信息，可以暂时存放在本地的存储中。需要记录的信息是： 上次执行到最后一个区块高度 已经接收到的IBTP的信息 重启之后，有两种情况： 如果存储没有删除，查询到最后一个处理过的区块高度，从这个高度开始进行跨链交易的处理（可能会有部分跨链交易重复提交，但是没关系，Exchanger会忽略这些重复提交的交易） 如果存储被删除，Syncer 重第一个区块开始同步，并提交这些区块的所有交易（这里也会由 Exchanger 模块来忽略已经执行过的交易） 插件设计 概述 由于现在采用区块链服务的各种应用可能在使用多种不同架构的区块链，所以如果跨链平台想要获得对接各种区块链的跨链能力的话，必然使得适配异构区块链的部分过于复杂。 为了简化跨链网关对于不同架构的区块链的适配工作，我们将所有直接和应用链直接交互的部分抽象到Plugin中，Plugin为跨链网关提供必要的查询应用链状态、提交跨链交易到应用链等服务的接口，做到了对于应用链本身架构复杂性对于跨链网关是透明的。 Plugin模式的一大特点是将Pier与应用链的交互模块和Pier核心模块进行解耦，从而方便更多的应用链加入跨链系统中。Plugin作为一个和Pier相对独立的一个模块，是通过Pier运行时外部启动服务的方式进行使用。为了能实现与应用链的交互能力，Plugin需要根据不同区块链的机制具体实现特定的接口。接口需要满足以下几个功能： 监听相应区块链上的跨链事件并传递给Pier处理； 执行来自于其他区块链的跨链请求； 能够查询相应区块链上跨链交易相关的元数据。 能够查询执行跨链交易和跨链请求的历史数据 总的来说，采用Plugin机制的优势有如下两点： 方便更新，能够在不停止Pier的方式下更新Plugin； 方便适配不同的区块链，而不用改动Pier。 Plugin接口设计 为了减少Pier core和应用链之间的耦合，我们设计了Plugin的统一的接口，Plugin主要为Pier core提供向应用链的状态查询和资源调用的接口。具体的接口和说明如下： type Client interface { // 传递相应的信息进行初始化 Initialize ( configPath string , pierID string , extra [] byte ) error // 启动Plugin服务的接口 Start () error ​ // 停止Plugin服务的接口 Stop () error ​ // Plugin负责将区块链上产生的跨链事件转化为标准的IBTP格式，Pier通过GetIBTP接口获取跨链请求再进行处理 GetIBTP () chan * pb . IBTP ​ // Plugin 负责执行其他链过来的跨链请求，Pier调用SubmitIBTP提交收到的跨链请求。[][]byte 为执行跨链请求的结果。 SubmitIBTP ( * pb . IBTP ) ( * pb . SubmitIBTPResponse , error ) // GetOutMessage 负责在跨链合约中查询历史跨链请求。查询键值中to指定目的链，idx指定序号，查询结果为以Plugin负责的区块链作为来源链的跨链请求。 GetOutMessage ( to string , idx uint64 ) ( * pb . IBTP , error ) ​ // GetInMessage 负责在跨链合约中查询历史跨链请求。查询键值中from指定来源链，idx指定序号，查询结果为以Plugin负责的区块链作为目的链的跨链请求。 GetInMessage ( from string , idx uint64 ) ([][] byte , error ) ​ // GetInMeta 是获取跨链请求相关的Meta信息的接口。以Plugin负责的区块链为目的链的一系列跨链请求的序号信息。如果Plugin负责A链，则可能有多条链和A进行跨链，如B->A:3; C->A:5。返回的map中，key值为来源链ID，value对应该来源链已发送的最新的跨链请求的序号，如{B:3, C:5}。 GetInMeta () ( map [ string ] uint64 , error ) ​ // GetOutMeta 是获取跨链请求相关的Meta信息的接口。以Plugin负责的区块链为来源链的一系列跨链请求的序号信息。如果Plugin负责A链，则A可能和多条链进行跨链，如A->B:3; A->C:5。返回的map中，key值为目的链ID，value对应已发送到该目的链的最新跨链请求的序号，如{B:3, C:5}。 GetOutMeta () ( map [ string ] uint64 , error ) ​ // GetCallbackMeta 是获取跨链请求相关的Meta信息的接口。以Plugin负责的区块链为来源链的一系列跨链请求的序号信息。如果Plugin负责A链，则A可能和多条链进行跨链，如A->B:3; A->C:5；同时由于跨链请求中支持回调操作，即A->B->A为一次完整的跨链操作，我们需要记录回调请求的序号信息，如A->B->:2; A->C—>A:4。返回的map中，key值为目的链ID，value对应到该目的链最新的带回调跨链请求的序号，如{B:2, C:4}。（注意 CallbackMeta序号可能和outMeta是不一致的，这是由于由A发出的跨链请求部分是没有回调的） GetCallbackMeta () ( map [ string ] uint64 , error ) ​ // CommitCallback 执行完IBTP包之后进行一些回调操作。 CommitCallback ( ibtp * pb . IBTP ) error ​ // Name 描述Plugin负责的区块链的自定义名称，一般和业务相关，如司法链等。 Name () string ​ // Type 描述Plugin负责的区块链类型，比如Fabric Type () string } 设计说明 由于不同类型的区块链在架构上的不同，具体实现上述的接口必然有所不同，我们没发从代码层面仔细介绍，但是能够大概介绍一下Plugin的实现的思路。 在我们的设计中，跨链网关和Plugin之间涉及到跨链交易的接口都是通过IBTP来交互的，跨链网关不需要关心在应用链上跨链请求不同的数据格式，需要处理的都是IBTP Package。所以在实现Plugin上也需要围绕IBTP Package作出一定的适配。总的来说具体需要做到如下的几点： 监听应用区块链上的跨链事件，并传递给Pier core进行处理。这个一般可以通过订阅区块链的事件的功能来做到。需要注意的是，Plugin需要负责跨链事件到IBTP Package的转换。Plugin重要的特点之一就是屏蔽了底层应用链不同数据格式之间的复杂性，向Pier core提供了统一的IBTP Package的数据结构，这对于Pier core的处理来说更加便捷。 提供查询应用链跨链合约维护的跨链Meta信息接口。Pier本身是不保存跨链交易的状态信息的，需要长时间存储的跨链交易记录信息都应该在中继链和应用链上进行记录。所以Pier无论什么时候都应该可以从宕机等情况中恢复，恢复的过程也正需要这些接口进行查询。 提交其他链上来的跨链请求。这一步是监听本应用链跨链请求的逆操作，但是Plugin和Pier core在交互上都应该是IBTP格式的Package，所以这部分功能中，Plugin需要解开IBTP package，转化为应用链可以识别的数据结构，在提交到跨链合约上进行执行。同时对于跨链交易可能的执行出错，Plugin也应该提供一定的错误处理能力。对于执行的结果，也需要为Pier core 提供统一的Response数据结构。 跨链合约设计 按照IBTP结构的设计的话，BitxHub只负责记录应用链这个粒度的跨链交易的Index。但是在Pier调用应用链智能合约执行跨链交易时，有多个智能合约的情况下，很难维护一个应用链层面的Index。 所以我们考虑在各个应用链上维护两个不同的合约。一个合约负责对接跨链网关Pier，为跨链管理合约Broker；一个合约负责具体的业务场景，为业务合约。业务合约需要跨链时，要统一将跨链请求提交到Broker合约上，Broker统一和Pier进行交互。一个Broker合约可以负责对接多个业务合约。 Broker合约 Broker有三部分主要的内容需要维护：交易序号、历史交易、错误处理 交易序号 该合约有三个跨链交易的序号需要维护： // key值为目的链地址to,value为发往该链的最后index mapping ( address => uint64 ) outerMeta ; // key值为来源链地址from,value为从该链发过来的最后index map ( address => uint64 ) innerMeta ; // key值为目的链地址to,value为该链已经执行回调的最后index map ( address => uint64 ) callbackrMeta ; 上述的三个序号主要能够防止重放攻击和保证跨链网关提交交易的幂等性（某些场景下跨链网关能够放心的多次提交而不用担心重复上链）。 历史交易 历史数据又可以分为两个部分，一个是自身链上发起的跨链请求（发送到其他链上去）；一个是从其他链收到的跨链交易，执行完成后的记录。 // 目的链地址 + 交易序号作为序号，自身链上发起的跨链请求内容作为 value mapping ( address + uint64 => record ) outMessages ; // 来源链地址 + 交易序号作为序号，其他链发起的跨链交易执行结果作为 value mapping ( address + uint64 => result )) inMessages ; 通过在 Broker 合约上记录历史数据，可以让跨链网关在重启、交易丢失等情况下恢复。以上只是伪代码的描述，具体在不同区块链的智能合约上实现时会有不同的策略。 错误处理 由于Broker 上执行跨链交易要求交易序号严格递增。这导致在某些跨链交易因为参数错误等原因无法调用到跨链交易处理函数，序号无法消耗，从而后面所有的交易都被认为是无效的情况。 为了应对这种情况，我们在Broker 合约专门提供了错误处理函数。当某个跨链交易无法处理的时候，通过调用该函数可以消耗该跨链交易的序号，让后面的跨链交易能够正常进行。 // 用来消耗执行其他链发起的跨链交易出错时的序号 function interchainError ( address sourceChainID , uint64 index ) public returns ( bool ); // 用来消耗执行其他链返回的回调交易出错时的序号 function interchainConfirmError ( address sourceChainID , uint64 index ) public returns ( bool ); 大规模跨链 概述 现有的跨链网络分为**中继链+跨链网关**模式和**跨链网关直连**模式，如果要组成大规模混合跨链网络的万链互连系统，就需要跨链网关添加**分布式哈希表DHT**和**跨链交易路由**的功能。 跨链交易路由流程： 中继链A中应用链A‘抛出跨链事件，目的链是中继链B中的应用链B’。 应用链A‘的跨链网关收到跨链事件，发送IBTP给中继链A，中继链A验证跨链交易的有效性，验证成功后将该笔交易打包出块。 跨链网关A解析中继链A的区块，解析到IBTP的目的链不属于中继链A管理的应用链，随后跨链网关A根据DHT路由到目的中继链B的跨链网关B。 跨链网关B收到IBTP，将跨链交易发送到相应的中继链。 中继链B验证跨链交易的有效性，验证成功后将该笔交易打包出块。 应用链B‘的跨链网关同步中继链B的区块，收到中继链B‘路由的跨链交易，发送给应用链B’执行跨链交易。 详细设计 在大规模跨链网络中，网络拓扑图如下： 路由传输 每个跨链网关维护两个表，一个为**跨链网关路由表(PTable)**，记录应用链ID和应用链网络地址的关联关系，具体实现为DHT，如下表所示： AppID AppAddr 0xe6f8c9cf6e38bd506fae93b73ee5e80cc8f73667 /ip4/111.132.1.111/quic/5001/p2p/QmZZFk1Tj6p25ecz98SpyHxb6joDPxR3wVPptDwuc8fue1 0x8374bb1e41d4a4bb4ac465e74caa37d242825efc /ip4/171.132.1.131/quic/4002/p2p/QmNRgD6djYJERNpDpHqRn3mxjJ9SYiiGWzExNSy4sEmSNL 另一个本地缓存的**网关中继关联表(PBTable)**，记录应用链ID和中继链的关系。如下表所示： AppID BxhID 0xe6f8c9cf6e38bd506fae93b73ee5e80cc8f73667 bxhA 0xe1sdddcf6e38bdxxxae93b73ecscs0cc8f73112 bxhA 种子节点：**由每个接入到路由网络的跨链网关维护，如上图种子节点可以是PierA和PierB 。** Pier新增： Pier连接到中继链，中继链路由模块发生Add Pier动作后，将所属中继链管理的所有应用链信息广播给所属的Pier，Pier构造本地的**网关中继关联表**； Pier加入路由网络，连接种子节点，构造**跨链网关路由表**； 路由网络中其它Pier收到了广播的信息，更新本地的**跨链网关路由表；** 如果应用链方只是想加入该中继联盟的跨链网络，并不想加入整个大规模网络中，可以在应用链注册时添加字段用于判断是否支持大规模跨链。 Pier更新： 类似Pier新增。 Pier删除： Pier在加入路由网络后，长时间Ping_Pier无响应，**跨链网关路由表**会自动删除该Pier信息。 IBTP传输流程图： 跨链网关路由模块接口定义： type Router interface { // Start starts the router module Start () error // Stop Stop () error //Broadcast broadcasts the registered appchain ids to the union network Broadcast ( ids [] string ) error //Route sends ibtp to the union pier in target relay chain Route ( ibtp * pb . IBTP ) error //ExistAppchain returns if appchain id exit in route map ExistAppchain ( id string ) bool //AddAppchains adds appchains to route map and broadcast them to union network AddAppchains ( appchains [] * rpcx . Appchain ) error } DHT 分布式哈希表采用S/Kademlia，相较于Kademlia提高了安全性，能够抵御不同程度的日蚀攻击、女巫攻击。 libp2p提供了对应的DHT库： https://github.com/libp2p/go-libp2p-kad-dht IBTP验证 目的中继链验证来自跨链网关的IBTP是否真正在来源中继链验证成功并且执行上链，提供以下两种证明方式： 多重签名： 来源中继链产生的跨链交易需要来源中继链节点的多重签名，最少签名阈值为Quorum数量，跨链网关路由传递IBTP的时候把对应多重签名信息带上。 SPV证明：（需要同步全网中继链的区块头） 目的中继链通过跨链网关同步来源中继链的区块头，验证IBTP的跨链交易是否存在于来源链的区块内，验证成功即表示IBTP是有效的。","text_tokens":["带","主备","说明","querycallbackmeta","按序","关心","信息","上","为","不必要","一直","担心","不","未","比如","包","合约","处理","几点","通信","如果","queryoutermeta","进来","区块","以下几点","直连","场景","重试","取信","模块接口","原因","就是","设计方案","错乱","正","满足","中继","_","以","前面","传","被","需","解决方案","大概","所以","并","一般","打包","操作","spv","“","本地","很难","分析","严格","多次","exit","链中","log","回执","handler","解决","=","on","回滚","必定","现在","存储","新","项","。","停止","值中","ids","启动","回去","没发","架构","不同","风险","顺序","或者","有效","链为","已","开始","existappchain","新增","库",",","再","能够","接口","清空","throwed","回复","callbackmeta","完成","返回","抛弃","处理过程","returns","in","询问","发现","即可","两边","元","exchanger","已有","产生","女巫","去","broadcasts","更换","依赖","出","概述","自身","潜在","子","两个","简要","发起","概率","构图","程度","插件","采用","看",";","关系","中","core","https","kademlia","链路","运行","设置","减少","start","recover","逆","大规模","账本","com","删除","更","以及","多种","client","-","安全","对","发送给","之间","解开","外部","retry","不会","string","相对"," ","bitxhub","hamng","3","造成","更加","抽象","路由","qmnrgd6djyjernpdphqrn3mxjj9syiigwzexnsy4semsnl","和","做出","getassetexchangesigns","之后","清零","adds","完","关联","组成","执行","必然","必须","1.131","用于","数据格式","当","key","数据结构","有所不同","导致","0xe1sdddcf6e38bdxxxae93b73ecscs0cc8f73112","appchains","构造","index2","（","自己","单独","路由表","之一","libp2p","继续","为空","出错","管理","保存","有效性","宕机","业务","这种","index","broker","从而","这","abi","its","到","拒绝执行","sdk","[","executor","时会","来自","流程","理器","用来","plugin","那么","检查","getinterchainbyid","多种不同","‘","全部重","为主","再主备","分布","对接","其它","请求","清除","简化","dht","给","获取信息","异构","错误处理","无论","存放","保证","因为","写入","失败","historical","攻击","图","缓存","自主","主从","重","输入","：","可用","是","作为","非常","这里","appaddr","一致","成功","一笔","发送到",":","随机","commitcallback","只","kad","两点","送给","在","interchain","指定","0","ibtpid","签名","from","只要","加入","遍历","系统","类似","注意","定义","网络通信","一些","据库","inmessages","层面","后","的","与","作出","没有","链方","交易","传输","ismain","则","动","不用","对应","重复","为了","使用","一下","极端","解","query","而","name","种子","同时","两种","nil","stop","一个","panic",">","上述","response","机制","错误","移除","主","推送","实现","调用","rpcx","规模","无法","后面","171.132","内置","自动","initialize","+","本","集群","资源","设计说明","them","哈希","过程","参数设置","认为","手段","接入","包括","listenibtp","没关","由","发出","连接","当前","获得","三个","忽略","抛","outtermeta","头","最新","路径","特点","record","表","丢失","内容","特定","网络拓扑","回调","上去","转发","低","内存","github","广播","更新","负责","go","重新","自然","解析","拒绝","配置","抛出","outmeta","处理函数","交与","数据库","策略","带回","4002","记录","情况","还","那些","全网","queries","也","1.111","来说","难点","发回去","出现","方法","真正","p2p","这个","a","多","分为","问题","日蚀","新一轮","然后","转化","向","重启","地址","初始化","理过","竞争","1","再次","屏蔽","getoutmessage","重要","可能","发过来","过于","其他","id","响应","如","to","结合","事件","具体","{","几笔","relay","add","设计","总的来说","什么","0x8374bb1e41d4a4bb4ac465e74caa37d242825efc","来","这部分","queryibtp","queryinterchainmeta","转账","是否","名称","放心","几个","独立","作","另","类型","方","验证","不必","属于","链组","starts","签","’","没关系","统一","getinmeta","appid","error","备用","历史数据","段","address","）","获取","存在","但是","判断","针对","会","随后","public","即","0xe6f8c9cf6e38bd506fae93b73ee5e80cc8f73667","司法","”","转","混合","干扰","发生","三种","网络地址","对于","之前","sycner","111.132","需求","传递","方案","ibtps","描述","抵御","互连","callbackrmeta","链上","资产","这是","如上","getinmessage","/","监听","不断","关键","漏掉","mapping","状态","piera","chan","送到","syncer","递增","没","却","通道","value","the","getappchains","报错","无效","出块","长时间","布式","queryibtpreceipt","一大","编号","正确","module","应对","pier","后续","添加","getoutmeta","broadcast","第一个","interchainerror","of","介绍","appchain","已经","相较","必要","支持","相应","submitibtp","链","bool","思路","不能","逻辑","上图","调跨","lite","某个","开源",")","ip4","还是","高","序号","文件","union","agent","函数参数","订阅","联盟","从该","查询","network","分","出来","恢复","要求","提供","幂","byte","如何","数量","间","点","比较","自定义","发来","额外","result","等","function","全部","getibtp","功能","识别","pbtable","注册","b","一次","耦合","发回","monitor","收到","部分","要","值","以上","ibtp","发送","各个","5001","4","对方","route","带上","格式","多条","by","函数","相信","chain","and","接受","router","可以","知道","于","放","主要","idx","系列","latest","这部","底层","切换","采取","时","整体","需要","总体","—","index1","package","打印","pa","本文","manager","interchainwrapper","ptable","quorum","执行器","核心","打","按照","标准","很多","自定","覆盖","发过","每个","来源","应用","过来","表示","把","过","就","pierb","做到","目的","工作","拓扑","有序","复杂","模块","．","适配","缓冲","仔细","​","]","；","}","内","功能模块","一步","一定","通过","几条","sourcereceiptcounter","sendibtp","能力","东西","三","成为","流程图","思想","(","列表","所有","伪","sends","校验","应该","专门","一系列","完整","5","历史","模式","特殊","所示","type","详细","性","service","并且","整个","确定","改动","最少","将","结构","生成","高度","一系","qmzzfk1tj6p25ecz98spyhxb6jodpxr3wvpptdwuc8fue1","无","动作","围绕","不想","消耗","配置文件","节点","相关","addappchains","结果","有","pb","if","s","提高","交由","stops","是从","所属","互相","考虑","executeibtp","该种","交换","提交","一种","分布式","<","处理器","想要","outmessages","getcallbackmeta","上来","优势","registerappchainhandler","智能","透明","参数","interchainmeta","不再","各种","bxha","从","该笔","c","现有","想","将会","便捷","validate","名","升级成","如上图","单纯","发","可拉取","涉及","又","excuter","方式","网络连接","对比","registerrecoverhandler","fabric","sync","进行","一轮","callback","如下","listen","防止",".","根据","能","极","engine","方便","预设","meta","大规","pierid","第一","接收","都","innermeta","这些","粒度","有误","的话","map","代价","任何","*","interface","暂时","当然","平台","复杂性","submitibtpresponse","发往","configpath","多重","2","下","上次","outermeta","时间","多个","证明","耦","让","链是","字","改为","代码","划分","交互","直接","使得","bxhid","originalibtp","registered","排查","安全性","主动","最后","ping","interchainconfirmerror","正常","出新","跨链","大","无用","网络","由于","某些","升级","recoverunionhandler","、","值为","多发","阈值","发现自己","sourcechainid","初始","我们","步骤","只是","负担","转换","架构图","uint64","extra","appchainhandler","同步","版本","本身","查询键","时候","，","网关","quic","维护","服务","万链","target","了","getibtpsigns","有所","该","以下","链会","数据"],"title":"跨链网关设计方案","title_tokens":["设计","方案","网关","设计方案","跨链"]},{"location":"bitxhub/design/pier/#_1","text":"","text_tokens":[],"title":"跨链网关设计方案","title_tokens":["设计","方案","网关","设计方案","跨链"]},{"location":"bitxhub/design/pier/#_2","text":"在中继链的设计中，对于跨链网关的主要功能作了简要的介绍。本文主要详细介绍跨链网关的主要设计架构思想。 从跨链网关的**功能**上来说，设计上需要解决的难点包括以下几点： 跨链网关需要对接不同架构的区块链，如何简化跨链网关接入不同区块链的跨链网关设计上需要考虑的问题。 跨链网关需要支持中继模式（直接和中继链连接）和直连模式（直接和其他的跨链网关进行连接），如何在不同模式间切换时设计上需要考虑的问题。 从总体架构来说，跨链网关根据不同的功能采取了模块划分的方式，主要的功能模块有Monitor，Executor，Exchanger ，Validate Engine，Appchain Manager，Network等。","text_tokens":["介绍","appchain","模块","monitor","validate","划分","支持","直接","上","链","在","对于","其他"," ","executor","方式","engine","几点","功能模块","以下","和","跨链","进行","主要","解决","区块","根据","以下几点","直连","思想","设计","有","exchanger","切换","对接","接入","需要","来说","难点","包括","。","简化","时","总体","network","连接","考虑","的","本文","中继","manager","如何","作","间","模式","问题","架构","简要","，","*","不同","网关","（","中","：","详细","等","了","）","功能","从","采取"],"title":"整体架构","title_tokens":["架构","整体"]},{"location":"bitxhub/design/pier/#_3","text":"一次完整的跨链交易的处理过程如下： A．Monitor监听 跨链网关PA启动之后，Appchain A发起一笔跨链交易，Monitor模块监听到该跨链交易，跨链网关对于该跨链交易做出检查之后，保存相应的跨链交易。 B．Exchanger转发 Exchanger获取Monitor收到的跨链交易，作相应的检查后，进行转发。转发过程中，根据跨链交易的目的链ID以及连接的是中继链还是直连的其他跨链网关等信息，转发到正确的路由路径。 中继链模式 通过中继链的SDK，提交跨链交易到中继链的内置合约上，中继链记录并执行验证，转发等操作。 直连模式 通过P2P网络连接其他跨链网关，通过跨链交易的目的链ID来转发到相应的跨链网关。 C. Exchanger接受外部跨链交易 中继链模式 Exchanger 的子模块Lite和Syncer负责同步中继链的区块头和跨链交易的信息，对于验证通过的跨链交易，Exchanger进行转送到Executor中。 直连模式 Exchanger通过P2P网络收到对方跨链网关发送的跨链交易，并作出相应的验证操作。验证通过的跨链交易转送到Executor中。 Executor提交跨链交易到应用链上，并根据执行的结果，构造返回的回执类型的IBTP包，转送到Exchanger进行下一步的转发工作。 C．跨链交易在目的链执行之后，返回回执信息。 中继链模式 Exchanger 的子模块Lite和Syncer负责同步中继链的区块头和跨链交易的信息，对于验证通过的跨链交易和回执信息，Exchanger进行转送到Executor中。 直连模式 Exchanger通过P2P网络收到对方跨链网关发送的跨链交易，并作出相应的验证操作。验证通过的跨链交易或者回执转送到Executor中。 以上，就是一次完整的跨链交易的执行过程。","text_tokens":["目的","工作","模块","信息","到","上","．","sdk","其他","id","executor","包","合约","处理","检查","一步","通过","区块","直连","就是","来","中继","完整","作","模式","类型","验证","：","是","并","获取","一笔","操作","转","在","对于","回执","链上","结果","监听","送到","。","syncer","后","的","启动","作出","提交","交易","或者","正确","c","appchain","相应","链","返回","处理过程","网络连接","内置","lite","进行","如下","还是","过程","exchanger","根据",".","连接","头","子","发起","路径","中","等","下","转发","b","一次","monitor","收到","以及","负责","以上","ibtp","发送","外部","对方"," ","接受","路由","记录","和","跨链","做出","网络","之后","执行","pa","p2p","a","同步","构造","，","网关","应用","保存","理过","该"],"title":"处理流程","title_tokens":["处理","流程"]},{"location":"bitxhub/design/pier/#_4","text":"","text_tokens":[],"title":"模块依赖关系","title_tokens":["关系","模块","依赖"]},{"location":"bitxhub/design/pier/#_5","text":"","text_tokens":[],"title":"在中继链模式下","title_tokens":["模式","下","链","在","中继"]},{"location":"bitxhub/design/pier/#_6","text":"","text_tokens":[],"title":"在直连模式下","title_tokens":["模式","下","直连","在"]},{"location":"bitxhub/design/pier/#_7","text":"在我们的设计中，极端情况下，跨链网关可以在没有保存任何跨链相关的数据就能正确启动。当然这需要不断的恢复之前的数据，重启的网络通信代价比较大。为了减少网络传输的启动负担，我们在对于一些关键的跨链信息还是进行了数据库的保存操作。","text_tokens":["减少","这","操作","信息","在","对于","之前","数据库","可以","通信","情况","跨链","相关","大","网络","还是","进行","能","设计","不断","关键","网络通信","一些","需要","我们","据库","。","负担","恢复","的","没有","启动","代价","任何","传输","比较","，","当然","网关","为了","中","重启","极端","下","保存","正确","了","就","数据"],"title":"错误场景处理","title_tokens":["处理","错误","场景"]},{"location":"bitxhub/design/pier/#executor","text":"中继链清除数据 中继链清除数据之后： 如果A链的跨链网关不重启，再从其他链（如B链）发来交易B-1。Exchanger 模块必定是忽略这些交易的。这种情况下只需多发几条交易覆盖前面序号的跨链交易即可。 但是如果从该跨链网关发送新的跨链交易到中继链，中继链会有序号不对的报错。但是跨链网关对这部分还没有相应的错误处理机制。 如果A链的跨链网关重启 执行模块对比两边的最新序号，无法进行有效操作。因为已经有跨链交易写入应用链的账本了，再次执行的话可能会有潜在的风险（比如转账的操作） 合约清除数据 合约清除数据之后 如果跨链网关不重启，执行模块内存中还是正确的序号。 接受其他链的交易，执行模块会认为正常——但是提交到合约上时会有序号错误的出错情况，从而执行模块构造跨链交易失败的回执（来源链上可能会采取回滚操作）。后续的执行全部都会是这种失败的情况。 如果跨链网关重启 执行模块查询的最新序号为 0 ，“其他方”可能为5。该种情况会重新上链执行，但是发回的回执信息会**因为序号错乱被“其他方”拒绝**。（潜在风险是重新执行的结果和之前的不一致）但是覆盖完之前的序号之后，能够正常跨链。","text_tokens":["这种","再次","从而","可能","模块","信息","到","上","为","其他","时会","不","比如","如","合约","处理","如果","几条","清除","这部分","错乱","转账","错误处理","中继","因为","写入","失败","5","方","前面","：","被","是","需","一致","）","但是","会","操作","”","只","“","之前","0","回执","链上","结果","有","回滚","必定","新","。","的","没有","该种","提交","交易","报错","风险","有效","正确","后续","从","再","已经","能够","相应","机制","错误","链","无法","对比","两边","即可","进行","还是","序号","exchanger","认为","从该","查询","都","这些","忽略","的话","最新","潜在","*","发来","中","下","全部","内存","b","账本","发回","部分","重新","-","对","1","发送","拒绝"," ","接受","正常","情况","跨链","和","还","之后","完","多发","这部","执行","采取","—","a","构造","，","网关","（","覆盖","重启","来源","应用","了","出错","链会","数据"],"title":"Executor 开源版本错误分析","title_tokens":["executor","分析"," ","开源","错误","版本"]},{"location":"bitxhub/design/pier/#monitor","text":"中继链清除数据 中继链清除数据之后，分两种情况分析 如果跨链网关不重启，插件出现新的交易的话，Monitor 正常抛给其他模块，发送到中继链，会因为 IBTP的 Index 被拒绝执行。 按照现在的情况，会不断重试 如果跨链网关重启，中继链记录的 Index 值清零。Monitor 按照应用链记录的交易全部重发。如果目的链的记录没有清空的话，之前处理过的会被应用链拒绝，后续可以正常工作；如果目的链记录清空的话，会造成交易重复执行（看场景能不能接受重复执行） 合约清除数据 合约清空 Pier 不重启，新的交易过来的话，会被Monitor 模块拒绝（可能需要多发几笔无用交易覆盖），之后能够重新工作。 Pier 重启的话，Monitor 查询的交易为空，中继链却有记录，Monitor 没有有效的处理手段，必须有外部来推送新交易。","text_tokens":["index","目的","工作","可能","模块","拒绝执行","其他","不","；","合约","处理","如果","全部重","几笔","场景","重试","来","清除","给","中继","因为","被","）","发送到","会","之前","分析","有","不断","现在","新","送到","。","却","的","没有","交易","重复","有效","pier","后续","两种","能够","清空","链","发","推送","不能","能","手段","查询","分","的话","抛","插件","看","全部","monitor","重新","值","ibtp","发送","拒绝","外部"," ","造成","接受","正常","记录","可以","情况","跨链","无用","之后","清零","多发","执行","必须","需要","出现","，","网关","（","按照","覆盖","重启","为空","应用","过来","过","数据"],"title":"Monitor 模块错误场景分析","title_tokens":["分析"," ","模块","monitor","错误","场景"]},{"location":"bitxhub/design/pier/#exchanger","text":"在新的设计中，统一由Exchanger模块维护 Index 相关的信息，需要满足以下的几个功能点。 接受来自 Monitor模块的交易并校验index，校验成功后交与 Syncer 模块提交给中继链执行IBTP； 接受来自 Syncer 模块的交易并校验 index，校验成功交与Excuter模块提交给应用链执行IBTP； 然后处理IBTP回执。 对于丢失的IBTP交易，要求 Syncer 和 Monitor 提供按照 IBTP_ID 的查询方式； 对于丢失的IBTP回执，要求 Executor 提供按照 IBTP_ID 的查询方式； 错误处理 由于Exchanger作为中继链和应用链的模块中的转发模块，对Index的校验的要求非常高，要求一定要根据From按序进行。 中继链 -> 跨链网关 如果Exchanger模块收到了Sycner来的跨链交易，执行以下操作： 比较收到的IBTP的序号 Index1 和内存中维护的序号信息 Index2 ： Index1 = Index2 + 1，是正常处理的逻辑 Index1 < Index2 + 1 说明Agent重复提交了该IBTP，直接抛弃该IBTP即可。 Index1 > Index2 + 1 说明Sycner漏掉了某些IBTP没有发送，按照漏掉的 IBTP 的 IBTP_ID ，调用Agent的查询接口恢复漏掉的 IBTP 即可。 跨链网关 -> 中继链 如果Exchanger模块收到了从Monitor来的跨链交易，执行以下操作： 比较收到的IBTP的序号 Index1 和内存中维护的序号信息 Index2 ： Index1 = Index2 + 1，是正常处理的逻辑 Index1 < Index2 + 1 说明Monitor重复提交了该IBTP，直接抛弃该IBTP即可。 Index1 > Index2 + 1 说明Monitor漏掉了某些IBTP没有发送，按照漏掉的 IBTP 的 IBTP_ID ，调用Monitor的查询接口恢复漏掉的 IBTP 即可。 如果在恢复IBTP的过程中出错，则交由相应模块一直retry（不考虑中继链和应用链删除数据的情况）。","text_tokens":["index","说明","模块","按序","信息","一直","id","来自","executor","不","；","处理","一定","如果","设计","来","给","错误处理","满足","校验","几个","中继","_","统一","：","是","作为","非常","成功","）","并","操作","在","对于","sycner","from","相关","回执","=","交由","漏掉","新","。","syncer","后","考虑","的","没有","提交","交易","<","则","重复","从","接口",">","相应","错误","链","抛弃","逻辑","excuter","调用","方式","+","即可","进行","高","过程","序号","exchanger","根据","agent","查询","由","恢复","要求","提供","点","比较","中","丢失","功能","转发","内存","删除","monitor","要","收到","-","直接","对","ibtp","发送","retry"," ","交与","接受","正常","和","跨链","情况","某些","由于","执行","需要","index1","，","网关","index2","维护","按照","（","然后","应用","了","出错","该","以下","1","数据"],"title":"Exchanger 模块设计","title_tokens":["设计","exchanger","模块"," "]},{"location":"bitxhub/design/pier/#_8","text":"","text_tokens":[],"title":"架构图","title_tokens":["架构图","架构","构图"]},{"location":"bitxhub/design/pier/#_9","text":"","text_tokens":[],"title":"恢复机制","title_tokens":["机制","恢复"]},{"location":"bitxhub/design/pier/#_10","text":"pier在宕机重启后，需要把应用链中未提交到中继链的跨链交易提交到中继链，那么需要进行以下步骤： 从Monitor模块获取应用链当前的跨链交易信息，合约中使用outterMeta保存 从Sync模块中获取已经提交到中继链的跨链交易信息，中继链中使用interchainMeta保存 遍历outterMeta和interchainMeta对比还没提交到中继链的跨链交易，然后调用Monitor模块获取相应的跨链交易并提交到中继链","text_tokens":["pier","已经","模块","monitor","相应","信息","到","在","链"," ","调用","未","那么","链中","从","合约","对比","sync","并","进行","跨链","和","还","遍历","需要","步骤","没","当前","后","的","outtermeta","中继","提交","交易","，","：","中","使用","重启","然后","应用","保存","interchainmeta","宕机","把","获取","以下"],"title":"未提交的跨链交易","title_tokens":["未","跨链","的","提交","交易"]},{"location":"bitxhub/design/pier/#_11","text":"在 pier 宕机重启之后，有三种类型的未执行交易： 从其他链发过来的跨链交易未执行 由于网关都是按照中继链高度顺序执行的，这部分不用特殊的恢复机制。重启之后 Syncer 从上次记录的高度重新执行。 已经执行的跨链交易，但是回执未发回去 通过 Executor 模块获取 InnerMeta，再从 Syncer 获取 SourceReceiptCounter 遍历 InnerMeta 和 SourceReceiptCounter 对比能够知道那些交易已经执行但是回执还没返回给中继链，并通过 Executor 模块去应用链获取IBTP 回执。 还未执行的Callback 交易（对应自己已经发出的带Callback的跨链交易） 由于跨链交易回执也是一种**跨链交易，中继链会打包在 InterchainWrapper中，跨链网关按照顺序来自然会执行到，不用额外的恢复机制。**","text_tokens":["带","模块","发过来","到","其他","executor","未","通过","sourcereceiptcounter","来","这部分","给","中继","类型","特殊","：","是","）","并","获取","但是","会","打包","高度","三种","在","回执","遍历","有","。","syncer","没","的","交易","一种","回去","不用","对应","顺序","pier","从","已经","再","能够","机制","链","返回","对比","callback","去","都","innermeta","发出","恢复","*","额外","中","上次","发回","部分","重新","自然","ibtp"," ","记录","知道","和","跨链","还","之后","由于","那些","这部","执行","也","发回去","interchainwrapper","，","网关","（","按照","自己","发过","重启","应用","过来","宕机","链会"],"title":"未执行的跨链交易","title_tokens":["执行","未","的","跨链","交易"]},{"location":"bitxhub/design/pier/#monitor_1","text":"Monitor不再维护index相关的信息，由Exchanger统一进行维护。需要满足一下的几个功能点： 通过插件监听区块链上的跨链交易 提供查询IBTP的接口（根据ibtp id） 提供查询应用链上跨链交易Meta信息的接口","text_tokens":["index","接口","monitor","信息","ibtp"," ","id","进行","通过","相关","链上","跨链","exchanger","根据","区块","meta","监听","需要","查询","。","由","的","满足","几个","提供","交易","点","，","插件","（","维护","统一","：","一下","应用","不再","）","功能"],"title":"Monitor 模块设计","title_tokens":["设计","模块","monitor"," "]},{"location":"bitxhub/design/pier/#_12","text":"type Monitor interface { // Start starts the service of monitor Start () error // Stop stops the service of monitor Stop () error // listen on interchain ibtp from appchain ListenIBTP () <- chan * pb . IBTP // query historical ibtp by its id QueryIBTP ( id string ) ( * pb . IBTP , error ) // QueryOuterMeta queries latest index map of ibtps throwed on appchain QueryOuterMeta () map [ string ] uint64 }","text_tokens":["start","of","appchain","stop","index",",","monitor","its","throwed","-","ibtp","interchain","string"," ","[","id","by","]","ibtps","}",")","from","queryoutermeta","listen",".","pb","queries","on","/","latest","(","stops","listenibtp","chan","queryibtp","map","uint64","the","historical","<","type","*","interface","starts","service","error","query","{"],"title":"接口设计","title_tokens":["设计","接口"]},{"location":"bitxhub/design/pier/#_13","text":"应用链监听出问题 查询IBTP可能出现以下错误： 输入的IBTP ID格式有误 index不存在（只要合约不动，就不会出现这个情况） 合约调用出错，比如合约地址不对，方法名出错等（重试，需要打log进行排查或者更换配置） 调用时网络出错（需要重试） 查询meta出错，需要retry","text_tokens":["index","可能","名","错误","链","对","ibtp","配置","不会","retry","排查"," ","格式","id","调用","不","比如","合约","log","情况","进行","只要","网络","meta","监听","重试","时","查询","需要","更换","出现","有误","的","出","存在","方法","这个","问题","动","，","打","（","输入","：","或者","地址","等","应用","出错","）","就","以下"],"title":"错误处理","title_tokens":["错误处理","处理","错误"]},{"location":"bitxhub/design/pier/#_14","text":"在新的设计中，主备高可用将会成为一个单独的模块，并且在Pier的配置文件中移除主备节点编号的配置项，改为再主备节点启动时随机生成序号的方案。需要满足以下的几个功能点： 能够在启动时自主发现自己是主节点还是备用节点 备用节点能够在主节点宕机的情况下主动升级成为主节点，继续完成跨链请求 主备节点之间不会互相干扰，不会出现跨链交易的重复执行","text_tokens":["主备","改为","能够","一个","随机","将会","模块","生成","干扰","升级成","完成","在","之间","配置","不会","移除"," ","主","方案","主动","配置文件","节点","发现","情况","跨链","升级","高","还是","序号","文件","成为","为主","设计","再主备","发现自己","执行","时","需要","请求","新","项","。","互相","出现","的","满足","启动","几个","交易","点","，","自主","单独","自己","重复","中","：","可用","是","编号","宕机","备用","下","继续","并且","pier","功能","以下"],"title":"主备模块设计","title_tokens":["设计","主备","模块"]},{"location":"bitxhub/design/pier/#_15","text":"type HAMng interface { Start () error // 启动Pier的主从模式 Stop () error // 停止Pier的主从模式 IsMain () <- chan bool // 判断是主节点还是备用节点 }","text_tokens":["start","stop","-","bool"," ","主","hamng","}",")","节点","还是","/","(","chan","停止","的","启动","模式","ismain","type","<","interface","主从","是","error","备用","pier","{","判断"],"title":"接口设计","title_tokens":["设计","接口"]},{"location":"bitxhub/design/pier/#_16","text":"同时有两个主节点： 如果主备两个节点同时连接中继链的一个节点，同时有两个主节点的错误不会产生； 如果主备两个节点连接中继链的两个不同节点，有极低概率产生同时有两个主节点的错误。 解决方案 ：针对该问题，新的设计将会在中继链节点收到广播询问后查询本地的主节点列表通道，如果有通道请求将会返回已有主节点的回复，并且缓冲回复给Pier，让Pier的主备节点发起新一轮的竞争。","text_tokens":["针对","主备","广播","一个","将会","收到","回复","错误","链","在","不会","返回"," ","主","本地","缓冲","方案","；","让","询问","节点","如果","一轮","有","极","产生","解决","已有","设计","列表","查询","请求","新","。","给","连接","后","的","通道","中继","问题","两个","概率","，","发起","不同","新一轮","：","解决方案","并且","pier","竞争","该","同时","低"],"title":"错误处理","title_tokens":["错误处理","处理","错误"]},{"location":"bitxhub/design/pier/#executor_1","text":"在新的设计中，Executor 不再维护 Index 相关的信息，只是作为单纯的执行器。需要满足以下的几个功能点。 接受来自 Exchanger 模块的交易，并提交到插件执行 对于执行的结果，构造出新的IBTP，发回给 Exchanger 模块 对于丢失的IBTP交易，提供按照 From + Index 的查询方式 重启之后查询应用了上最新的已执行的 Meta 信息","text_tokens":["index","发回","模块","信息","到","上","在","对于","ibtp","单纯"," ","executor","来自","方式","接受","+","并","from","出新","相关","之后","结果","exchanger","设计","meta","执行","需要","查询","新","只是","。","给","的","满足","几个","提供","最新","提交","交易","构造","点","执行器","，","插件","维护","按照","中","丢失","重启","作为","应用","了","已","不再","功能","以下"],"title":"Executor模块设计","title_tokens":["设计","executor","模块"]},{"location":"bitxhub/design/pier/#_17","text":"type Executor interface { Start () error // 启动Executor模块 Stop () error // 停止Executor模块 // 执行IBTP并返回结果，如果没有执行结果，返回 nil ExecuteIBTP ( ibtp * pb . IBTP ) ( * pb . IBTP , error ) // 查询最新的链上已执行的 Meta 信息 QueryInterchainMeta () map [ string ] uint64 // 查询最新的链上已收到回调的 Meta 信息 QueryCallbackMeta () map [ string ] uint64 // 查询历史跨链交易的执行结果的回执 QueryIBTPReceipt ( from string , index uint64 , originalIBTP * pb . IBTP ) ( * pb . IBTP , error ) }","text_tokens":["nil","start","index","stop",",","模块","querycallbackmeta","收到","信息","上","链","ibtp","originalibtp","返回","["," ","string","executor","]","}",")","from","如果","跨链","回执","结果",".","pb","/","meta","(","执行","查询","queryinterchainmeta","停止","的","启动","没有","executeibtp","map","最新","uint64","历史","交易","type","，","interface","*","queryibtpreceipt","error","已","回调","并","{"],"title":"接口设计","title_tokens":["设计","接口"]},{"location":"bitxhub/design/pier/#_18","text":"执行模块相信执行传进来的IBTP是有序的，序号的维护由其他模块维护。现在该模块只需要提交交易上链即可。","text_tokens":["有序","模块","只","上","链","ibtp","其他","相信","即可","进来","序号","执行","现在","需要","。","由","的","提交","交易","，","维护","传","是","该"],"title":"错误处理","title_tokens":["错误处理","处理","错误"]},{"location":"bitxhub/design/pier/#_19","text":"因为跨链网关提交交易到应用链也可能会有很多情况出现，不同场景下的处理方式不一致。 - 因为网络出错导致提交交易无法成功（其他类型需要重试的情况） 这种情况执行重试即可 （但是必须确定是网络错误） - 因为跨链交易参数设置出错 - 函数或者函数参数出错，或者ABI文件配置出错 这种情况下调用合约的专门的出错函数，使得该 Index 被消耗。 - 函数参数都正确，但是合约执行时目的合约不存在等错误 直接在合约记录该交易为失败，并返回，Index 被消耗。 - 提交上链成功，但是构造回执失败（Core打印错误） 由于回执IBTP是由插件进行构造的，所以跨链网关需要预设插件一定会构造回执返回出来。（跨链网关**需要对插件返回的东西进行检查，防止不必要的Panic**）","text_tokens":["这种","index","目的","可能","abi","到","上","为","不必要","其他","不","合约","处理","检查","一定","东西","场景","重试","专门","因为","失败","类型","不必","被","是","所以","成功","一致","）","并","确定","存在","但是","会","在","消耗","回执","有","。","的","提交","交易","不同","或者","参数","正确","panic","必要","错误","链","返回","调用","方式","无法","即可","进行","防止","文件","参数设置","函数参数","预设","都","由","出来","*","插件","core","等","下","设置","-","使得","直接","对","ibtp","配置"," ","函数","记录","情况","跨链","网络","由于","执行","也","必须","需要","时","打印","出现","导致","构造","，","网关","（","很多","应用","出错","该"],"title":"提交交易到应用链","title_tokens":["应用","到","链","提交","交易"]},{"location":"bitxhub/design/pier/#syncer","text":"Syncer 模块负责和中继链的交互，Exchanger 有任何从中继链获取信息的需求都是通过 Syncer 模块进行。Syncer 需要提供的功能： 监听中继链上的跨链交易，并推送跨链交易到 Exchanger 中 根据应用链 ID 查询中继链上的Meta信息 根据 IBTP ID 查询中继链上跨链交易 发送跨链交易到中继链上 向中继链查询资产交换类型跨链交易的多签信息","text_tokens":["模块","负责","交互","信息","到","链","ibtp","发送"," ","需求","推送","id","并","和","通过","进行","链上","跨链","资产","有","exchanger","根据","meta","取信","监听","需要","查询","syncer","。","都","获取信息","的","中继","提供","功能","交换","交易","任何","多","类型","，","签","：","中","向","是","应用","获取","从"],"title":"Syncer 模块设计","title_tokens":["设计","syncer","模块"," "]},{"location":"bitxhub/design/pier/#_20","text":"结合现在 Exchanger 的设计，Syncer 需要提供以下的接口 type Syncer interface { // 启动Syncer模块 Start () error // 停止Syncer模块 Stop () error // 查询中继链上已收到的跨链交易的最新 Index 的Meta信息 QueryInterchainMeta () map [ string ] uint64 // 根据 IBTP 的 ID 查询中继链上的记录 QueryIBTP ( ibtpID string ) ( * pb . IBTP , error ) // 监听链上抛出的跨链交易 ListenIBTP () <- chan * pb . IBTP // 发送其他链的 IBTP 到应用链上执行。 SendIBTP ( ibtp * pb . IBTP ) error // 从中继链获取资产交换的多签信息 GetAssetExchangeSigns ( id string ) ([] byte , error ) // 从中继链集群获取IBTP的多签信息 GetIBTPSigns ( ibtp * pb . IBTP ) ([] byte , error ) // 从中继链获取已注册的应用链组 GetAppchains () ([] * rpcx . Appchain , error ) // 通过appchain id获取 interchain meta信息 GetInterchainById ( from string ) * pb . Interchain // 注册Union模式下的recover处理器 RegisterRecoverHandler ( RecoverUnionHandler ) error // 注册可拉取appchains信息的处理器 RegisterAppchainHandler ( handler AppchainHandler ) error }","text_tokens":["index","模块","信息","到","其他","[","id","理器","]","}","结合","处理","getinterchainbyid","通过","sendibtp","设计","(","queryinterchainmeta","queryibtp","中继","模式","type","链组","签","error","获取","interchain","ibtpid","from","链上","handler","资产","pb","/","监听","现在","chan","syncer","。","停止","的","启动","getappchains","交换","交易","<","处理器","registerappchainhandler","已","从","appchain","stop",",","接口","链","可拉取","rpcx","registerrecoverhandler",")","集群","exchanger","根据",".","union","meta","查询","listenibtp","map","提供","最新","byte","*","interface","下","start","注册","recover","收到","-","ibtp","发送","string","抛出"," ","记录","跨链","recoverunionhandler","getassetexchangesigns","执行","需要","uint64","appchains","多","appchainhandler","，","应用","getibtpsigns","以下","{"],"title":"接口设计","title_tokens":["设计","接口"]},{"location":"bitxhub/design/pier/#_21","text":"Syncer 从中继链同步到的信息，可以暂时存放在本地的存储中。需要记录的信息是： 上次执行到最后一个区块高度 已经接收到的IBTP的信息 重启之后，有两种情况： 如果存储没有删除，查询到最后一个处理过的区块高度，从这个高度开始进行跨链交易的处理（可能会有部分跨链交易重复提交，但是没关系，Exchanger会忽略这些重复提交的交易） 如果存储被删除，Syncer 重第一个区块开始同步，并提交这些区块的所有交易（这里也会由 Exchanger 模块来忽略已经执行过的交易）","text_tokens":["会","已经","一个","可能","删除","）","模块","部分","高度","信息","到","链","在","ibtp","但是"," ","本地","第一个","最后","处理","可以","记录","情况","如果","进行","跨链","之后","有","exchanger","区块","执行","也","存储","需要","查询","接收","没关","syncer","。","第一","所有","这些","由","来","的","存放","没有","忽略","中继","这个","提交","交易","同步","，","暂时","重复","（","重","关系","中","：","没关系","是","重启","被","上次","这里","过","并","从","开始","两种"],"title":"恢复处理","title_tokens":["处理","恢复"]},{"location":"bitxhub/design/pier/#_22","text":"","text_tokens":[],"title":"插件设计","title_tokens":["插件","设计"]},{"location":"bitxhub/design/pier/#_23","text":"由于现在采用区块链服务的各种应用可能在使用多种不同架构的区块链，所以如果跨链平台想要获得对接各种区块链的跨链能力的话，必然使得适配异构区块链的部分过于复杂。 为了简化跨链网关对于不同架构的区块链的适配工作，我们将所有直接和应用链直接交互的部分抽象到Plugin中，Plugin为跨链网关提供必要的查询应用链状态、提交跨链交易到应用链等服务的接口，做到了对于应用链本身架构复杂性对于跨链网关是透明的。 Plugin模式的一大特点是将Pier与应用链的交互模块和Pier核心模块进行解耦，从而方便更多的应用链加入跨链系统中。Plugin作为一个和Pier相对独立的一个模块，是通过Pier运行时外部启动服务的方式进行使用。为了能实现与应用链的交互能力，Plugin需要根据不同区块链的机制具体实现特定的接口。接口需要满足以下几个功能： 监听相应区块链上的跨链事件并传递给Pier处理； 执行来自于其他区块链的跨链请求； 能够查询相应区块链上跨链交易相关的元数据。 能够查询执行跨链交易和跨链请求的历史数据 总的来说，采用Plugin机制的优势有如下两点： 方便更新，能够在不停止Pier的方式下更新Plugin； 方便适配不同的区块链，而不用改动Pier。","text_tokens":["做到","工作","从而","可能","复杂","模块","到","过于","为","其他","适配","来自","不","plugin","；","处理","多种不同","如果","通过","事件","具体","能力","区块","总的来说","对接","所有","请求","简化","给","异构","满足","几个","独立","历史","模式","：","是","作为","历史数据","所以","并","改动","将","两点","在","对于","传递","加入","系统","链上","相关","有","监听","现在","状态","。","停止","的","与","启动","提交","交易","架构","想要","不用","不同","优势","为了","使用","一大","透明","解","各种","pier","而","能够","接口","一个","必要","机制","相应","链","实现","方式","进行","元","如下","能","根据","方便","查询","获得","的话","提供","平台","复杂性","采用","特点","中","等","特定","下","耦","功能","运行","更新","更","部分","多种","交互","使得","直接","外部","相对"," ","抽象","于","和","跨链","由于","、","执行","必然","时","需要","我们","来说","多","本身","，","核心","网关","服务","应用","了","以下","数据"],"title":"概述","title_tokens":["概述"]},{"location":"bitxhub/design/pier/#plugin","text":"为了减少Pier core和应用链之间的耦合，我们设计了Plugin的统一的接口，Plugin主要为Pier core提供向应用链的状态查询和资源调用的接口。具体的接口和说明如下： type Client interface { // 传递相应的信息进行初始化 Initialize ( configPath string , pierID string , extra [] byte ) error // 启动Plugin服务的接口 Start () error ​ // 停止Plugin服务的接口 Stop () error ​ // Plugin负责将区块链上产生的跨链事件转化为标准的IBTP格式，Pier通过GetIBTP接口获取跨链请求再进行处理 GetIBTP () chan * pb . IBTP ​ // Plugin 负责执行其他链过来的跨链请求，Pier调用SubmitIBTP提交收到的跨链请求。[][]byte 为执行跨链请求的结果。 SubmitIBTP ( * pb . IBTP ) ( * pb . SubmitIBTPResponse , error ) // GetOutMessage 负责在跨链合约中查询历史跨链请求。查询键值中to指定目的链，idx指定序号，查询结果为以Plugin负责的区块链作为来源链的跨链请求。 GetOutMessage ( to string , idx uint64 ) ( * pb . IBTP , error ) ​ // GetInMessage 负责在跨链合约中查询历史跨链请求。查询键值中from指定来源链，idx指定序号，查询结果为以Plugin负责的区块链作为目的链的跨链请求。 GetInMessage ( from string , idx uint64 ) ([][] byte , error ) ​ // GetInMeta 是获取跨链请求相关的Meta信息的接口。以Plugin负责的区块链为目的链的一系列跨链请求的序号信息。如果Plugin负责A链，则可能有多条链和A进行跨链，如B->A:3; C->A:5。返回的map中，key值为来源链ID，value对应该来源链已发送的最新的跨链请求的序号，如{B:3, C:5}。 GetInMeta () ( map [ string ] uint64 , error ) ​ // GetOutMeta 是获取跨链请求相关的Meta信息的接口。以Plugin负责的区块链为来源链的一系列跨链请求的序号信息。如果Plugin负责A链，则A可能和多条链进行跨链，如A->B:3; A->C:5。返回的map中，key值为目的链ID，value对应已发送到该目的链的最新跨链请求的序号，如{B:3, C:5}。 GetOutMeta () ( map [ string ] uint64 , error ) ​ // GetCallbackMeta 是获取跨链请求相关的Meta信息的接口。以Plugin负责的区块链为来源链的一系列跨链请求的序号信息。如果Plugin负责A链，则A可能和多条链进行跨链，如A->B:3; A->C:5；同时由于跨链请求中支持回调操作，即A->B->A为一次完整的跨链操作，我们需要记录回调请求的序号信息，如A->B->:2; A->C—>A:4。返回的map中，key值为目的链ID，value对应到该目的链最新的带回调跨链请求的序号，如{B:2, C:4}。（注意 CallbackMeta序号可能和outMeta是不一致的，这是由于由A发出的跨链请求部分是没有回调的） GetCallbackMeta () ( map [ string ] uint64 , error ) ​ // CommitCallback 执行完IBTP包之后进行一些回调操作。 CommitCallback ( ibtp * pb . IBTP ) error ​ // Name 描述Plugin负责的区块链的自定义名称，一般和业务相关，如司法链等。 Name () string ​ // Type 描述Plugin负责的区块链类型，比如Fabric Type () string }","text_tokens":["目的","getoutmessage","可能","说明","信息","到","为","其他","[","id","​","]","不","比如","plugin","如","to","合约","处理","}","；","包","通过","如果","事件","具体","区块","设计","(","请求","名称","应该","一系列","历史","以","5","完整","类型","type","统一","：","getinmeta","是","作为","error","一致","）","获取","发送到","一般","将",":","即","操作","司法","commitcallback","一系","在","指定","传递","描述","from","相关","链上","结果","有","这是","pb","注意","getinmessage","/","定义","一些","状态","chan","送到","。","停止","值中","的","启动","没有","value","提交","则","getcallbackmeta","对应","为了","链为","已","pier","getoutmeta","name","同时","c","stop",",","再","接口",">","submitibtp","相应","支持","callbackmeta","链","返回","调用","调跨","initialize","fabric",")","资源","进行","如下","序号",".","产生","meta","pierid","查询","由","发出","map","提供","byte","最新","自定义","*","interface","submitibtpresponse",";","configpath","中","core","等","2","getibtp","回调","减少","start","b","一次","耦合","负责","收到","部分","client","-","对","之间","ibtp","发送","4","string","outmeta"," ","格式","多条","3","带回","记录","和","跨链","值为","由于","主要","idx","系列","完","之后","执行","初始","需要","我们","—","key","uint64","extra","a","查询键","，","（","服务","标准","自定","转化","向","来源","应用","了","初始化","过来","业务","该","{"],"title":"Plugin接口设计","title_tokens":["plugin","接口","设计"]},{"location":"bitxhub/design/pier/#_24","text":"由于不同类型的区块链在架构上的不同，具体实现上述的接口必然有所不同，我们没发从代码层面仔细介绍，但是能够大概介绍一下Plugin的实现的思路。 在我们的设计中，跨链网关和Plugin之间涉及到跨链交易的接口都是通过IBTP来交互的，跨链网关不需要关心在应用链上跨链请求不同的数据格式，需要处理的都是IBTP Package。所以在实现Plugin上也需要围绕IBTP Package作出一定的适配。总的来说具体需要做到如下的几点： 监听应用区块链上的跨链事件，并传递给Pier core进行处理。这个一般可以通过订阅区块链的事件的功能来做到。需要注意的是，Plugin需要负责跨链事件到IBTP Package的转换。Plugin重要的特点之一就是屏蔽了底层应用链不同数据格式之间的复杂性，向Pier core提供了统一的IBTP Package的数据结构，这对于Pier core的处理来说更加便捷。 提供查询应用链跨链合约维护的跨链Meta信息接口。Pier本身是不保存跨链交易的状态信息的，需要长时间存储的跨链交易记录信息都应该在中继链和应用链上进行记录。所以Pier无论什么时候都应该可以从宕机等情况中恢复，恢复的过程也正需要这些接口进行查询。 提交其他链上来的跨链请求。这一步是监听本应用链跨链请求的逆操作，但是Plugin和Pier core在交互上都应该是IBTP格式的Package，所以这部分功能中，Plugin需要解开IBTP package，转化为应用链可以识别的数据结构，在提交到跨链合约上进行执行。同时对于跨链交易可能的执行出错，Plugin也应该提供一定的错误处理能力。对于执行的结果，也需要为Pier core 提供统一的Response数据结构。","text_tokens":["做到","这","屏蔽","重要","可能","复杂","关心","信息","上","到","为","其他","适配","仔细","不","plugin","合约","处理","几点","一定","一步","通过","事件","具体","能力","区块","设计","总的来说","什么","就是","来","请求","这部分","给","正","无论","错误处理","应该","中继","类型","：","统一","是","大概","所以","并","但是","一般","结构","操作","在","对于","围绕","传递","链上","结果","注意","监听","存储","状态","。","层面","的","作出","提交","交易","没发","架构","上来","不同","长时间","一下","pier","从","同时","介绍","能够","接口","上述","便捷","response","错误","链","思路","涉及","实现","本","进行","如下","过程","meta","订阅","查询","都","这些","恢复","提供","复杂性","特点","中","core","等","时间","功能","识别","逆","代码","负责","部分","交互","之间","ibtp","解开"," ","格式","更加","可以","记录","和","跨链","情况","由于","这部","底层","执行","也","必然","需要","我们","package","数据格式","来说","转换","有所不同","数据结构","这个","本身","时候","，","网关","维护","之一","转化","向","应用","了","保存","出错","宕机","有所","数据"],"title":"设计说明","title_tokens":["设计","说明","设计说明"]},{"location":"bitxhub/design/pier/#_25","text":"按照IBTP结构的设计的话，BitxHub只负责记录应用链这个粒度的跨链交易的Index。但是在Pier调用应用链智能合约执行跨链交易时，有多个智能合约的情况下，很难维护一个应用链层面的Index。 所以我们考虑在各个应用链上维护两个不同的合约。一个合约负责对接跨链网关Pier，为跨链管理合约Broker；一个合约负责具体的业务场景，为业务合约。业务合约需要跨链时，要统一将跨链请求提交到Broker合约上，Broker统一和Pier进行交互。一个Broker合约可以负责对接多个业务合约。","text_tokens":["index","broker","将","结构","一个","只","负责","要","交互","到","上","链","在","ibtp","各个","为","bitxhub"," ","调用","很难","；","合约","记录","可以","情况","跨链","和","链上","具体","进行","有","场景","设计","执行","对接","时","需要","我们","请求","。","层面","粒度","考虑","的","的话","这个","提交","交易","两个","，","不同","网关","按照","维护","统一","智能","应用","下","所以","多个","管理","pier","业务","但是"],"title":"跨链合约设计","title_tokens":["设计","合约","跨链"]},{"location":"bitxhub/design/pier/#broker","text":"Broker有三部分主要的内容需要维护：交易序号、历史交易、错误处理","text_tokens":["broker","需要","维护","主要","处理","：","部分","内容","错误处理","的","错误","序号","有","三","、","交易","历史"],"title":"Broker合约","title_tokens":["合约","broker"]},{"location":"bitxhub/design/pier/#_26","text":"该合约有三个跨链交易的序号需要维护： // key值为目的链地址to,value为发往该链的最后index mapping ( address => uint64 ) outerMeta ; // key值为来源链地址from,value为从该链发过来的最后index map ( address => uint64 ) innerMeta ; // key值为目的链地址to,value为该链已经执行回调的最后index map ( address => uint64 ) callbackrMeta ; 上述的三个序号主要能够防止重放攻击和保证跨链网关提交交易的幂等性（某些场景下跨链网关能够放心的多次提交而不用担心重复上链）。","text_tokens":["目的","index",",","已经","能够","上述",">","）","发过来","上","链","mapping","为"," ","担心","重复","最后","多次","to","合约",")","from","防止","跨链","callbackrmeta","和","某些","值为","序号","有","=","主要","放","/","场景","(","执行","需要","。","innermeta","key","保证","三个","的","map","value","uint64","幂","放心","提交","交易","攻击","不用",";","网关","维护","发往","重","：","发过","（","地址","等","性","来源","下","outermeta","过来","address","回调","而","该","从"],"title":"交易序号","title_tokens":["序号","交易"]},{"location":"bitxhub/design/pier/#_27","text":"历史数据又可以分为两个部分，一个是自身链上发起的跨链请求（发送到其他链上去）；一个是从其他链收到的跨链交易，执行完成后的记录。 // 目的链地址 + 交易序号作为序号，自身链上发起的跨链请求内容作为 value mapping ( address + uint64 => record ) outMessages ; // 来源链地址 + 交易序号作为序号，其他链发起的跨链交易执行结果作为 value mapping ( address + uint64 => result )) inMessages ; 通过在 Broker 合约上记录历史数据，可以让跨链网关在重启、交易丢失等情况下恢复。以上只是伪代码的描述，具体在不同区块链的智能合约上实现时会有不同的策略。","text_tokens":["目的","broker","上","其他","时会","；","合约","通过","具体","区块","(","请求","伪","历史","是","作为","历史数据","address","）","发送到","在","描述","链上","结果","有","=","/","是从","inmessages","送到","。","后","的","value","交易","outmessages","不同","智能","一个",">","完成","链","又","实现","+",")","序号","恢复","自身","两个","发起",";","result","record","内容","丢失","等","下","上去","让","代码","部分","收到","以上","mapping","发送"," ","策略","可以","记录","情况","跨链","、","执行","只是","uint64","分为","，","网关","（","地址","重启","来源","数据"],"title":"历史交易","title_tokens":["交易","历史"]},{"location":"bitxhub/design/pier/#_28","text":"由于Broker 上执行跨链交易要求交易序号严格递增。这导致在某些跨链交易因为参数错误等原因无法调用到跨链交易处理函数，序号无法消耗，从而后面所有的交易都被认为是无效的情况。 为了应对这种情况，我们在Broker 合约专门提供了错误处理函数。当某个跨链交易无法处理的时候，通过调用该函数可以消耗该跨链交易的序号，让后面的跨链交易能够正常进行。 // 用来消耗执行其他链发起的跨链交易出错时的序号 function interchainError ( address sourceChainID , uint64 index ) public returns ( bool ); // 用来消耗执行其他链返回的回调交易出错时的序号 function interchainConfirmError ( address sourceChainID , uint64 index ) public returns ( bool );","text_tokens":["这种","index","broker","从而","这","上","到","其他","用来","合约","处理","通过","(","原因","所有","专门","因为","被","是","address","public","在","严格","消耗","/","递增","。","的","交易","无效","为了","参数","应对","interchainerror",",","能够","错误","链","bool","返回","调用","无法","后面","returns","某个",")","进行","序号","认为","都","要求","提供","发起",";","等","function","回调","让","处理函数"," ","函数","interchainconfirmerror","正常","可以","情况","跨链","某些","由于","sourcechainid","执行","时","我们","当","导致","uint64","时候","，","了","出错","该"],"title":"错误处理","title_tokens":["错误处理","处理","错误"]},{"location":"bitxhub/design/pier/#_29","text":"","text_tokens":[],"title":"大规模跨链","title_tokens":["规模","跨链","大规模","大规"]},{"location":"bitxhub/design/pier/#_30","text":"现有的跨链网络分为**中继链+跨链网关**模式和**跨链网关直连**模式，如果要组成大规模混合跨链网络的万链互连系统，就需要跨链网关添加**分布式哈希表DHT**和**跨链交易路由**的功能。 跨链交易路由流程： 中继链A中应用链A‘抛出跨链事件，目的链是中继链B中的应用链B’。 应用链A‘的跨链网关收到跨链事件，发送IBTP给中继链A，中继链A验证跨链交易的有效性，验证成功后将该笔交易打包出块。 跨链网关A解析中继链A的区块，解析到IBTP的目的链不属于中继链A管理的应用链，随后跨链网关A根据DHT路由到目的中继链B的跨链网关B。 跨链网关B收到IBTP，将跨链交易发送到相应的中继链。 中继链B验证跨链交易的有效性，验证成功后将该笔交易打包出块。 应用链B‘的跨链网关同步中继链B的区块，收到中继链B‘路由的跨链交易，发送给应用链B’执行跨链交易。","text_tokens":["目的","到","流程","不","‘","如果","事件","区块","直连","分布","dht","给","中继","模式","验证","属于","’","：","成功","发送到","打包","将","随后","混合","送给","互连","系统","送到","。","后","的","交易","分布式","出块","布式","有效","添加","该笔","现有","相应","链","规模","+","哈希","根据","大规","*","表","中","链是","功能","b","大规模","要","收到","发送给","解析","ibtp","发送","抛出"," ","路由","和","跨链","网络","组成","执行","需要","a","同步","分为","，","网关","万链","有效性","应用","管理","就"],"title":"概述","title_tokens":["概述"]},{"location":"bitxhub/design/pier/#_31","text":"在大规模跨链网络中，网络拓扑图如下：","text_tokens":["规模","，","拓扑","大规模","中","图","网络拓扑","：","跨链","如下","在","网络","大规"],"title":"详细设计","title_tokens":["详细","设计"]},{"location":"bitxhub/design/pier/#_32","text":"每个跨链网关维护两个表，一个为**跨链网关路由表(PTable)**，记录应用链ID和应用链网络地址的关联关系，具体实现为DHT，如下表所示： AppID AppAddr 0xe6f8c9cf6e38bd506fae93b73ee5e80cc8f73667 /ip4/111.132.1.111/quic/5001/p2p/QmZZFk1Tj6p25ecz98SpyHxb6joDPxR3wVPptDwuc8fue1 0x8374bb1e41d4a4bb4ac465e74caa37d242825efc /ip4/171.132.1.131/quic/4002/p2p/QmNRgD6djYJERNpDpHqRn3mxjJ9SYiiGWzExNSy4sEmSNL 另一个本地缓存的**网关中继关联表(PBTable)**，记录应用链ID和中继链的关系。如下表所示： AppID BxhID 0xe6f8c9cf6e38bd506fae93b73ee5e80cc8f73667 bxhA 0xe1sdddcf6e38bdxxxae93b73ecscs0cc8f73112 bxhA 种子节点：**由每个接入到路由网络的跨链网关维护，如上图种子节点可以是PierA和PierB 。** Pier新增： Pier连接到中继链，中继链路由模块发生Add Pier动作后，将所属中继链管理的所有应用链信息广播给所属的Pier，Pier构造本地的**网关中继关联表**； Pier加入路由网络，连接种子节点，构造**跨链网关路由表**； 路由网络中其它Pier收到了广播的信息，更新本地的**跨链网关路由表；** 如果应用链方只是想加入该中继联盟的跨链网络，并不想加入整个大规模网络中，可以在应用链注册时添加字段用于判断是否支持大规模跨链。 Pier更新： 类似Pier新增。 Pier删除： Pier在加入路由网络后，长时间Ping_Pier无响应，**跨链网关路由表**会自动删除该Pier信息。 IBTP传输流程图： 跨链网关路由模块接口定义： type Router interface { // Start starts the router module Start () error // Stop Stop () error //Broadcast broadcasts the registered appchain ids to the union network Broadcast ( ids [] string ) error //Route sends ibtp to the union pier in target relay chain Route ( ibtp * pb . IBTP ) error //ExistAppchain returns if appchain id exit in route map ExistAppchain ( id string ) bool //AddAppchains adds appchains to route map and broadcast them to union network AddAppchains ( appchains [] * rpcx . Appchain ) error }","text_tokens":["模块","信息","到","为","[","id","流程","]","响应","；","to","}","如果","具体","{","relay","add","流程图","模块接口","(","0x8374bb1e41d4a4bb4ac465e74caa37d242825efc","所有","其它","dht","给","是否","sends","中继","_","另","所示","缓存","type","starts","：","appid","是","error","appaddr","整个","段","并","判断","会","0xe6f8c9cf6e38bd506fae93b73ee5e80cc8f73667","将","发生","qmzzfk1tj6p25ecz98spyhxb6jodpxr3wvpptdwuc8fue1","网络地址","在","无","动作","111.132","本地","不想","exit","节点","加入","类似","addappchains","如上","定义","pb","if","/","piera","所属","。","后","ids","的","the","链方","传输","长时间","module","bxha","pier","添加","broadcast","种子","existappchain","新增","appchain","stop","一个","想","接口","如上图","支持","链","bool","规模","实现","171.132","上图","rpcx","in","returns","自动","ip4",")","them","如下",".","union","大规","联盟","接入","broadcasts","由","network","连接","map","两个","*","interface","表","关系","中","时间","链路","字","pbtable","注册","start","广播","大规模","更新","删除","收到","bxhid","5001","ibtp","registered","string","route"," ","chain","and","ping","路由","router","4002","记录","qmnrgd6djyjernpdphqrn3mxjj9syiigwzexnsy4semsnl","和","跨链","可以","网络","adds","关联","1.111","1.131","时","用于","只是","0xe1sdddcf6e38bdxxxae93b73ecscs0cc8f73112","p2p","ptable","appchains","构造","，","网关","quic","维护","路由表","每个","地址","target","应用","管理","了","该","pierb"],"title":"路由传输","title_tokens":["路由","传输"]},{"location":"bitxhub/design/pier/#dht","text":"分布式哈希表采用S/Kademlia，相较于Kademlia提高了安全性，能够抵御不同程度的日蚀攻击、女巫攻击。 libp2p提供了对应的DHT库： https://github.com/libp2p/go-libp2p-kad-dht","text_tokens":["库","github",":","能够","com","相较","go","kad","-","安全"," ","安全性","于","抵御","哈希","、","女巫",".","提高","s","/","分布","dht","。","的","提供","分布式","攻击","，","程度","不同","对应","采用","布式","表","日蚀","libp2p","：","了","https","kademlia"],"title":"DHT","title_tokens":["dht"]},{"location":"bitxhub/design/pier/#ibtp","text":"目的中继链验证来自跨链网关的IBTP是否真正在来源中继链验证成功并且执行上链，提供以下两种证明方式： 多重签名： 来源中继链产生的跨链交易需要来源中继链节点的多重签名，最少签名阈值为Quorum数量，跨链网关路由传递IBTP的时候把对应多重签名信息带上。 SPV证明：（需要同步全网中继链的区块头） 目的中继链通过跨链网关同步来源中继链的区块头，验证IBTP的跨链交易是否存在于来源链的区块内，验证成功即表示IBTP是有效的。","text_tokens":["最少","目的","即","spv","信息","上","链","在","ibtp","为","带上"," ","来自","传递","方式","签名","路由","内","节点","于","通过","跨链","产生","全网","区块","阈值","执行","需要","。","是否","的","真正","存在","中继","提供","证明","quorum","头","交易","数量","同步","时候","验证","，","多重","对应","网关","（","：","有效","是","来源","并且","表示","成功","把","）","以下","两种"],"title":"IBTP验证","title_tokens":["ibtp","验证"]},{"location":"bitxhub/design/privacy_protection/","text":"隐私保护 前提 在跨链场景中，中继链需要记录不同的应用链的跨链请求，所有的跨链交易对于加入了中继链跨链系统的应用链来说都是可见的。这种情况下，如果应用链用户发起的跨链交易带有隐私数据，隐私数据非常容易泄露。 所以我们在中继链的设计中需要隐私保护相关的机制，并且能够保持比较高的灵活度。在跨链系统中，我们提出了两种可行的隐私保护机制。 隐私交易 跨链交易在提交到中继链的共识节点之后，会通过共识发送到所有的其他节点去，所以跨链交易对于整个中继链来说没有隐私性可言。而隐私交易这种机制下，收到跨链交易的节点并不会将跨链交易的内容直接进行共识，而是计算跨链交易的哈希值进行共识。跨链交易在共识完成之后，参与方的共识节点将完整的跨链交易直接发送到参与方负责的中继链节点。 这样不相关的节点就无法直接获取到跨链交易，能够保护用户的交易隐私信息。 端到端加密 另一种进行隐私保护的思路是在跨链交易提交之前，就对跨链交易进行加密操作。为了提升加解密的效率，采用对称加密和秘钥协商的机制来实现。具体的一次加密交易过程如下图： 要进行加密交易的双方需要在中继链上注册自己的私钥衍生的公钥，这样双方通过自己拥有的私钥和对方注册的公钥，能够计算出一个相同的对称加密的秘钥，用于提交跨链交易之前的加密和获取跨链交易之后的解密。这个秘钥只有公钥的话无法解出用于加密的对称秘钥，所以能够保证跨链交易的隐私性。","text_tokens":["这种","提升","前提","信息","到","带有","其他","隐私","用户","可言","不","如果","通过","具体","场景","设计","对称","请求","所有","来","计算","保证","泄露","中继","完整","另","提出","图","：","是","性","非常","所以","并且","共识","整个","并","发送到","获取","会","可行","将","衍生","非常容易","操作","在","对于","之前","加密","可见","参与方","常容","节点","加入","系统","相关","链上","容易","送到","。","的","没有","这样","提交","交易","一种","不同","双方","为了","相同","解","而","两种","能够","加解密","一个","效率","机制","完成","链","思路","实现","无法","保护","进行","哈希","如下","高","过程","去","都","端到","出","的话","解密","私钥","比较","发起","交易过程","采用","中","内容","下","协商","注册","而是","一次","参与","负责","收到","要","拥有","直接","值","对","发送","不会","对方"," ","公钥","只有","端","记录","情况","跨链","和","秘钥","之后","用于","需要","来说","我们","灵活","这个","度","，","自己","应用","了","保持","就","数据"],"title":"隐私保护方案","title_tokens":["保护","方案","隐私"]},{"location":"bitxhub/design/privacy_protection/#_1","text":"","text_tokens":[],"title":"隐私保护","title_tokens":["保护","隐私"]},{"location":"bitxhub/design/privacy_protection/#_2","text":"在跨链场景中，中继链需要记录不同的应用链的跨链请求，所有的跨链交易对于加入了中继链跨链系统的应用链来说都是可见的。这种情况下，如果应用链用户发起的跨链交易带有隐私数据，隐私数据非常容易泄露。 所以我们在中继链的设计中需要隐私保护相关的机制，并且能够保持比较高的灵活度。在跨链系统中，我们提出了两种可行的隐私保护机制。","text_tokens":["这种","可行","非常容易","能够","机制","两种","带有","在","链","对于","用户","可见","隐私"," ","保护","记录","常容","情况","跨链","加入","系统","如果","相关","高","场景","设计","容易","需要","请求","所有","来说","。","我们","都","灵活","泄露","的","中继","交易","度","提出","比较","，","发起","不同","中","是","非常","应用","了","下","所以","并且","保持","数据"],"title":"前提","title_tokens":["前提"]},{"location":"bitxhub/design/privacy_protection/#_3","text":"跨链交易在提交到中继链的共识节点之后，会通过共识发送到所有的其他节点去，所以跨链交易对于整个中继链来说没有隐私性可言。而隐私交易这种机制下，收到跨链交易的节点并不会将跨链交易的内容直接进行共识，而是计算跨链交易的哈希值进行共识。跨链交易在共识完成之后，参与方的共识节点将完整的跨链交易直接发送到参与方负责的中继链节点。 这样不相关的节点就无法直接获取到跨链交易，能够保护用户的交易隐私信息。","text_tokens":["会","这种","将","而是","能够","参与","负责","收到","机制","直接","值","到","完成","在","链","对于","发送","信息","不会","就","其他","隐私"," ","可言","用户","不","无法","保护","参与方","节点","并","通过","跨链","进行","哈希","相关","之后","去","所有","来说","送到","。","计算","获取","的","没有","中继","这样","提交","交易","完整","，","内容","性","下","所以","共识","整个","而","发送到"],"title":"隐私交易","title_tokens":["交易","隐私"]},{"location":"bitxhub/design/privacy_protection/#_4","text":"另一种进行隐私保护的思路是在跨链交易提交之前，就对跨链交易进行加密操作。为了提升加解密的效率，采用对称加密和秘钥协商的机制来实现。具体的一次加密交易过程如下图： 要进行加密交易的双方需要在中继链上注册自己的私钥衍生的公钥，这样双方通过自己拥有的私钥和对方注册的公钥，能够计算出一个相同的对称加密的秘钥，用于提交跨链交易之前的加密和获取跨链交易之后的解密。这个秘钥只有公钥的话无法解出用于加密的对称秘钥，所以能够保证跨链交易的隐私性。","text_tokens":["注册","一次","操作","加解密","衍生","能够","一个","提升","要","效率","机制","拥有","在","对","思路","之前","对方","加密","隐私"," ","实现","公钥","无法","保护","只有","进行","跨链","和","秘钥","具体","过程","如下","链上","通过","之后","对称","用于","需要","来","。","计算","获取","保证","的","出","的话","中继","这样","这个","解密","提交","交易","私钥","另","一种","图","，","交易过程","双方","采用","自己","为了","：","是","性","相同","解","所以","协商","就"],"title":"端到端加密","title_tokens":["端到","端","加密"]},{"location":"bitxhub/design/rate-limiter/","text":"API流控设计 实体定义 漏桶算法 漏桶算法的原理可以类比为往一个固定大小的桶里盛水，同时，水从桶底漏洞以固定速度流出，如果加水过快，则直接溢出，如下图所示。它可以应用于网络传输限流，计算机每发送一个数据包，如果桶内未满，则把数据包放入桶里，如果桶内已满，则丢弃数据包，与此同时，以固定速度从桶内取出数据包，发送到网络，从而达到**强行限制数据平均传输速率**的目的。 漏桶算法常用于将突发或不稳定流量整形为以固定速度在网络中传输的流量。 令牌桶算法 对于要求允许某种程度的突发传输，漏桶算法显然无法满足需求，而令牌桶可以做到这一点。令牌桶算法同样定义了一个固定大小的桶，桶里最多可容纳 b 个令牌，每当有数据包需要发送时，要从桶里取出对应数量的令牌才能发送，如果桶里没有足够令牌，则无法发送。与此同时，以固定速度 r 往桶里添加新令牌，当桶里令牌数已经达到 b 个时，丢弃新令牌。 令牌桶算法非常适合于针对系统外部请求的限流，当桶内有足够多令牌时，系统在某一时刻可以同时接收并处理多个请求，充分利用到系统资源。 总结来说，令牌桶限流允许突发流量，对于请求的限流、网络带宽限流，更能充分利用系统资源和网络资源，是适用于区块链底层平台系统流控的一种限流方法。 2.详细设计 区块链节点的入口流量大体分为两种： 一种为客户端发送过来的请求，请求可能为区块链数据查询、发送新交易、合约操作等（下文将简称为“客户端请求”）。节点接收到客户端请求后，首先需要从网络IO流中读取到请求的字节内容，然后反序列化字节内容为结构化内容，最后根据结构化请求体调用对应的API逻辑； 另一种为其他区块链节点发过来的网络消息，区块链系统底层是由多个共识节点组成的共识网络，节点间通过计算机网络进行信息传输（下文将简称为“节点间网络消息”）。节点接收到对端节点发送过来的网络消息后，根据消息类型，抛给对应的模块去处理。因此，不仅需要对客户端请求进行流量控制，防止大量突发外部请求都往同一个节点发送，耗尽目标节点资源导致目标节点服务瘫痪。还要对节点接收到的网络消息进行限流，防止节点在高负载下，前面的消息涉及的系统逻辑还未处理完，还源源不断地接收和缓存后面到来的消息，甚至导致节点内存溢出。 2.1 RPC流控 交易拦截器限流 限制请求速率：通过令牌桶限流算法控制请求速率，并限制节点最多可同时接收并处理的请求数。 节点高负载下拒绝新交易：当节点交易池已满或者处于异常、异常恢复状态无法进行正常共识时，拒绝来自客户端发送过来的新交易，避免交易参数检查、交易验签带来的CPU消耗。 令牌桶算法： https://github.com/juju/ratelimit GRPC提供Interceptor用于拦截请求： https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/ratelimit/ratelimit.go // Limiter defines the interface to perform request rate limiting. // If Limit function return true, the request will be rejected. // Otherwise, the request will pass. type Limiter interface { Limit () bool } // UnaryServerInterceptor returns a new unary server interceptors that performs request rate limiting. func UnaryServerInterceptor ( limiter Limiter ) grpc . UnaryServerInterceptor { return func ( ctx context . Context , req interface {}, info * grpc . UnaryServerInfo , handler grpc . UnaryHandler ) ( interface {}, error ) { if limiter . Limit () { return nil , status . Errorf ( codes . ResourceExhausted , \"%s is rejected by grpc_ratelimit middleware, please retry later.\" , info . FullMethod ) } return handler ( ctx , req ) } } // StreamServerInterceptor returns a new stream server interceptor that performs rate limiting on the request. func StreamServerInterceptor ( limiter Limiter ) grpc . StreamServerInterceptor { return func ( srv interface {}, stream grpc . ServerStream , info * grpc . StreamServerInfo , handler grpc . StreamHandler ) error { if limiter . Limit () { return status . Errorf ( codes . ResourceExhausted , \"%s is rejected by grpc_ratelimit middleware, please retry later.\" , info . FullMethod ) } return handler ( srv , stream ) } } 结合令牌桶和GRPC的interceptor实现对于API的流控： type Limitor struct { TokenBucket } // returns a new token bucket that fills at the rate of one token every fillInterval, // up to the given maximum capacity.Both arguments must be positive. // The bucket is initially full. func NewLimitor ( fillInterval time . Duration , capacity int64 ) * Limitor // allows the specification of the quantum size - quantum tokens are added every fillInterval. func NewLimitorWithQuantum ( fillInterval time . Duration , capacity , quantum int64 ) * Limitor func ( l * Limitor ) Limit () bool { return l . TakeAvailable () == 0 } 在bitxhub.toml添加相对应的配置 limitor: interval: 10ms quantum: 100 capacity: 10000 2.2 P2P流控 带权消息分发器限流 主要用来限制非关键模块的流量，防止带宽、CPU和内存都被非关键模块给占用。具体做法是为各个需要进行网络通信的模块分配带缓存空间的读（R）、写（W）管道，根据模块在系统中所占权重为其管道分配不同的缓存大小。 消息分发器收到一条来自底层P2P网络的网络消息，根据消息类型将消息分发给对应模块进行处理。这条消息首先分发给模块对应的 R 管道，模块再从 R 管道按照FIFO原则取出消息，执行相关逻辑，如果 R 管道消费速度慢于生产速度，导致分发消息时 R 管道已满，则说明模块内部已处于高负载，丢弃这条消息。为了保证达到系统限流目的，模块从 R 管道取出消息并处理消息的过程必须是串行的，而模块间的消息并行处理，互不干扰。 举个例子，当非关键模块处于高负载处理能力变慢时，其 R 管道虽然占满，但是不会影响共识模块消息的处理速度，同时又由于不同模块根据权重 R 管道大小不同，一定程度上防止节点一直处理非关键模块消息占用过多系统资源而导致共识模块消息无法得到及时处理。 带权消息分发一定程度上降低了各模块由于处理能力差异而相互干扰，提高系统网络消息并行处理能力，保证核心网络消息不被非核心网络消息占去全部系统资源，同时，系统高负载下自动丢弃新接收到的网络消息，防止系统负载过高而崩溃。","text_tokens":["带","10000","发给","处理速度","说明","rejected","performs","各","信息","上","满","为","一直","不","未","合约","处理","tokenbucket","如果","通信","streamserverinfo","区块","到来","反","生产","%","满足","limiter","new","以","_","io","数据包","前面","某","one","被","并","later","return","容纳","操作","读取","“","given","权重","负载","handler","=","on","序列化","新","positive","。","平均","漏洞","int64","可","不同","速度","或者","已","并行","充分利用","某种",",","再","拦截器","字节","能力差异","加水","returns","codes","已满","令牌","去","bucket","固定","举个","are","计算机","往","或","程度","及时处理","中","例子","https","ratelimit","interval","与此","com","结构化","10ms","-","对","条","外部","retry","相对","bitxhub","不会"," ","能力差","fills","源源","和","网络带宽","分发","完","限流","组成","执行","用于","必须","当","defines","server","导致","2.2","r","（","体","从而","这","还要","tokens","2.1","到","充分","同一个","newlimitor","消费","来自","用来","检查","l","请求","从桶","给","ecosystem","保证","达到","图","缓存","resourceexhausted","：","差异","是","非常","发送到","context",":","api","足够","池已","request","在","struct","serverstream","其","0","序列","quantum","系统","srv","下文","稳定","定义","网络通信","某种程度","后","原则","的","没有","交易","传输","则","对应","为了","limitor","而","分配","同时","两种","both","nil","一个","耗尽","漏桶","拦截","桶","info","实现","调用","无法","后面","虽然","自动","unary","资源","过程","瘫痪","will","由","过快","抛","最","首先","token","内容","capacity","内存","github","中所","go","拒绝","配置","并行处理","水","同样","还","grpc","req","fifo","传输速率","来说","读","limit","方法","p2p","a","多","分为","rate","然后","当桶","避免","网络资源","可能","time","过多","每当","发过来","其他","客户端","to","结合","相互","具体","is","设计","计算","unaryserverinfo","底","另","类型","目标","error","共识","）","但是","针对","流控","因此","”","常用","干扰","带来","rpc","对于","需求","interceptors","streamserverinterceptor","arguments","w","带权","/","不断","关键","状态","送到","整形","stream","适合","the","个","initially","与此同时","takeavailable","验签","分利","newlimitorwithquantum","be","添加","限制","func","of","已经","up","原理","异常","middleware","类比","链","bool","应","\"","逻辑",")","里","不仅","status","流出","大量","高","unaryhandler","放入","空间","查询","fullmethod","溢出","every","分","恢复","要求","added","提供","数量","间","toml","等","数","function","全部","处于","带宽","b","要","收到","发送","各个","by","ctx","端","that","可以","于","主要","算机","底层","duration","具体做法","时","需要","大体","pass","源源不断","往桶","核心","按照","得到","发过","应用","过来","把","每","过高","做到","目的","管道","模块","占用","未满","unaryserverinterceptor","true","；","流量","简称","内","}","一定","通过","丢弃","能力","及时","(","速率","串行","流中","取出","size","所示","type","at","详细","将","结构","影响","maximum","实体","errorf","计算机网络","非常适合","一点","消耗","互不","同一","节点","控制","must","相关","有","强行","if","s","提高","perform","甚至","streamhandler","allows","cpu","blob","一种","一条","master","参数","系统资源","从","允许","最多","非核心","做法","fillinterval","降低","崩溃","涉及","又","内部","消息","limiting","非关键","进行","防止","full","如下","写",".","总结","根据","一","接收","都","适用","更能","specification","*","平台","interface","2","盛水","下","多个","突发","大小","入口","please","算法","otherwise","直接","速度慢","它","最后","interceptor","客户","占","正常","地","器","网络","由于","、","时刻","100","才能","占去","juju","非核","显然","，","变慢","服务","了","利用","{","数据"],"title":"API流控设计","title_tokens":["设计","api","流控"]},{"location":"bitxhub/design/rate-limiter/#api","text":"","text_tokens":[],"title":"API流控设计","title_tokens":["设计","api","流控"]},{"location":"bitxhub/design/rate-limiter/#_1","text":"","text_tokens":[],"title":"实体定义","title_tokens":["实体","定义"]},{"location":"bitxhub/design/rate-limiter/#_2","text":"漏桶算法的原理可以类比为往一个固定大小的桶里盛水，同时，水从桶底漏洞以固定速度流出，如果加水过快，则直接溢出，如下图所示。它可以应用于网络传输限流，计算机每发送一个数据包，如果桶内未满，则把数据包放入桶里，如果桶内已满，则丢弃数据包，与此同时，以固定速度从桶内取出数据包，发送到网络，从而达到**强行限制数据平均传输速率**的目的。 漏桶算法常用于将突发或不稳定流量整形为以固定速度在网络中传输的流量。","text_tokens":["目的","从而","未满","满","为","不","流量","内","如果","丢弃","速率","从桶","计算","取出","达到","底","以","图","所示","数据包","发送到","将","常用","在","稳定","强行","送到","。","整形","平均","漏洞","的","传输","与此同时","则","速度","已","从","同时","限制","一个","漏桶","原理","桶","类比","加水","里","流出","如下","放入","溢出","固定","过快","计算机","往","*","或","中","盛水","突发","大小","与此","算法","直接","发送"," ","它","水","可以","于","网络","算机","限流","传输速率","，","应用","把","每","数据"],"title":"漏桶算法","title_tokens":["算法","漏桶"]},{"location":"bitxhub/design/rate-limiter/#_3","text":"对于要求允许某种程度的突发传输，漏桶算法显然无法满足需求，而令牌桶可以做到这一点。令牌桶算法同样定义了一个固定大小的桶，桶里最多可容纳 b 个令牌，每当有数据包需要发送时，要从桶里取出对应数量的令牌才能发送，如果桶里没有足够令牌，则无法发送。与此同时，以固定速度 r 往桶里添加新令牌，当桶里令牌数已经达到 b 个时，丢弃新令牌。 令牌桶算法非常适合于针对系统外部请求的限流，当桶内有足够多令牌时，系统在某一时刻可以同时接收并处理多个请求，充分利用到系统资源。 总结来说，令牌桶限流允许突发流量，对于请求的限流、网络带宽限流，更能充分利用系统资源和网络资源，是适用于区块链底层平台系统流控的一种限流方法。","text_tokens":["做到","这","网络资源","每当","到","充分","流量","内","处理","如果","丢弃","区块","请求","取出","满足","达到","以","数据包","某","是","非常","并","针对","容纳","流控","足够","非常适合","在","对于","一点","需求","系统","有","定义","新","某种程度","。","的","没有","适合","可","个","传输","一种","与此同时","则","对应","速度","分利","系统资源","添加","而","充分利用","从","同时","某种","已经","允许","一个","漏桶","桶","链","无法","里","资源","令牌","总结","一","接收","固定","适用","要求","最","更能","数量","程度","平台","数","多个","大小","突发","带宽","与此","b","算法","要","发送","外部"," ","可以","同样","于","网络带宽","和","网络","、","时刻","限流","底层","才能","时","需要","来说","往桶","方法","多","r","显然","，","当桶","了","利用","数据"],"title":"令牌桶算法","title_tokens":["令牌","桶","算法"]},{"location":"bitxhub/design/rate-limiter/#2","text":"区块链节点的入口流量大体分为两种： 一种为客户端发送过来的请求，请求可能为区块链数据查询、发送新交易、合约操作等（下文将简称为“客户端请求”）。节点接收到客户端请求后，首先需要从网络IO流中读取到请求的字节内容，然后反序列化字节内容为结构化内容，最后根据结构化请求体调用对应的API逻辑； 另一种为其他区块链节点发过来的网络消息，区块链系统底层是由多个共识节点组成的共识网络，节点间通过计算机网络进行信息传输（下文将简称为“节点间网络消息”）。节点接收到对端节点发送过来的网络消息后，根据消息类型，抛给对应的模块去处理。因此，不仅需要对客户端请求进行流量控制，防止大量突发外部请求都往同一个节点发送，耗尽目标节点资源导致目标节点服务瘫痪。还要对节点接收到的网络消息进行限流，防止节点在高负载下，前面的消息涉及的系统逻辑还未处理完，还源源不断地接收和缓存后面到来的消息，甚至导致节点内存溢出。","text_tokens":["可能","模块","还要","信息","到","发过来","同一个","为","其他","客户端","未","；","流量","合约","简称","处理","通过","区块","到来","请求","反","流中","给","计算","另","类型","缓存","io","目标","前面","：","是","共识","）","将","结构","因此","操作","”","api","读取","计算机网络","“","在","负载","序列","同一","节点","控制","系统","下文","序列化","不断","甚至","新","。","后","的","交易","传输","一种","对应","从","两种","一个","耗尽","字节","链","涉及","逻辑","调用","后面","消息","不仅","进行","防止","资源","大量","高","瘫痪","根据","去","查询","接收","溢出","由","都","抛","计算机","往","首先","间","内容","等","下","多个","突发","内存","入口","结构化","对","发送","外部"," ","最后","客户","端","源源","地","和","还","网络","、","完","算机","底层","组成","限流","需要","大体","源源不断","导致","分为","，","（","服务","然后","发过","过来","体","数据"],"title":"2.详细设计","title_tokens":["详细",".","2","设计"]},{"location":"bitxhub/design/rate-limiter/#21-rpc","text":"交易拦截器限流 限制请求速率：通过令牌桶限流算法控制请求速率，并限制节点最多可同时接收并处理的请求数。 节点高负载下拒绝新交易：当节点交易池已满或者处于异常、异常恢复状态无法进行正常共识时，拒绝来自客户端发送过来的新交易，避免交易参数检查、交易验签带来的CPU消耗。 令牌桶算法： https://github.com/juju/ratelimit GRPC提供Interceptor用于拦截请求： https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/ratelimit/ratelimit.go // Limiter defines the interface to perform request rate limiting. // If Limit function return true, the request will be rejected. // Otherwise, the request will pass. type Limiter interface { Limit () bool } // UnaryServerInterceptor returns a new unary server interceptors that performs request rate limiting. func UnaryServerInterceptor ( limiter Limiter ) grpc . UnaryServerInterceptor { return func ( ctx context . Context , req interface {}, info * grpc . UnaryServerInfo , handler grpc . UnaryHandler ) ( interface {}, error ) { if limiter . Limit () { return nil , status . Errorf ( codes . ResourceExhausted , \"%s is rejected by grpc_ratelimit middleware, please retry later.\" , info . FullMethod ) } return handler ( ctx , req ) } } // StreamServerInterceptor returns a new stream server interceptor that performs rate limiting on the request. func StreamServerInterceptor ( limiter Limiter ) grpc . StreamServerInterceptor { return func ( srv interface {}, stream grpc . ServerStream , info * grpc . StreamServerInfo , handler grpc . StreamHandler ) error { if limiter . Limit () { return status . Errorf ( codes . ResourceExhausted , \"%s is rejected by grpc_ratelimit middleware, please retry later.\" , info . FullMethod ) } return handler ( srv , stream ) } } 结合令牌桶和GRPC的interceptor实现对于API的流控： type Limitor struct { TokenBucket } // returns a new token bucket that fills at the rate of one token every fillInterval, // up to the given maximum capacity.Both arguments must be positive. // The bucket is initially full. func NewLimitor ( fillInterval time . Duration , capacity int64 ) * Limitor // allows the specification of the quantum size - quantum tokens are added every fillInterval. func NewLimitorWithQuantum ( fillInterval time . Duration , capacity , quantum int64 ) * Limitor func ( l * Limitor ) Limit () bool { return l . TakeAvailable () == 0 } 在bitxhub.toml添加相对应的配置 limitor: interval: 10ms quantum: 100 capacity: 10000","text_tokens":["10000","time","rejected","performs","tokens","满","unaryserverinterceptor","newlimitor","来自","true","客户端","to","}","处理","结合","检查","l","tokenbucket","通过","streamserverinfo","is","(","请求","速率","ecosystem","%","size","limiter","unaryserverinfo","new","_","type","at","resourceexhausted","one","：","error","共识","并","context","later","return","流控",":","maximum","errorf","api","带来","池已","request","在","对于","struct","serverstream","given","interceptors","0","streamserverinterceptor","消耗","负载","节点","控制","arguments","quantum","must","handler","srv","=","if","s","/","on","状态","perform","新","positive","。","stream","streamhandler","allows","int64","的","可","the","cpu","blob","交易","initially","takeavailable","master","验签","或者","参数","newlimitorwithquantum","be","limitor","添加","同时","限制","both","func","nil","of",",","up","拦截器","最多","拦截","桶","异常","info","middleware","应","fillinterval","bool","\"","实现","无法","returns","unary","limiting",")","codes","进行","status","full","高","令牌",".","unaryhandler","bucket","接收","fullmethod","will","every","恢复","are","specification","added","提供","*","interface","token","toml","数","下","function","https","capacity","处于","ratelimit","interval","github","com","please","算法","go","10ms","otherwise","-","拒绝","发送","retry","相对","bitxhub","配置"," ","by","fills","ctx","interceptor","客户","that","正常","和","、","grpc","req","限流","duration","100","用于","时","pass","当","defines","server","limit","juju","a","，","rate","过来","避免","{"],"title":"2.1 RPC流控","title_tokens":["2.1","流控","rpc"," "]},{"location":"bitxhub/design/rate-limiter/#22-p2p","text":"带权消息分发器限流 主要用来限制非关键模块的流量，防止带宽、CPU和内存都被非关键模块给占用。具体做法是为各个需要进行网络通信的模块分配带缓存空间的读（R）、写（W）管道，根据模块在系统中所占权重为其管道分配不同的缓存大小。 消息分发器收到一条来自底层P2P网络的网络消息，根据消息类型将消息分发给对应模块进行处理。这条消息首先分发给模块对应的 R 管道，模块再从 R 管道按照FIFO原则取出消息，执行相关逻辑，如果 R 管道消费速度慢于生产速度，导致分发消息时 R 管道已满，则说明模块内部已处于高负载，丢弃这条消息。为了保证达到系统限流目的，模块从 R 管道取出消息并处理消息的过程必须是串行的，而模块间的消息并行处理，互不干扰。 举个例子，当非关键模块处于高负载处理能力变慢时，其 R 管道虽然占满，但是不会影响共识模块消息的处理速度，同时又由于不同模块根据权重 R 管道大小不同，一定程度上防止节点一直处理非关键模块消息占用过多系统资源而导致共识模块消息无法得到及时处理。 带权消息分发一定程度上降低了各模块由于处理能力差异而相互干扰，提高系统网络消息并行处理能力，保证核心网络消息不被非核心网络消息占去全部系统资源，同时，系统高负载下自动丢弃新接收到的网络消息，防止系统负载过高而崩溃。","text_tokens":["带","目的","发给","这","处理速度","管道","说明","模块","占用","过多","各","上","满","到","为","一直","用来","来自","不","流量","处理","一定","通信","如果","相互","具体","丢弃","能力","及时","串行","给","生产","取出","保证","达到","类型","缓存","被","差异","是","共识","）","并","但是","将","影响","干扰","在","权重","其","互不","负载","节点","相关","系统","w","带权","提高","关键","网络通信","新","。","原则","的","cpu","一条","则","不同","对应","为了","速度","已","系统资源","并行","而","分配","从","同时","限制","再","非核心","做法","降低","能力差异","崩溃","又","逻辑","内部","无法","虽然","自动","消息","非关键","资源","防止","进行","已满","高","过程","写","根据","空间","接收","举个","都","分","首先","间","程度","及时处理","例子","下","大小","全部","处于","内存","带宽","中所","收到","条","各个","不会","能力差"," ","速度慢","占","并行处理","器","于","和","分发","网络","由于","主要","、","限流","具体做法","底层","执行","时","需要","fifo","必须","当","读","导致","占去","p2p","r","非核","，","核心","（","按照","变慢","得到","了","消费","过高"],"title":"2.2 P2P流控","title_tokens":["p2p","流控","2.2"," "]},{"location":"bitxhub/design/rate-limiter/#_4","text":"","text_tokens":[],"title":"","title_tokens":[]},{"location":"bitxhub/dev/api/","text":"","text_tokens":[],"title":"Api","title_tokens":["api"]},{"location":"bitxhub/dev/cross_contract/","text":"跨链合约 按照跨链合约的设计，我们需要在有跨链需求的应用链上部署两种合约。一个合约负责对接跨链网关Pier，为跨链管理合约Broker；一个合约负责具体的业务场景，为业务合约。业务合约需要跨链时，要统一将跨链请求提交到Broker合约上，Broker统一和Pier进行交互。一个Broker合约可以负责对接多个业务合约。 跨链接入方无需对broker合约进行修改，直接部署使用即可；同时为了简化业务合约的编写，我们设计了业务合约的相应接口。 以下以以太坊上的solidity合约为例。 Broker 合约接口 // 提供给业务合约注册。注册且审核通过的业务合约才能调用Broker合约的跨链接口，输入为具体的broker合约地址 function register ( string addr ) public // 提供给管理员审核已经注册的业务合约 function audit ( string addr , bool status ) public returns ( bool ) // getInnerMeta 是获取跨链请求相关的Meta信息的接口。以Broker所在的区块链为目的链的一系列跨链请求的序号信息。 // 如果Broker在A链，则可能有多条链和A进行跨链，如B->A:3; C->A:5。 // 返回的map中，key值为来源链ID，value对应该来源链已发送的最新的跨链请求的序号，如{B:3, C:5}。 function getInnerMeta () public view returns ( address [] memory , uint64 [] memory ) // getOuterMeta 是获取跨链请求相关的Meta信息的接口。以Broker所在的区块链为来源链的一系列跨链请求的序号信息。 // 如果以Broker在A链，则A可能和多条链进行跨链，如A->B:3; A->C:5。 // 返回的map中，key值为目的链ID，value对应已发送到该目的链的最新跨链请求的序号，如{B:3, C:5}。 function getOuterMeta () public view returns ( address [] memory , uint64 [] memory ) // getCallbackMeta 是获取跨链请求相关的Meta信息的接口。以Broker所在的区块链为来源链的一系列跨链请求的序号信息。 // 如果Broker在A链，则A可能和多条链进行跨链，如A->B:3; A->C:5；同时由于跨链请求中支持回调操作，即A->B->A为一次完整的跨链操作， // 我们需要记录回调请求的序号信息，如A->B->:2; A->C—>A:4。返回的map中，key值为目的链ID，value对应到该目的链最新的带回调跨链请求的序号， // 如{B:2, C:4}。（注意 callbackMeta序号可能和outMeta是不一致的，这是由于由A发出的跨链请求部分是没有回调的） function getCallbackMeta () public view returns ( address [] memory , uint64 [] memory ) // getInMessage 查询历史跨链请求所在的区块高度。查询键值中srcChainID指定来源链，idx指定序号，查询结果为以Broker所在的区块链作为目的链的跨链请求所在的区块高度。 function getInMessage ( string srcChainID , uint64 idx ) public view returns ( uint ) // getOutMessage 查询历史跨链请求所在的区块高度。查询键值中dstChainID指定目的链，idx指定序号，查询结果为以Broker所在的区块链作为来源链的跨链请求所在的区块高度。 function getOutMessage ( string dstChainID , uint64 idx ) public view returns ( uint ) // 提供给跨链网关调用的接口，跨链网关收到跨链请求时会调用该接口。 function invokeInterchain ( address srcChainID , uint64 index , address destAddr , bool req , bytes calldata bizCallData ) payable external // 提供给跨链网关调用的接口，当跨链网关收到无效当跨链请求时会调用该接口。 function invokeIndexUpdateWithError ( address srcChainID , uint64 index , bool req , string memory err ) public // 提供给业务合约发起通用的跨链交易的接口。 function emitInterchainEvent ( address destChainID , string memory destAddr , string memory funcs , string memory args , string memory argscb , string memory argsrb ) public onlyWhiteList // 提供给合约部署初始化使用 function initialize () public 重要接口说明 emitInterchainEvent 该接口是业务合约发起通用的跨链调用的接口。接收的参数有：目的链ID，目的链业务合约地址或ID，调用的函数名、回调函数名、回滚函数名，调用函数的参数，回调函数的参数，回滚函数的参数。 Broker会记录跨链交易相应的元信息，对跨链交易进行编号，保证跨链交易有序进行, 并且抛出跨链事件，以通知跨链网关跨链交易的产生。 invokeInterchain 该接口是跨链网关对业务合约进行跨链调用或回调/回滚的接口。 接收参数有：来源链ID，交易序号，目的业务合约ID，是否是跨链请求，业务合约调用方法和参数的封装数据。 跨链网关对要调用的目的合约的方法和参数进行封装，通过该接口实现对不同目的合约的灵活调用，并返回目的合约的调用函数的返回值。 业务合约接口 业务合约现阶段分为资产类和数据交换类的业务合约，由于资产类的有操作原子性和安全性的考虑，需要的接口实现上比数据交换类的业务合约更复杂。 Transfer 合约 // 发起一笔跨链交易的接口 function transfer ( string dstChainID , string destAddr , string sender , string receiver , string amount ) public // 提供给Broker合约收到跨链充值所调用的接口 function interchainCharge ( string sender , string receiver , uint64 val ) public onlyBroker returns ( bool ) // 跨链交易失败之后，提供给Broker合约进行回滚的接口 function interchainRollback ( string sender , uint64 val ) public onlyBroker // 获取transfer合约中某个账户的余额 function getBalance ( string id ) public view returns ( uint64 ) // 在transfer合约中给某个账户设置一定的余额 function setBalance ( string id , uint64 amount ) public } DataSwapper合约 // 发起一个跨链获取数据交易的接口 function get ( string dstChainID , string dstAddr , string key ) public // 提供给Broker合约调用，当Broker收到跨链获取数据的请求时取数据的接口 function interchainGet ( string key ) public onlyBroker returns ( bool , string memory ) // 跨链获取到的数据回写的接口 function interchainSet ( string key , string value ) public onlyBroker 具体实现 对于想要接入到我们的跨链平台中的Fabric区块链，我们已经有提供跨链管理合约Broker和相应的Plugin，你只需要对你的业务合约进行一定的改造便可拥有跨链功能。 如果是其他应用链，你可以根据我们的设计思路自行开发跨链管理合约以及相应的Plugin。 现在我们已经有Solidity版本和chaincode版本编写的跨链合约样例实现，具体说明如下： Solidity 跨链合约实现 Chaincode 跨链合约实现 如果你需要新的语言编写合约，你可以按照我们的设计思路和参考实现进行进一步的开发。 现在我们支持Hyperchain EVM合约、以太坊私链Solidity合约、BCOS EVM合约以及Fabric Chaincode合约。 Hyperchain、以太坊、BCOS上的EVM合约 本节主要说明在支持EVM合约的应用链上，如何使用我们提供的跨链管理合约Broker，在你已有的Solidity业务合约的基础上添加接口，以获得跨链能力。 当然不同的区块链可能在以太坊的EVM上做了一些二次开发和新增功能，请根据具体区块链的文档相应修改代码。 业务合约Demo 假设你已经有了一个简单的KV存储的业务合约，代码如下： pragma solidity >= 0.5.7 ; contract DataSwapper { mapping ( string => string ) dataM ; // map for accounts // 数据交换类的业务合约 function getData ( string memory key ) public returns ( string memory ) { return dataM [ key ]; } function setData ( string memory key , string memory value ) public { dataM [ key ] = value ; } } 现在你想在这个合约的基础上增加一个跨链获取数据的功能，如果使用我们的跨链管理合约提供的接口，很简单的增加几个接口就可以了。 发起跨链数据交换的接口 contract DataSwapper { // broker合约地址 address BrokerAddr = 0x2346f3BA3F0B6676aa711595daB8A27d0317DB57 ; Broker broker = Broker ( BrokerAddr ); ... function get ( address destChainID , string memory destAddr , string memory key ) public { broker . emitInterchainEvent ( destChainID , destAddr , \"interchainGet,interchainSet,\" , key , key , \"\" ); } } contract Broker { function emitInterchainEvent ( address destChainID , string memory destAddr , string memory funcs , string memory args , string memory argscb , string memory argsrb ) public ; } 其中Broker的地址和该业务合约需要使用到的接口需要在业务合约中声明，然后直接调用该接口发起跨链交易。 跨链获取的接口 contract DataSwapper { ... modifier onlyBroker { require ( msg.sender == BrokerAddr , \"Invoker are not the Broker\" ); _ ; } function interchainGet ( string memory key ) public onlyBroker returns ( bool , string memory ) { return ( true , dataM [ key ]); } } 我们规定跨链调用的接口的第一个返回值类型必须是bool类型，它用来表示跨链调用是否成功。 其中onlyBroker是进行跨链权限控制的修饰器。该接口和下面的跨链回写接口均是提供给Broker合约进行调用，也是其他应用链发来的跨链交易执行时需要调用的接口。 跨链回写的接口 contract DataSwapper { ... function interchainSet ( string memory key , string memory value ) public onlyBroker { setData ( key , value ); } ... } Fabric 本节主要说明在Fabric应用链上，如何使用我们提供的跨链管理合约Broker，在你已有业务合约的基础上添加接口，以获得跨链能力。 业务合约Demo 假设你已经有了一个简单的KV存储的业务合约，代码如下： type KVStore struct {} func ( s * KVStore ) Init ( stub shim . ChaincodeStubInterface ) peer . Response { return shim . Success ( nil ) } func ( s * KVStore ) Invoke ( stub shim . ChaincodeStubInterface ) peer . Response { function , args := stub . GetFunctionAndParameters () fmt . Printf ( \"invoke: %s\\n\" , function ) switch function { case \"get\" : return s . get ( stub , args ) case \"set\" : return s . set ( stub , args ) default : return shim . Error ( \"invalid function: \" + function + \", args: \" + strings . Join ( args , \",\" )) } } func ( s * KVStore ) get ( stub shim . ChaincodeStubInterface , args [] string ) peer . Response { // args[0]: key value , err := stub . GetState ( args [ 0 ]) if err != nil { return shim . Error ( err . Error ()) } return shim . Success ( value ) } // get is business function which will invoke the to,tid,id func ( s * KVStore ) set ( stub shim . ChaincodeStubInterface , args [] string ) peer . Response { if len ( args ) != 2 { return shim . Error ( \"incorrect number of arguments\" ) } err := stub . PutState ( args [ 0 ], [] byte ( args [ 1 ])) if err != nil { return shim . Error ( err . Error ()) } return shim . Success ( nil ) } func main () { err := shim . Start ( new ( KVStore )) if err != nil { fmt . Printf ( \"Error starting chaincode: %s\" , err ) } } 现在你想在这个合约的基础上增加一个跨链获取数据的功能，如果使用我们的跨链管理合约提供的接口，很简单的增加几个接口就可以了。 发起跨链数据交换的接口 为了方便用户使用，我们在原来获取数据的接口基础上增加这个功能： const ( channelID = \"mychannel\" brokerContractName = \"broker\" emitInterchainEventFunc = \"EmitInterchainEvent\" ) func ( s * KVStore ) get ( stub shim . ChaincodeStubInterface , args [] string ) peer . Response { switch len ( args ) { case 1 : // args[0]: key value , err := stub . GetState ( args [ 0 ]) if err != nil { return shim . Error ( err . Error ()) } return shim . Success ( value ) case 3 : // args[0]: destination appchain id // args[1]: destination contract address // args[2]: key b := util . ToChaincodeArgs ( emitInterchainEventFunc , args [ 0 ], args [ 1 ], \"interchainGet\" , args [ 2 ], \"interchainSet\" , args [ 2 ], \"\" , \"\" ) response := stub . InvokeChaincode ( brokerContractName , b , channelID ) if response . Status != shim . OK { return shim . Error ( fmt . Errorf ( \"invoke broker chaincode %s error: %s\" , brokerContractName , response . Message ). Error ()) } return shim . Success ( nil ) default : return shim . Error ( \"incorrect number of arguments\" ) } } 由于我们的跨链管理合约一旦部署之后，chaincode name和所在的channel和跨链接口都是不变的，所以在业务变量中直接使用常量指定Broker合约的相关信息。 b := util . ToChaincodeArgs ( emitInterchainEventFunc , args [ 0 ], args [ 1 ], \"interchainGet\" , args [ 2 ], \"interchainSet\" , args [ 2 ], \"\" , \"\" ) response := stub . InvokeChaincode ( brokerContractName , b , channelID ) 这两行代码调用了我们的跨链管理合约，只需要提供参数：目的链ID，目的链上业务合约的地址，跨链调用函数，跨链调用函数参数，回调函数，回调函数参数，最后两个参数为回滚函数和回滚函数参数，因为该场景下即使目的链执行跨链交易失败，来源链也无需回滚，因此无需提供回滚信息。 跨链获取的接口 func ( s * KVStore ) interchainGet ( stub shim . ChaincodeStubInterface , args [] string ) peer . Response { if len ( args ) != 1 { return shim . Error ( \"incorrect number of arguments\" ) } value , err := stub . GetState ( args [ 0 ]) if err != nil { return shim . Error ( err . Error ()) } return shim . Success ( value ) } interchainGet 接收参数 key ，在本合约中查询该 Key 值对应的 value ，并返回。该接口提供给 Broker 合约进行跨链获取数据的调用。 跨链回写的接口 func ( s * KVStore ) interchainSet ( stub shim . ChaincodeStubInterface , args [] string ) peer . Response { if len ( args ) != 2 { return shim . Error ( \"incorrect number of arguments\" ) } err := stub . PutState ( args [ 0 ], [] byte ( args [ 1 ])) if err != nil { return shim . Error ( err . Error ()) } return shim . Success ( nil ) } interchainSet 接收参数 key ，在本合约中设置 Key 值对应的 value 。该接口提供给 Broker 合约回写跨链获取数据的时候进行调用。 使用示例 跨链场景 ：以以太坊为例，位于A链的账户Alice向位于B链的Bob发起转账交易。 在应用链部署broker合约与业务合约，具体部署流程参考 部署跨链合约 。 调用 register 方法注册业务合约。入参为需要进行跨链的业务合约地址。 调用 audit 对已经注册的业务合约进行审核，status为1说明审核通过。 transfer 业务合约调用 setBalance 方法初始化账户。 transfer 业务合约调用 transfer 方法发起跨链交易。 1.1 appchainA deploy ==> brokerA addr：0xFb23Af09e3E8D83fd5575De9558920Bf351F05E8 businessA addr: 0x5bFe03Dbd09817d4957693f672cc31A133Bb6084 1.2 appchainB deploy ==> brokerB addr：0xC8C086200f92c9226b42079eCB3137eFc8752801 businessB addr: 0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f 2.1 brokerA register ==> addr：0x5bFe03Dbd09817d4957693f672cc31A133Bb6084 //部署的业务合约地址 2.2 brokerB register ==> addr：0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f //部署的业务合约地址 3.1 brokerA audit ==> addr：0x5bFe03Dbd09817d4957693f672cc31A133Bb6084 status: 1 3.2 brokeB audit ==> addr：0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f status: 1 4.1 transferA setBalance ==> id: Alice amount: 100 4.2 transfeB setBalance ==> id: Bob amount: 0 // destChainID为B链的PierID，可在终端通过pier --repo <appchainB_config_path> id获取 // destAddr为B链的业务合约地址 5 transferA transfer ==> destChainID: 0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1 destAddr: 0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f sender: Alice receiver: Bob amount: 10 观察跨链网关与中继链日志 # 网关pierA同步以太坊区块头并处理跨链交易，发送至中继链 INFO[21:54:30.559] Persist block header height=18 module=bxh_lite WARN[21:54:30.560] query header: header at 18 not found module=syncer INFO[21:54:32.568] Handle interchain tx wrapper count=0 height=18 index=0 module=syncer WARN[21:54:38.401] query header: header at 19 not found module=syncer INFO[21:54:38.401] Persist block header height=19 module=bxh_lite INFO[21:54:40.404] Handle interchain tx wrapper count=1 height=19 index=0 module=syncer INFO[21:54:40.409] Apply tx from=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb id=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-2 index=2 module=executor status=true type=RECEIPT_SUCCESS 2021-12-01T21:54:40.413+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:40.412+0800 [INFO ] client: submit ibtp: id=0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-2 contract=0x5bFe03Dbd09817d4957693f672cc31A133Bb6084 func= 2021-12-01T21:54:40.413+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:40.413+0800 [INFO ] client: arg: 0= 2021-12-01T21:54:40.413+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:40.413+0800 [INFO ] client: InvokeIndexUpdate: ibtp=0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-2 # 中继链将收到的跨链交易上链，并路由到网关PierB time=\"2021-12-01T21:54:30.420\" level=info msg=\"======== Replica 1 call execute, height=18\" module=order time=\"2021-12-01T21:54:30.430\" level=info msg=\"Generated block\" count=1 height=18 module=app time=\"2021-12-01T21:54:30.554\" level=info msg=\"Persisted block\" count=1 elapse=8.963884ms hash=0x4474C7a5db7049Da22cEB82324988f572e57Ba88926D4D8549110c433bAD01de height=18 module=executor # 网关PierB同步区块头并处理跨链交易，将回执类型跨链交易返回给中继链 INFO[21:54:30.565] Persist block header height=18 module=bxh_lite WARN[21:54:30.567] query header: header at 18 not found module=syncer INFO[21:54:32.568] Handle interchain tx wrapper count=1 height=18 index=0 module=syncer INFO[21:54:32.568] Apply tx from=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb id=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-2 index=2 module=executor status=true type=INTERCHAIN 2021-12-01T21:54:32.594+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:32.591+0800 [INFO ] client: submit ibtp: id=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-2 contract=0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f func=interchainCharge 2021-12-01T21:54:32.594+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:32.593+0800 [INFO ] client: arg: 0=A 2021-12-01T21:54:32.594+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:32.593+0800 [INFO ] client: arg: 1=B 2021-12-01T21:54:32.594+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:32.593+0800 [INFO ] client: arg: 2=10 2021-12-01T21:54:37.810+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:37.810+0800 [INFO ] client: log: index=0 data=0x0000000000000000000000000000000000000000000000000000000000000001 INFO[21:54:37.813] Handle ibtp success id=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-2 module=exchanger type=INTERCHAIN INFO[21:54:38.381] Persist block header height=19 module=bxh_lite WARN[21:54:38.381] query header: header at 19 not found module=syncer INFO[21:54:40.384] Handle interchain tx wrapper count=0 height=19 index=0 module=syncer # 中继链将收到的回执类型的跨链交易上链，返回至网关PierA time=\"2021-12-01T21:54:38.311\" level=info msg=\"======== Replica 1 call execute, height=19\" module=order time=\"2021-12-01T21:54:38.312\" level=info msg=\"Generated block\" count=1 height=19 module=app time=\"2021-12-01T21:54:38.399\" level=info msg=\"Persisted block\" count=1 elapse=6.881ms hash=0xf676406e6f88FC0cF27b043e926e1e4a528E6Ee5ed62146e86D18F3ABA68D260 height=19 module=executor # 网关PierA收到跨链交易回执，返回给应用链A INFO[21:54:45.568] Execute callback fields.msg= index=2 module=executor status=true type=RECEIPT_SUCCESS INFO[21:54:45.569] Handle ibtp receipt success id=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-2 module=exchanger type=RECEIPT_SUCCESS # 跨链交易完成，在应用链A上查询Alice的余额从100变更为90；在应用链B上查询Bob的余额从0变更为10 总结 经过上面的改造，你的业务合约已经具备跨链获取数据的功能了，完整的代码可以参考 这里","text_tokens":["说明","信息","上","为","get","不","合约","处理","如果","onlybroker","一旦","区块","位于","debug","38.381","场景","chaincodestubinterface","30.565","40.413","modifier","%","中继","new","以","_","srcchainid","tochaincodeargs","37.810","所以","并","return","argsrb","操作","channelid","sh","msg","40.384","1.1","0x0000000000000000000000000000000000000000000000000000000000000001","链接","log","口","回执","32.591","=","38.311","回滚","tx","现在","存储","0xfb23af09e3e8d83fd5575de9558920bf351f05e8","新","。","peer","值中","invalid","可","brokerb","调用函数","不同","dstaddr","submit","链为","送至","已","transfeb","persist","新增",",","类","接口","便","businessa","callbackmeta","完成","返回","invoke","returns","原子","emitinterchaineventfunc","获取数据","accounts","即可","45.569","元","bob","exchanger","已有","产生","interchainset","dstchainid","are","充值","number","开发","两个","发起","或","45.568",";","0xc8c086200f92c9226b42079ecb3137efc8752801","中","block","0x2346f3ba3f0b6676aa711595dab8a27d0317db57","37.813","incorrect","设置","start","更","以及","bxh","call","30.567","chaincode","-","安全","client","对","mapping","string","19"," ","修饰","3","原来","路由","和","之后","execute","执行","必须","灵活","当","business","key","2.2","destination","32.568","（","18","管理","业务","账户","getdata","index","broker","这","2.1","到","部署","[","用户","deploy","register","时会","用来","流程","40.404","executor","30.554","plugin","30.559","0x4474c7a5db7049da22ceb82324988f572e57ba88926d4d8549110c433bad01de","0.5","data","不变","ok","40.412","对接","请求","简化","给","保证","文档","appchaina","因为","4.2","失败","replica","输入","：","是","作为","message","这里","进一步","strings","一致","interchaincharge","成功","发送到","一笔","mychannel","bizcalldata","现阶段",":","setbalance","只","假设","在","payable","transfer","struct","指定","interchain","getinnermeta","0","from","40.409","fields","kvstore","注意","getoutermeta","一些","len","的","私链","没有","与","join","0xf676406e6f88fc0cf27b043e926e1e4a528e6ee5ed62146e86d18f3aba68d260","交易","则","余额","对应","default","为了","使用","管理员","argscb","query","name","所","同时","两种","nil","坊","4.1","一个","audit",">","response","for","info","做","实现","调用","0x5bfe03dbd09817d4957693f672cc31a133bb6084","返回值","receiver","initialize","+","本","经过","repo","count","接入","跨","will","由","发出","自行","获得","发送至","最新","头","app","config","回调","brokercontractname","其中","负责","wrapper","均","invoker","outmeta","抛出","funcs","interchainget","带回","bytes","记录","which","found","req","也","32.593","21","方法","这个","a","分为","3.1","上面","修改","demo","改造","然后","向","地址","solidity","初始化","1","30.420","通知","getoutmessage","重要","可能","参为","time","elapse","arg","其他","请","id","无需","!","如","to","事件","具体","日志","is","38.401","设计","kv","是否","转账","几个","至","bcos","类型","简单","入","统一","brokera","error","address","所在","）","获取","2021","会","public","即","因此","对于","需求","brokeraddr","arguments","init","链上","资产","这是","getinmessage","/","piera","interchainrollback","printf","送到","syncer","set","#","value","the","下面","数据交换","destchainid","比","无效","32.594","二次","编号","module","pier","回写","添加","第一个","func","of","appchain","38.399","已经","view","且","支持","相应","链","bool","\"","思路","10","调跨","lite","某个",")","status","height","序号","函数参数","入方","查询","hash","提供","byte","基础","如何","封装","通用","require","putstate","增加","发来","二次开发","function","功能","order","注册","--","b","一次","memory","fmt","ms","要","部分","收到","switch","1.2","值","handle","apply","args","发送","ibtp","4","多条","函数","可以","datam","主要","idx","系列","54","时","需要","编写","—","success","01t21","level","getstate","stub","val","按照","参考","来源","应用","6.881","表示","观察","就","pierb","很","目的","有序","tid","pragma","复杂","0xff8199fae48c808b45667da0ccaaee839b1a10cb","节","常量","calldata","示例","businessb","alice","true","]","；","}","一定","一步","dataswapper","通过","generated","能力","starting","(","const","receipt","invokechaincode","应该","一系列","完整","5","历史","...","getfunctionandparameters","type","at","30.430","性","两行","header","brokeb","并且","n","invokeindexupdatewitherror","将","errorf","即使","高度","一系","3.2","30.560","case","控制","相关","结果","有","s","if","考虑","8.963884","交换","提交","invokeinterchain","<","想要","getcallbackmeta","参数","变量","规定","从","evm","main","c","想","名","contract","emitinterchainevent","审核","destaddr","warn","38.312","setdata","对要","0800","你","fabric","进行","callback","如下",".","根据","总结","时取","方便","shim","meta","pierid","第一","err","external","接收","都","addr","persisted","7","封装数据","util","变更","map","amount","appchainb","样例","0xa5dd12e27ee5e79ce0b50adb376414351c8eea5f","*","平台","当然","transfera","2","\\","下","多个","终端","为例","语言","12","代码","拥有","交互","直接","sender","安全性","具备","hyperchain","not","它","最后","invokeindexupdate","uint","getbalance","器","90","跨链","值为","由于","、","阶段","100","才能","初始","我们","是否是","权限","onlywhitelist","channel","path","0x23fb0e7ef676467563d37d820f1b1fddb0f9a2e1","uint64","以太","同步","版本","查询键","时候","，","网关","声明","了","该","以下","{","数据"],"title":"跨链合约开发","title_tokens":["开发","合约","跨链"]},{"location":"bitxhub/dev/cross_contract/#_1","text":"按照跨链合约的设计，我们需要在有跨链需求的应用链上部署两种合约。一个合约负责对接跨链网关Pier，为跨链管理合约Broker；一个合约负责具体的业务场景，为业务合约。业务合约需要跨链时，要统一将跨链请求提交到Broker合约上，Broker统一和Pier进行交互。一个Broker合约可以负责对接多个业务合约。 跨链接入方无需对broker合约进行修改，直接部署使用即可；同时为了简化业务合约的编写，我们设计了业务合约的相应接口。 以下以以太坊上的solidity合约为例。","text_tokens":["为例","broker","将","坊","一个","接口","负责","要","交互","直接","相应","到","上","在","对","为","部署"," ","需求","无需","；","链接","合约","可以","即可","和","跨链","进行","链上","具体","有","场景","设计","对接","时","需要","我们","请求","入方","。","跨","简化","编写","的","提交","以","以太","，","修改","网关","按照","为了","统一","使用","应用","管理","了","多个","solidity","pier","业务","以下","同时","两种"],"title":"跨链合约","title_tokens":["合约","跨链"]},{"location":"bitxhub/dev/cross_contract/#broker","text":"// 提供给业务合约注册。注册且审核通过的业务合约才能调用Broker合约的跨链接口，输入为具体的broker合约地址 function register ( string addr ) public // 提供给管理员审核已经注册的业务合约 function audit ( string addr , bool status ) public returns ( bool ) // getInnerMeta 是获取跨链请求相关的Meta信息的接口。以Broker所在的区块链为目的链的一系列跨链请求的序号信息。 // 如果Broker在A链，则可能有多条链和A进行跨链，如B->A:3; C->A:5。 // 返回的map中，key值为来源链ID，value对应该来源链已发送的最新的跨链请求的序号，如{B:3, C:5}。 function getInnerMeta () public view returns ( address [] memory , uint64 [] memory ) // getOuterMeta 是获取跨链请求相关的Meta信息的接口。以Broker所在的区块链为来源链的一系列跨链请求的序号信息。 // 如果以Broker在A链，则A可能和多条链进行跨链，如A->B:3; A->C:5。 // 返回的map中，key值为目的链ID，value对应已发送到该目的链的最新跨链请求的序号，如{B:3, C:5}。 function getOuterMeta () public view returns ( address [] memory , uint64 [] memory ) // getCallbackMeta 是获取跨链请求相关的Meta信息的接口。以Broker所在的区块链为来源链的一系列跨链请求的序号信息。 // 如果Broker在A链，则A可能和多条链进行跨链，如A->B:3; A->C:5；同时由于跨链请求中支持回调操作，即A->B->A为一次完整的跨链操作， // 我们需要记录回调请求的序号信息，如A->B->:2; A->C—>A:4。返回的map中，key值为目的链ID，value对应到该目的链最新的带回调跨链请求的序号， // 如{B:2, C:4}。（注意 callbackMeta序号可能和outMeta是不一致的，这是由于由A发出的跨链请求部分是没有回调的） function getCallbackMeta () public view returns ( address [] memory , uint64 [] memory ) // getInMessage 查询历史跨链请求所在的区块高度。查询键值中srcChainID指定来源链，idx指定序号，查询结果为以Broker所在的区块链作为目的链的跨链请求所在的区块高度。 function getInMessage ( string srcChainID , uint64 idx ) public view returns ( uint ) // getOutMessage 查询历史跨链请求所在的区块高度。查询键值中dstChainID指定目的链，idx指定序号，查询结果为以Broker所在的区块链作为来源链的跨链请求所在的区块高度。 function getOutMessage ( string dstChainID , uint64 idx ) public view returns ( uint ) // 提供给跨链网关调用的接口，跨链网关收到跨链请求时会调用该接口。 function invokeInterchain ( address srcChainID , uint64 index , address destAddr , bool req , bytes calldata bizCallData ) payable external // 提供给跨链网关调用的接口，当跨链网关收到无效当跨链请求时会调用该接口。 function invokeIndexUpdateWithError ( address srcChainID , uint64 index , bool req , string memory err ) public // 提供给业务合约发起通用的跨链交易的接口。 function emitInterchainEvent ( address destChainID , string memory destAddr , string memory funcs , string memory args , string memory argscb , string memory argsrb ) public onlyWhiteList // 提供给合约部署初始化使用 function initialize () public","text_tokens":["目的","broker","index","getoutmessage","可能","信息","到","calldata","为","部署","[","register","id","时会","不","]","如","；","}","合约","通过","如果","具体","区块","(","请求","给","应该","一系列","完整","以","5","历史","srcchainid","输入","是","作为","address","一致","所在","）","获取","发送到","invokeindexupdatewitherror","bizcalldata","public",":","即","操作","argsrb","高度","一系","在","payable","指定","getinnermeta","链接","口","相关","结果","有","这是","注意","getinmessage","/","getoutermeta","送到","。","值中","的","没有","value","invokeinterchain","交易","destchainid","则","无效","getcallbackmeta","对应","链为","使用","管理员","argscb","已","同时","c",",","已经","audit","且","接口",">","view","支持","callbackmeta","emitinterchainevent","链","审核","bool","destaddr","返回","调用","调跨","returns","initialize",")","status","进行","序号","meta","查询","err","external","跨","由","addr","发出","dstchainid","map","提供","最新","通用","发起",";","中","2","function","回调","注册","b","一次","memory","部分","收到","-","对","args","发送","4","string","outmeta"," ","多条","3","funcs","带回","uint","bytes","记录","和","跨链","值为","由于","idx","系列","req","才能","初始","需要","我们","—","当","onlywhitelist","key","uint64","a","查询键","，","网关","（","地址","来源","管理","初始化","业务","该","{"],"title":"Broker 合约接口","title_tokens":["合约","broker","接口"," "]},{"location":"bitxhub/dev/cross_contract/#_2","text":"emitInterchainEvent 该接口是业务合约发起通用的跨链调用的接口。接收的参数有：目的链ID，目的链业务合约地址或ID，调用的函数名、回调函数名、回滚函数名，调用函数的参数，回调函数的参数，回滚函数的参数。 Broker会记录跨链交易相应的元信息，对跨链交易进行编号，保证跨链交易有序进行, 并且抛出跨链事件，以通知跨链网关跨链交易的产生。 invokeInterchain 该接口是跨链网关对业务合约进行跨链调用或回调/回滚的接口。 接收参数有：来源链ID，交易序号，目的业务合约ID，是否是跨链请求，业务合约调用方法和参数的封装数据。 跨链网关对要调用的目的合约的方法和参数进行封装，通过该接口实现对不同目的合约的灵活调用，并返回目的合约的调用函数的返回值。","text_tokens":["会","目的","broker","通知","有序",",","接口","名","相应","信息","emitinterchainevent","链","对","抛出","返回"," ","id","对要","调用","实现","函数","返回值","合约","记录","并","进行","跨链","事件","元","和","通过","序号","有","、","产生","回调","回滚","/","请求","接收","灵活","。","是否是","是否","保证","方法","的","封装数据","invokeinterchain","交易","以","封装","通用","调用函数","发起","，","或","不同","网关","：","是","参数","地址","编号","来源","并且","业务","该","数据"],"title":"重要接口说明","title_tokens":["重要","接口","说明"]},{"location":"bitxhub/dev/cross_contract/#_3","text":"业务合约现阶段分为资产类和数据交换类的业务合约，由于资产类的有操作原子性和安全性的考虑，需要的接口实现上比数据交换类的业务合约更复杂。","text_tokens":["现阶段","类","操作","接口","复杂","更","安全","上","安全性","实现","原子","合约","和","由于","资产","有","阶段","需要","。","考虑","的","交换","数据交换","分为","比","，","性","业务","数据"],"title":"业务合约接口","title_tokens":["接口","业务","合约"]},{"location":"bitxhub/dev/cross_contract/#transfer","text":"// 发起一笔跨链交易的接口 function transfer ( string dstChainID , string destAddr , string sender , string receiver , string amount ) public // 提供给Broker合约收到跨链充值所调用的接口 function interchainCharge ( string sender , string receiver , uint64 val ) public onlyBroker returns ( bool ) // 跨链交易失败之后，提供给Broker合约进行回滚的接口 function interchainRollback ( string sender , uint64 val ) public onlyBroker // 获取transfer合约中某个账户的余额 function getBalance ( string id ) public view returns ( uint64 ) // 在transfer合约中给某个账户设置一定的余额 function setBalance ( string id , uint64 amount ) public }","text_tokens":["broker","public",",","view","接口","setbalance","收到","sender","在","bool","destaddr","string","transfer"," ","id","调用","receiver","returns","}","合约","某个",")","getbalance","一定","onlybroker","跨链","进行","之后","/","回滚","(","interchainrollback","设置","dstchainid","给","获取","充值","的","提供","uint64","amount","交易","失败","val","发起","，","余额","中","function","interchaincharge","一笔","所","账户"],"title":"Transfer 合约","title_tokens":["合约","transfer"," "]},{"location":"bitxhub/dev/cross_contract/#dataswapper","text":"// 发起一个跨链获取数据交易的接口 function get ( string dstChainID , string dstAddr , string key ) public // 提供给Broker合约调用，当Broker收到跨链获取数据的请求时取数据的接口 function interchainGet ( string key ) public onlyBroker returns ( bool , string memory ) // 跨链获取到的数据回写的接口 function interchainSet ( string key , string value ) public onlyBroker","text_tokens":["broker","public",",","memory","一个","接口","收到","到","bool","string"," ","get","调用","interchainget","returns","合约","获取数据",")","onlybroker","跨链","时取","/","(","interchainset","请求","当","dstchainid","给","key","的","提供","value","交易","发起","，","dstaddr","function","回写","获取","数据"],"title":"DataSwapper合约","title_tokens":["dataswapper","合约"]},{"location":"bitxhub/dev/cross_contract/#_4","text":"对于想要接入到我们的跨链平台中的Fabric区块链，我们已经有提供跨链管理合约Broker和相应的Plugin，你只需要对你的业务合约进行一定的改造便可拥有跨链功能。 如果是其他应用链，你可以根据我们的设计思路自行开发跨链管理合约以及相应的Plugin。 现在我们已经有Solidity版本和chaincode版本编写的跨链合约样例实现，具体说明如下： Solidity 跨链合约实现 Chaincode 跨链合约实现 如果你需要新的语言编写合约，你可以按照我们的设计思路和参考实现进行进一步的开发。 现在我们支持Hyperchain EVM合约、以太坊私链Solidity合约、BCOS EVM合约以及Fabric Chaincode合约。","text_tokens":["语言","broker","坊","已经","说明","只","便","拥有","以及","相应","chaincode","支持","到","链","对","对于","思路","其他"," ","实现","hyperchain","plugin","合约","你","fabric","一定","可以","一步","和","跨链","进行","如果","具体","如下","有","根据","区块","、","设计","接入","需要","我们","现在","编写","。","新","自行","的","私链","提供","可","开发","样例","以太","版本","bcos","想要","，","平台","按照","中","改造","：","是","参考","管理","应用","solidity","进一步","业务","功能","evm"],"title":"具体实现","title_tokens":["实现","具体"]},{"location":"bitxhub/dev/cross_contract/#hyperchainbcosevm","text":"本节主要说明在支持EVM合约的应用链上，如何使用我们提供的跨链管理合约Broker，在你已有的Solidity业务合约的基础上添加接口，以获得跨链能力。 当然不同的区块链可能在以太坊的EVM上做了一些二次开发和新增功能，请根据具体区块链的文档相应修改代码。","text_tokens":["新增","broker","坊","接口","说明","可能","代码","支持","相应","节","上","做","在","链"," ","请","合约","你","本","和","跨链","链上","具体","能力","主要","已有","区块","根据","一些","我们","。","获得","文档","的","提供","开发","基础","如何","以","以太","，","修改","当然","不同","使用","二次","应用","管理","solidity","了","二次开发","添加","业务","功能","evm"],"title":"Hyperchain、以太坊、BCOS上的EVM合约","title_tokens":["坊","hyperchain","合约","的","上","evm","、","以太","bcos"]},{"location":"bitxhub/dev/cross_contract/#demo","text":"假设你已经有了一个简单的KV存储的业务合约，代码如下： pragma solidity >= 0.5.7 ; contract DataSwapper { mapping ( string => string ) dataM ; // map for accounts // 数据交换类的业务合约 function getData ( string memory key ) public returns ( string memory ) { return dataM [ key ]; } function setData ( string memory key , string memory value ) public { dataM [ key ] = value ; } } 现在你想在这个合约的基础上增加一个跨链获取数据的功能，如果使用我们的跨链管理合约提供的接口，很简单的增加几个接口就可以了。","text_tokens":["getdata","return","public","类","已经","一个","代码","pragma",">","memory",",","想","接口","for","contract","上","假设","在","mapping","就","string","["," ","setdata","]","returns","}","合约","你",")","accounts","dataswapper","获取数据","跨链","0.5","如下","如果","datam","可以","有","=",".","/","(","存储","现在","我们","kv","。","key","7","的","map","value","这个","交换","基础","功能","提供","数据交换","几个","，","简单",";","增加","很","：","使用","了","solidity","function","管理","业务","获取","{","数据"],"title":"业务合约Demo","title_tokens":["demo","业务","合约"]},{"location":"bitxhub/dev/cross_contract/#_5","text":"contract DataSwapper { // broker合约地址 address BrokerAddr = 0x2346f3BA3F0B6676aa711595daB8A27d0317DB57 ; Broker broker = Broker ( BrokerAddr ); ... function get ( address destChainID , string memory destAddr , string memory key ) public { broker . emitInterchainEvent ( destChainID , destAddr , \"interchainGet,interchainSet,\" , key , key , \"\" ); } } contract Broker { function emitInterchainEvent ( address destChainID , string memory destAddr , string memory funcs , string memory args , string memory argscb , string memory argsrb ) public ; } 其中Broker的地址和该业务合约需要使用到的接口需要在业务合约中声明，然后直接调用该接口发起跨链交易。","text_tokens":["broker","public","argsrb",",","memory","其中","接口","直接","contract","emitinterchainevent","到","在","args","\"","destaddr","string"," ","get","调用","brokeraddr","funcs","interchainget","}","合约",")","dataswapper","和","跨链",".","=","/","(","interchainset","需要","。","key","的","交易","...","destchainid","，","发起",";","声明","使用","中","argscb","地址","然后","function","0x2346f3ba3f0b6676aa711595dab8a27d0317db57","address","业务","该","{"],"title":"发起跨链数据交换的接口","title_tokens":["发起","接口","跨链","的","交换","数据交换","数据"]},{"location":"bitxhub/dev/cross_contract/#_6","text":"contract DataSwapper { ... modifier onlyBroker { require ( msg.sender == BrokerAddr , \"Invoker are not the Broker\" ); _ ; } function interchainGet ( string memory key ) public onlyBroker returns ( bool , string memory ) { return ( true , dataM [ key ]); } } 我们规定跨链调用的接口的第一个返回值类型必须是bool类型，它用来表示跨链调用是否成功。 其中onlyBroker是进行跨链权限控制的修饰器。该接口和下面的跨链回写接口均是提供给Broker合约进行调用，也是其他应用链发来的跨链交易执行时需要调用的接口。","text_tokens":["broker","其他","[","用来","true","]","}","合约","dataswapper","onlybroker","(","是否","给","modifier","_","...","类型","是","成功","return","public","msg","brokeraddr","控制","=","。","的","the","下面","交易","回写","规定","第一个",",","接口","一个","contract","链","bool","\"","返回","调用","返回值","returns",")","进行",".","第一","are","提供","require",";","发来","function","其中","memory","均","sender","invoker","string"," ","修饰","not","interchainget","它","器","和","跨链","datam","执行","也","必须","时","我们","需要","权限","key","，","应用","表示","该","{"],"title":"跨链获取的接口","title_tokens":["接口","跨链","获取","的"]},{"location":"bitxhub/dev/cross_contract/#_7","text":"contract DataSwapper { ... function interchainSet ( string memory key , string memory value ) public onlyBroker { setData ( key , value ); } ... }","text_tokens":["public","memory",",","contract","string"," ","setdata","}",")","dataswapper","onlybroker","(","interchainset","key","value","...",";","function","{"],"title":"跨链回写的接口","title_tokens":["回写","跨链","接口","的"]},{"location":"bitxhub/dev/cross_contract/#fabric","text":"本节主要说明在Fabric应用链上，如何使用我们提供的跨链管理合约Broker，在你已有业务合约的基础上添加接口，以获得跨链能力。","text_tokens":["broker","接口","说明","节","上","在","合约","你","fabric","本","跨链","链上","能力","主要","已有","我们","。","获得","的","提供","基础","如何","以","，","使用","应用","管理","添加","业务"],"title":"Fabric","title_tokens":["fabric"]},{"location":"bitxhub/dev/cross_contract/#demo_1","text":"假设你已经有了一个简单的KV存储的业务合约，代码如下： type KVStore struct {} func ( s * KVStore ) Init ( stub shim . ChaincodeStubInterface ) peer . Response { return shim . Success ( nil ) } func ( s * KVStore ) Invoke ( stub shim . ChaincodeStubInterface ) peer . Response { function , args := stub . GetFunctionAndParameters () fmt . Printf ( \"invoke: %s\\n\" , function ) switch function { case \"get\" : return s . get ( stub , args ) case \"set\" : return s . set ( stub , args ) default : return shim . Error ( \"invalid function: \" + function + \", args: \" + strings . Join ( args , \",\" )) } } func ( s * KVStore ) get ( stub shim . ChaincodeStubInterface , args [] string ) peer . Response { // args[0]: key value , err := stub . GetState ( args [ 0 ]) if err != nil { return shim . Error ( err . Error ()) } return shim . Success ( value ) } // get is business function which will invoke the to,tid,id func ( s * KVStore ) set ( stub shim . ChaincodeStubInterface , args [] string ) peer . Response { if len ( args ) != 2 { return shim . Error ( \"incorrect number of arguments\" ) } err := stub . PutState ( args [ 0 ], [] byte ( args [ 1 ])) if err != nil { return shim . Error ( err . Error ()) } return shim . Success ( nil ) } func main () { err := shim . Start ( new ( KVStore )) if err != nil { fmt . Printf ( \"Error starting chaincode: %s\" , err ) } } 现在你想在这个合约的基础上增加一个跨链获取数据的功能，如果使用我们的跨链管理合约提供的接口，很简单的增加几个接口就可以了。","text_tokens":["tid","上","[","get","id","]","!","}","合约","to","如果","starting","is","(","chaincodestubinterface","kv","%","几个","new","getfunctionandparameters","type","简单","：","error","strings","n","获取","return",":","假设","在","struct","0","case","arguments","init","有","kvstore","=","s","if","/","存储","len","现在","printf","。","set","peer","invalid","的","value","join","the","default","使用","main","func","nil","of",",","已经","一个","response","想","接口","\"","invoke","你","+",")","获取数据","如下",".","shim","err","will","number","提供","byte","基础","putstate","*","增加","\\","2","function","incorrect","功能","start","fmt","代码","switch","chaincode","1","args","string"," ","which","可以","跨链","我们","success","business","key","这个","getstate","stub","，","很","了","管理","业务","就","{","数据"],"title":"业务合约Demo","title_tokens":["demo","业务","合约"]},{"location":"bitxhub/dev/cross_contract/#_8","text":"为了方便用户使用，我们在原来获取数据的接口基础上增加这个功能： const ( channelID = \"mychannel\" brokerContractName = \"broker\" emitInterchainEventFunc = \"EmitInterchainEvent\" ) func ( s * KVStore ) get ( stub shim . ChaincodeStubInterface , args [] string ) peer . Response { switch len ( args ) { case 1 : // args[0]: key value , err := stub . GetState ( args [ 0 ]) if err != nil { return shim . Error ( err . Error ()) } return shim . Success ( value ) case 3 : // args[0]: destination appchain id // args[1]: destination contract address // args[2]: key b := util . ToChaincodeArgs ( emitInterchainEventFunc , args [ 0 ], args [ 1 ], \"interchainGet\" , args [ 2 ], \"interchainSet\" , args [ 2 ], \"\" , \"\" ) response := stub . InvokeChaincode ( brokerContractName , b , channelID ) if response . Status != shim . OK { return shim . Error ( fmt . Errorf ( \"invoke broker chaincode %s error: %s\" , brokerContractName , response . Message ). Error ()) } return shim . Success ( nil ) default : return shim . Error ( \"incorrect number of arguments\" ) } } 由于我们的跨链管理合约一旦部署之后，chaincode name和所在的channel和跨链接口都是不变的，所以在业务变量中直接使用常量指定Broker合约的相关信息。 b := util . ToChaincodeArgs ( emitInterchainEventFunc , args [ 0 ], args [ 1 ], \"interchainGet\" , args [ 2 ], \"interchainSet\" , args [ 2 ], \"\" , \"\" ) response := stub . InvokeChaincode ( brokerContractName , b , channelID ) 这两行代码调用了我们的跨链管理合约，只需要提供参数：目的链ID，目的链上业务合约的地址，跨链调用函数，跨链调用函数参数，回调函数，回调函数参数，最后两个参数为回滚函数和回滚函数参数，因为该场景下即使目的链执行跨链交易失败，来源链也无需回滚，因此无需提供回滚信息。","text_tokens":["目的","broker","这","常量","上","信息","为","部署","[","用户","get","id","无需","]","!","}","合约","{","一旦","ok","不变","场景","(","chaincodestubinterface","const","invokechaincode","%","因为","失败","tochaincodeargs","：","是","error","两行","message","所以","address","所在","mychannel","获取","return",":","因此","errorf","即使","只","channelid","在","指定","0","链接","case","arguments","口","相关","链上","=","kvstore","s","if","/","回滚","len","。","peer","的","value","交易","调用函数","default","为了","使用","参数","变量","name","func","nil","of","appchain",",","接口","response","contract","emitinterchainevent","链","\"","invoke","调用","emitinterchaineventfunc","获取数据",")","status",".","方便","shim","函数参数","interchainset","err","跨","都","util","number","提供","基础","两个","*","增加","中","2","下","incorrect","回调","功能","brokercontractname","b","fmt","代码","switch","chaincode","直接","args","string"," ","原来","3","函数","interchainget","最后","和","跨链","由于","之后","执行","也","需要","我们","success","channel","key","这个","getstate","stub","destination","，","地址","来源","管理","了","业务","该","1","数据"],"title":"发起跨链数据交换的接口","title_tokens":["发起","接口","跨链","的","交换","数据交换","数据"]},{"location":"bitxhub/dev/cross_contract/#_9","text":"func ( s * KVStore ) interchainGet ( stub shim . ChaincodeStubInterface , args [] string ) peer . Response { if len ( args ) != 1 { return shim . Error ( \"incorrect number of arguments\" ) } value , err := stub . GetState ( args [ 0 ]) if err != nil { return shim . Error ( err . Error ()) } return shim . Success ( value ) } interchainGet 接收参数 key ，在本合约中查询该 Key 值对应的 value ，并返回。该接口提供给 Broker 合约进行跨链获取数据的调用。","text_tokens":["return","func","of","nil","broker",":",",","接口","response","值","1","在","args","\"","string","["," ","返回","调用","0","]","!","interchainget","}","合约","本",")","arguments","并","进行","跨链","获取数据",".","kvstore","=","s","if","shim","(","chaincodestubinterface","len","查询","err","接收","。","success","给","key","获取","peer","number","的","value","提供","getstate","stub","*","，","对应","中","参数","error","incorrect","该","{","数据"],"title":"跨链获取的接口","title_tokens":["接口","跨链","获取","的"]},{"location":"bitxhub/dev/cross_contract/#_10","text":"func ( s * KVStore ) interchainSet ( stub shim . ChaincodeStubInterface , args [] string ) peer . Response { if len ( args ) != 2 { return shim . Error ( \"incorrect number of arguments\" ) } err := stub . PutState ( args [ 0 ], [] byte ( args [ 1 ])) if err != nil { return shim . Error ( err . Error ()) } return shim . Success ( nil ) } interchainSet 接收参数 key ，在本合约中设置 Key 值对应的 value 。该接口提供给 Broker 合约回写跨链获取数据的时候进行调用。","text_tokens":["return","func","of","nil","broker",":",",","接口","response","值","1","在","args","\"","string","["," ","调用","0","]","!","}","合约","本",")","arguments","获取数据","进行","跨链",".","kvstore","=","s","if","shim","(","chaincodestubinterface","len","interchainset","err","接收","。","success","给","key","获取","peer","number","的","value","提供","byte","stub","putstate","时候","*","，","对应","中","参数","2","error","回写","incorrect","数据","该","{","设置"],"title":"跨链回写的接口","title_tokens":["回写","跨链","接口","的"]},{"location":"bitxhub/dev/cross_contract/#_11","text":"跨链场景 ：以以太坊为例，位于A链的账户Alice向位于B链的Bob发起转账交易。 在应用链部署broker合约与业务合约，具体部署流程参考 部署跨链合约 。 调用 register 方法注册业务合约。入参为需要进行跨链的业务合约地址。 调用 audit 对已经注册的业务合约进行审核，status为1说明审核通过。 transfer 业务合约调用 setBalance 方法初始化账户。 transfer 业务合约调用 transfer 方法发起跨链交易。 1.1 appchainA deploy ==> brokerA addr：0xFb23Af09e3E8D83fd5575De9558920Bf351F05E8 businessA addr: 0x5bFe03Dbd09817d4957693f672cc31A133Bb6084 1.2 appchainB deploy ==> brokerB addr：0xC8C086200f92c9226b42079eCB3137eFc8752801 businessB addr: 0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f 2.1 brokerA register ==> addr：0x5bFe03Dbd09817d4957693f672cc31A133Bb6084 //部署的业务合约地址 2.2 brokerB register ==> addr：0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f //部署的业务合约地址 3.1 brokerA audit ==> addr：0x5bFe03Dbd09817d4957693f672cc31A133Bb6084 status: 1 3.2 brokeB audit ==> addr：0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f status: 1 4.1 transferA setBalance ==> id: Alice amount: 100 4.2 transfeB setBalance ==> id: Bob amount: 0 // destChainID为B链的PierID，可在终端通过pier --repo <appchainB_config_path> id获取 // destAddr为B链的业务合约地址 5 transferA transfer ==> destChainID: 0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1 destAddr: 0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f sender: Alice receiver: Bob amount: 10 观察跨链网关与中继链日志 # 网关pierA同步以太坊区块头并处理跨链交易，发送至中继链 INFO[21:54:30.559] Persist block header height=18 module=bxh_lite WARN[21:54:30.560] query header: header at 18 not found module=syncer INFO[21:54:32.568] Handle interchain tx wrapper count=0 height=18 index=0 module=syncer WARN[21:54:38.401] query header: header at 19 not found module=syncer INFO[21:54:38.401] Persist block header height=19 module=bxh_lite INFO[21:54:40.404] Handle interchain tx wrapper count=1 height=19 index=0 module=syncer INFO[21:54:40.409] Apply tx from=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb id=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-2 index=2 module=executor status=true type=RECEIPT_SUCCESS 2021-12-01T21:54:40.413+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:40.412+0800 [INFO ] client: submit ibtp: id=0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-2 contract=0x5bFe03Dbd09817d4957693f672cc31A133Bb6084 func= 2021-12-01T21:54:40.413+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:40.413+0800 [INFO ] client: arg: 0= 2021-12-01T21:54:40.413+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:40.413+0800 [INFO ] client: InvokeIndexUpdate: ibtp=0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-2 # 中继链将收到的跨链交易上链，并路由到网关PierB time=\"2021-12-01T21:54:30.420\" level=info msg=\"======== Replica 1 call execute, height=18\" module=order time=\"2021-12-01T21:54:30.430\" level=info msg=\"Generated block\" count=1 height=18 module=app time=\"2021-12-01T21:54:30.554\" level=info msg=\"Persisted block\" count=1 elapse=8.963884ms hash=0x4474C7a5db7049Da22cEB82324988f572e57Ba88926D4D8549110c433bAD01de height=18 module=executor # 网关PierB同步区块头并处理跨链交易，将回执类型跨链交易返回给中继链 INFO[21:54:30.565] Persist block header height=18 module=bxh_lite WARN[21:54:30.567] query header: header at 18 not found module=syncer INFO[21:54:32.568] Handle interchain tx wrapper count=1 height=18 index=0 module=syncer INFO[21:54:32.568] Apply tx from=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb id=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-2 index=2 module=executor status=true type=INTERCHAIN 2021-12-01T21:54:32.594+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:32.591+0800 [INFO ] client: submit ibtp: id=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-2 contract=0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f func=interchainCharge 2021-12-01T21:54:32.594+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:32.593+0800 [INFO ] client: arg: 0=A 2021-12-01T21:54:32.594+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:32.593+0800 [INFO ] client: arg: 1=B 2021-12-01T21:54:32.594+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:32.593+0800 [INFO ] client: arg: 2=10 2021-12-01T21:54:37.810+0800 [DEBUG] plugin.sh: 2021-12-01T21:54:37.810+0800 [INFO ] client: log: index=0 data=0x0000000000000000000000000000000000000000000000000000000000000001 INFO[21:54:37.813] Handle ibtp success id=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-2 module=exchanger type=INTERCHAIN INFO[21:54:38.381] Persist block header height=19 module=bxh_lite WARN[21:54:38.381] query header: header at 19 not found module=syncer INFO[21:54:40.384] Handle interchain tx wrapper count=0 height=19 index=0 module=syncer # 中继链将收到的回执类型的跨链交易上链，返回至网关PierA time=\"2021-12-01T21:54:38.311\" level=info msg=\"======== Replica 1 call execute, height=19\" module=order time=\"2021-12-01T21:54:38.312\" level=info msg=\"Generated block\" count=1 height=19 module=app time=\"2021-12-01T21:54:38.399\" level=info msg=\"Persisted block\" count=1 elapse=6.881ms hash=0xf676406e6f88FC0cF27b043e926e1e4a528E6Ee5ed62146e86D18F3ABA68D260 height=19 module=executor # 网关PierA收到跨链交易回执，返回给应用链A INFO[21:54:45.568] Execute callback fields.msg= index=2 module=executor status=true type=RECEIPT_SUCCESS INFO[21:54:45.569] Handle ibtp receipt success id=0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-2 module=exchanger type=RECEIPT_SUCCESS # 跨链交易完成，在应用链A上查询Alice的余额从100变更为90；在应用链B上查询Bob的余额从0变更为10","text_tokens":["30.420","index","broker","参为","说明","time","0xff8199fae48c808b45667da0ccaaee839b1a10cb","elapse","arg","2.1","上","到","businessb","为","alice","部署","deploy","[","register","id","40.404","流程","]","executor","true","plugin","30.554","30.559","合约","处理","；","0x4474c7a5db7049da22ceb82324988f572e57ba88926d4d8549110c433bad01de","通过","generated","具体","日志","data","38.381","区块","位于","38.401","debug","场景","40.412","30.565","40.413","转账","receipt","给","appchaina","中继","至","4.2","以","_","5","类型","type","at","30.430","replica","入","：","37.810","brokera","header","brokeb","interchaincharge","获取","并","2021","将",":","setbalance","在","sh","interchain","transfer","msg","40.384","1.1","3.2","0","0x0000000000000000000000000000000000000000000000000000000000000001","30.560","log","from","回执","32.591","40.409","fields","=","38.311","/","tx","piera","0xfb23af09e3e8d83fd5575de9558920bf351f05e8","。","syncer","#","的","与","8.963884","可","0xf676406e6f88fc0cf27b043e926e1e4a528e6ee5ed62146e86d18f3aba68d260","交易","brokerb","destchainid","<","余额","32.594","submit","送至","module","transfeb","pier","persist","query","从","func","坊",",","已经","audit","4.1",">","38.399","businessa","contract","info","完成","链","审核","\"","destaddr","10","warn","返回","38.312","0800","调用","0x5bfe03dbd09817d4957693f672cc31a133bb6084","receiver","lite","+","进行","status","repo","height","bob","callback","45.569",".","exchanger","pierid","count","查询","persisted","addr","发送至","hash","变更","amount","头","app","appchainb","0xa5dd12e27ee5e79ce0b50adb376414351c8eea5f","config","30.567","发起","45.568","0xc8c086200f92c9226b42079ecb3137efc8752801","transfera","block","2","37.813","终端","order","为例","注册","--","b","12","ms","bxh","1.2","handle","收到","wrapper","-","client","call","sender","对","apply","ibtp","发送","19"," ","not","pierb","invokeindexupdate","路由","90","跨链","found","execute","54","100","初始","21","需要","32.593","success","01t21","0x23fb0e7ef676467563d37d820f1b1fddb0f9a2e1","path","level","方法","a","2.2","以太","同步","3.1","32.568","，","网关","18","向","地址","参考","应用","初始化","6.881","观察","业务","1","账户"],"title":"使用示例","title_tokens":["示例","使用"]},{"location":"bitxhub/dev/cross_contract/#_12","text":"经过上面的改造，你的业务合约已经具备跨链获取数据的功能了，完整的代码可以参考 这里","text_tokens":["已经","代码"," ","具备","合约","你","获取数据","可以","经过","跨链","获取","的","完整","上面","，","改造","参考","了","这里","业务","功能","数据"],"title":"总结","title_tokens":["总结"]},{"location":"bitxhub/dev/multiSDK/","text":"","text_tokens":[],"title":"multiSDK","title_tokens":["multisdk"]},{"location":"bitxhub/dev/plugin/","text":"应用链插件编写 在本教程中，你将构建一个完整功能的 Plugin。过程中能学习基本的概念和具体使用细节。该示例将展示如何快速、轻松地接入自己的区块链到跨链平台中来。 如果你需要接入自己开发的区块链到BitXHub跨链平台来的话，可以根据你们自己的区块链来定制开发Plugin，通过跨链网关来加入到跨链平台。 开发要求 安装 go1.13+ 设置好$GOPATH等环境 教程章节 重要概念 Plugin接口 程序目标 开始编写程序 编译你的Plugin 重要概念 在解释具体的接口之前，先明确几个概念： 跨链请求 ：如果有两条区块链A和B，A链需要向B链发起任何操作，需要按照IBTP规则向中继链发出一个请求包，我们称之为跨链请求A->B。 IBTP包 ：满足IBTP的一个package，跨链请求都需要通过IBTP包进行。 来源链 ：在跨链请求A->B中，A即为来源链。 目的链 ：在跨链请求A->B中，B即为目的链。 Plugin接口 为了更加便捷的开发Plugin接入到Pier中来，我们规定了下面一些必要的接口。 type Client interface { // 初始化Plugin服务 Initialize ( configPath string , pierID string , extra [] byte ) error // 启动Plugin服务的接口 Start () error // 停止Plugin服务的接口 Stop () error // Plugin负责将区块链上产生的跨链事件转化为标准的IBTP格式，Pier通过GetIBTP接口获取跨链请求再进行处理 GetIBTP () chan * pb . IBTP // Plugin 负责执行来源链过来的跨链请求，Pier调用SubmitIBTP提交收到的跨链请求。 SubmitIBTP ( * pb . IBTP ) ( * pb . SubmitIBTPResponse , error ) // GetOutMessage 负责在跨链合约中查询历史跨链请求。查询键值中to指定目的链，idx指定序号，查询结果为以Plugin负责的区块链作为来源链的跨链请求。 GetOutMessage ( to string , idx uint64 ) ( * pb . IBTP , error ) // GetInMessage 负责在跨链合约中查询历史跨链请求。查询键值中from指定来源链，idx指定序号，查询结果为以Plugin负责的区块链作为目的链的跨链请求。 GetInMessage ( from string , idx uint64 ) ([][] byte , error ) // GetInMeta 是获取跨链请求相关的Meta信息的接口。以Plugin负责的区块链为目的链的一系列跨链请求的序号信息。如果Plugin负责A链，则可能有多条链和A进行跨链，如B->A:3; C->A:5。返回的map中，key值为来源链ID，value对应该来源链已发送的最新的跨链请求的序号，如{B:3, C:5}。 GetInMeta () ( map [ string ] uint64 , error ) // GetOutMeta 是获取跨链请求相关的Meta信息的接口。以Plugin负责的区块链为来源链的一系列跨链请求的序号信息。如果Plugin负责A链，则A可能和多条链进行跨链，如A->B:3; A->C:5。返回的map中，key值为目的链ID，value对应已发送到该目的链的最新跨链请求的序号，如{B:3, C:5}。 GetOutMeta () ( map [ string ] uint64 , error ) // GetCallbackMeta 是获取跨链请求相关的Meta信息的接口。以Plugin负责的区块链为来源链的一系列跨链请求的序号信息。如果Plugin负责A链，则A可能和多条链进行跨链，如A->B:3; A->C:5；同时由于跨链请求中支持回调操作，即A->B->A为一次完整的跨链操作，我们需要记录回调请求的序号信息，如A->B->:2; A->C—>A:4。返回的map中，key值为目的链ID，value对应到该目的链最新的带回调跨链请求的序号，如{B:2, C:4}。（注意 CallbackMeta序号可能和outMeta是不一致的，这是由于由A发出的跨链请求部分是没有回调的） GetCallbackMeta () ( map [ string ] uint64 , error ) // CommitCallback 执行完IBTP包之后进行一些回调操作。 CommitCallback ( ibtp * pb . IBTP ) error // GetReceipt 获取一个已被执行IBTP的回执 GetReceipt ( ibtp * pb . IBTP ) ( * pb . IBTP , error ) // Name 描述Plugin负责的区块链的自定义名称，一般和业务相关，如司法链等。 Name () string // Type 描述Plugin负责的区块链类型，比如Fabric Type () string } 程序目的 本教程以开发一个简单的连接Fabric区块链网络的Plugin为例，最终的程序能够实现从负责的区块链获取 Hello World 信息并返回到跨链平台中。 开始编写你的程序 首先选择你的工程目录，按照正常的GO程序的流程建立项目 $ go version // 确认你安装的GO版本 $ mkdir ${ YOUR_PROJECT } $ cd ${ YOUR_PROJECT } $ go mod init exmple/fabric-plugin Client对象 首先创建一个 client.go 文件，这个文件是Plugin的核心和入口。 在该文件中，应该定义你的Plugin如何获取client 实例，以及如何启动和停止Plugin服务。 现在我们需要创建一个自定义的Client 结构，跨链网关最终拿到的应该是这个结构的一个实例，先来看看这个结构中都需要什么。 首先来看看 Client自定义 具体结构 type Client struct { meta * ContractMeta consumer * Consumer eventC chan * pb . IBTP pierId string name string } type ContractMeta struct { EventFilter string `json:\"event_filter\"` Username string `json:\"username\"` CCID string `json:\"ccid\"` ChannelID string `json:\"channel_id\"` ORG string `json:\"org\"` } meta：Plugin直接和跨链合约交互，需要保存你的合约的一些基础信息。由于我们需要连接一个Fabric网络，这些Meta信息包括 Fabric中跨链事件的名称、Fabric中的用户名称、Chaincode合约的名称、你的组织名称Org以及组织所在的channel。 consumer：可以理解为Fabric上跨链事件的“监听器”，这个监听器也是一个自定义的结构，具体的结构在后面会详细介绍。 eventC：为跨链网关提供读取监听到的跨链事件的通道。 name：自定的区块链的名称。 pierId：跨链网关注册在跨链平台中后产生的唯一ID，作为应用链的标识。 然后应该提供一个Client的实例化的接口（类似于构造函数），具体代码如下： func ( c * Client ) Initialize ( configPath , pierId string , extra [] byte ) error { eventC := make ( chan * pb . IBTP ) // read config from files fabricConfig , err := UnmarshalConfig ( configPath ) if err != nil { return nil , fmt . Errorf ( \"unmarshal config for plugin :%w\" , err ) } // some basic configs about your chaincode contractmeta := & ContractMeta { EventFilter : fabricConfig . EventFilter , Username : fabricConfig . Username , CCID : fabricConfig . CCID , ChannelID : fabricConfig . ChannelId , ORG : fabricConfig . Org , } // handler for listening on inter-chain events posted on your Fabric mgh , err := newFabricHandler ( contractmeta . EventFilter , eventC , pierId ) if err != nil { return err } done := make ( chan bool ) csm , err := NewConsumer ( configPath , contractmeta , mgh , done ) if err != nil { return err } c . consumer = csm c . eventC = eventC c . meta = contractmeta c . pierId = pierId c . name = fabricConfig . Name c . outMeta = m c . ticker = time . NewTicker ( 2 * time . Second ) c . done = done return nil } consumer consumer 负责监听区块链上的由跨链合约抛出的跨链事件以及和调用chaincode。 我们新建 ./consumer.go 文件 type Consumer struct { eventClient * event . Client meta * ContractMeta msgH MessageHandler channelProvider context . ChannelProvider ChannelClient * channel . Client registration fab . Registration ctx chan bool } eventClient：fabric gosdk提供的事件Client meta Fabric：相关的参数信息 msgH：事件handler，在监听到指定事件之后负责处理的函数 channelProvider：fabric gosdk提供的和chaincode交互 ChannelClient：fabric gosdk 提供的和调用chaincode的对象 registeration：fabric gosdk 提供的订阅特定事件的对象 ctx：用来结束consumer的goroutine Event 由于在Fabric上抛出的事件内容是可以自定义的，而跨链请求要在跨链平台上传递的话，需要使用IBTP包，所以我们需要一定的代码来执行这种转换。 我们新建 ./event.go 文件 type Event struct { Index uint64 `json:\"index\"` DstChainID string `json:\"dst_chain_id\"` SrcContractID string `json:\"src_contract_id\"` DstContractID string `json:\"dst_contract_id\"` Func string `json:\"func\"` Args string `json:\"args\"` Argscb string `json:\"argscb\"` Rollback string `json:\"rollback\"` Argsrb string `json:\"argsrb\"` Callback string `json:\"callback\"` Proof [] byte `json:\"proof\"` Extra [] byte `json:\"extra\"` } Event结构也是自定义的，需要和在你的跨链合约中抛出的事件结构一致。一个跨链交易事件，一般来说需要指定目标应用链的ID DstChainID ，目标应用链上智能合约的地址或者ID（Fabric上的chaincode没有合约地址） DstContractID ，这次跨链交易的发起者的合约地址 SrcContractID ，跨链调用的函数名 Func ，该函数的参数 Args ，是否有跨链调用之后要执行的回调函数 Callback ，为了该应用链上对于该事件的证明 Proof ，用户可自定义的部分 Extra 。 读取配置 Plugin的配置文件路径是通过Initialize的方法动态传入的，这意味着你可以方便的修改关于你的区块链的参数信息。我们新建文件 ./config.go 文件，负责配置读取的所有操作。 这里使用的是 github.com/spf13/viper 库和TOML文件作为配置，当然你也可以使用任何你熟悉的工具来读取配置。 package main import ( \"path/filepath\" \"strings\" \"github.com/spf13/viper\" ) const ( ConfigName = \"fabric.toml\" ) type Fabric struct { Addr string `toml:\"addr\" json:\"addr\"` Name string `toml:\"name\" json:\"name\"` EventFilter string `mapstructure:\"event_filter\" toml:\"event_filter\" json:\"event_filter\"` Username string `toml:\"username\" json:\"username\"` CCID string `toml:\"ccid\" json:\"ccid\"` ChannelId string `mapstructure:\"channel_id\" toml:\"channel_id\" json:\"channel_id\"` Org string `toml:\"org\" json:\"org\"` } func DefaultConfig () * Fabric { return & Fabric { Addr : \"localhost:10053\" , Name : \"fabric\" , EventFilter : \"CrosschainEventName\" , Username : \"Admin\" , CCID : \"Broker-001\" , ChannelId : \"mychannel\" , Org : \"org2\" , } } func UnmarshalConfig ( configPath string ) ( * Fabric , error ) { viper . SetConfigFile ( filepath . Join ( configPath , ConfigName )) viper . SetConfigType ( \"toml\" ) viper . AutomaticEnv () viper . SetEnvPrefix ( \"FABRIC\" ) replacer := strings . NewReplacer ( \".\" , \"_\" ) viper . SetEnvKeyReplacer ( replacer ) if err := viper . ReadInConfig (); err != nil { return nil , err } config := DefaultConfig () if err := viper . Unmarshal ( config ); err != nil { return nil , err } return config , nil } SubmitIBTP 该接口主要负责将其他链发送过来的IBTP包解析并构造成当前目的链的交易，发送到目的链的跨链合约中。 如果来源链要求将本链调用合约的结果返回的话，还需要构造相应的IBTP回执发回来源链。 func ( c * Client ) SubmitIBTP ( ibtp * pb . IBTP ) ( * pb . SubmitIBTPResponse , error ) { pd := & pb . Payload {} ret := & pb . SubmitIBTPResponse {} if err := pd . Unmarshal ( ibtp . Payload ); err != nil { return ret , fmt . Errorf ( \"ibtp payload unmarshal: %w\" , err ) } content := & pb . Content {} if err := content . Unmarshal ( pd . Content ); err != nil { return ret , fmt . Errorf ( \"ibtp content unmarshal: %w\" , err ) } if ibtp . Category () == pb . IBTP_UNKNOWN { return nil , fmt . Errorf ( \"invalid ibtp category\" ) } logger . Info ( \"submit ibtp\" , \"id\" , ibtp . ID (), \"contract\" , content . DstContractId , \"func\" , content . Func ) for i , arg := range content . Args { logger . Info ( \"arg\" , strconv . Itoa ( i ), string ( arg )) } if ibtp . Category () == pb . IBTP_RESPONSE && content . Func == \"\" { logger . Info ( \"InvokeIndexUpdate\" , \"ibtp\" , ibtp . ID ()) _ , resp , err := c . InvokeIndexUpdate ( ibtp . From , ibtp . Index , ibtp . Category ()) if err != nil { return nil , err } ret . Status = resp . OK ret . Message = resp . Message return ret , nil } var result [][] byte var chResp * channel . Response callFunc := CallFunc { Func : content . Func , Args : content . Args , } bizData , err := json . Marshal ( callFunc ) if err != nil { ret . Status = false ret . Message = fmt . Sprintf ( \"marshal ibtp %s func %s and args: %s\" , ibtp . ID (), callFunc . Func , err . Error ()) res , _ , err := c . InvokeIndexUpdate ( ibtp . From , ibtp . Index , ibtp . Category ()) if err != nil { return nil , err } chResp = res } else { res , resp , err := c . InvokeInterchain ( ibtp . From , ibtp . Index , content . DstContractId , ibtp . Category (), bizData ) if err != nil { return nil , fmt . Errorf ( \"invoke interchain for ibtp %s to call %s: %w\" , ibtp . ID (), content . Func , err ) } ret . Status = resp . OK ret . Message = resp . Message // if there is callback function, parse returned value result = util . ToChaincodeArgs ( strings . Split ( string ( resp . Data ), \",\" ) ... ) chResp = res } // If is response IBTP, then simply return if ibtp . Category () == pb . IBTP_RESPONSE { return ret , nil } proof , err := c . getProof ( * chResp ) if err != nil { return ret , err } ret . Result , err = c . generateCallback ( ibtp , result , proof , ret . Status ) if err != nil { return nil , err } return ret , nil } 编译你的Plugin 我们采用GO语言提供的插件模式，实现Pier对于你编写的Plugin的动态加载。 MacOS和Linux平台： 运行下面的命令，能够得到 your_plugin.so 文件。 $ cd ${ YOUR_PROJECT_PATH } $ go build --buildmode = plugin -o your_plugin.so ./*.go 将你编写的动态链接文件，放到Pier配置文件夹下，配合我们提供的Pier，就能接入到跨链平台来。","text_tokens":["go1.13","mgh","then","o","关于","章节","信息","上","为","不","比如","包","合约","处理","如果","$","区块","轻松","%","满足","中继","以","_","inter","newconsumer","tochaincodeargs","被","ccid","所以","srccontractid","并","理解","return","一般","argsrb","操作","读取","channelid","“","配合","mkdir","链接","回执","handler","=","on","成","参数信息","现在","。","停止","值中","invalid","启动","newreplacer","可","submit","解释","链为","newfabrichandler","或者","已","开始","库",",","能够","编译","好","接口","再","automaticenv","callbackmeta","linux","返回","invoke","your","产生","events","import","dstchainid","开发","发起","插件",";","mapstructure","采用","中","channelprovider","意味","运行","设置","start","确认","com","以及","call","client","-","chaincode","对","hello","bitxhub","string"," ","3","更加","unmarshalconfig","和","gosdk","之后","org","macos","你们","完","logger","执行","src","marshal","key","一般来说","构造","filepath","自己","（","保存","业务","&&","这种","index","broker","这","rollback","channelclient","到","[","用户","用来","流程","exmple","plugin","registration","data","eventclient","ok","contractmeta","请求","：","定制","是","作为","message","明确","这里","strings","一致","mychannel","发送到","context",":","工具","commitcallback","编写程序","规则","strconv","callfunc","在","interchain","struct","指定","from","加入","类似","注意","定义","中后","一些","的","没有","join","交易","csm","setenvprefix","则","对应","为了","使用","先","argscb","而","name","同时","nil","文件夹","stop","posted","一个","response",">","for","info","实现","调用","后面","initialize","+","本","done","registeration","过程","configs","接入","包括","about","由","发出","连接","当前","最新","命令","config","首先","路径","basic","内容","特定","回调","replacer","github","负责","go","解析","配置","outmeta","抛出","这次","getproof","some","带回","cd","so","记录","还","mod","也","来说","proof","方法","项目","这个","a","修改","然后","转化","向","地址","初始化","read","看看","工程","msgh","getoutmessage","重要","可能","唯一","time","setconfigtype","dst","arg","创建","其他","id","!","如","to","事件","具体","is","选择","什么","json","来","是否","名称","几个","version","称之为","类型","event","简单","目标","getinmeta","error","bizdata","所在","）","获取","viper","setconfigfile","会","即","司法","m","”","spf13","程序","对象","对于","之前","传递","pd","建立","listening","描述","init","链上","w","这是","generatecallback","getinmessage","/","res","监听","化","chan","送到","category","通道","value","下面","展示","range","传入","之为","pier","getoutmeta","func","介绍","必要","crosschaineventname","submitibtp","中来","支持","fabricconfig","fab","相应","链","bool","\"","files","var","调跨","ticker",")","实例","学习","意味着","status","序号","文件","&","标识","订阅","查询","content","要求","getreceipt","组织","提供","byte","基础","如何","发起者","setenvkeyreplacer","simply","自定义","toml","result","等","goroutine","admin","resp","function","getibtp","功能","拿到","注册","--","b","一次","fmt","发回","收到","部分","unmarshal","要","ibtp","发送","args","4","本链","格式","多条","函数","chain","ctx","结束","defaultconfig","newticker","and","可以","username","于","主要","idx","系列","需要","package","编写","—","ret","最终","核心","基本","false","按照","标准","得到","自定","sprintf","来源","应用","过来","就","目的","else","示例","]","；","}","一定","通过","itoa","i","(","动态","所有","const","新建","应该","一系列","there","consumer","完整","环境","历史","5","...","模式","type","`","详细","快速","将","结构","errorf","buildmode","一系","unknown","构建","配置文件","相关","两条","加载","结果","教程","有","pb","if","s","localhost","件夹","payload","监听器","提交","messagehandler","invokeinterchain","getcallbackmeta","filter","eventc","智能","参数","split","规定","从","main","c","make","便捷","名","001","contract","概念","细节","你","fabric","进行","callback","如下",".","能","根据","方便","configname","安装","meta","build","pierid","err","都","addr","这些","的话","util","map","10053","gopath","任何","project","chresp","*","平台","interface","当然","submitibtpresponse","configpath","returned","parse","2","构造函数","下","world","second","证明","链来","为例","语言","入口","代码","readinconfig","目录","交互","直接","放到","熟悉","invokeindexupdate","正常","地","跨链","网络","值为","由于","、","初始","我们","dstcontractid","channel","path","转换","uint64","extra","版本","查询键","，","即为","网关","服务","org2","eventfilter","了","该","{","链到"],"title":"应用链插件编写","title_tokens":["插件","编写","应用","链"]},{"location":"bitxhub/dev/plugin/#_1","text":"在本教程中，你将构建一个完整功能的 Plugin。过程中能学习基本的概念和具体使用细节。该示例将展示如何快速、轻松地接入自己的区块链到跨链平台中来。 如果你需要接入自己开发的区块链到BitXHub跨链平台来的话，可以根据你们自己的区块链来定制开发Plugin，通过跨链网关来加入到跨链平台。","text_tokens":["将","一个","中来","示例","到","在","bitxhub"," ","概念","plugin","细节","你","构建","本","该","地","学习","和","跨链","如果","具体","可以","过程","通过","教程","能","、","区块","根据","你们","轻松","接入","需要","来","。","的","的话","开发","加入","如何","完整","展示","，","平台","基本","自己","网关","中","使用","定制","快速","功能","链来","链到"],"title":"应用链插件编写","title_tokens":["插件","编写","应用","链"]},{"location":"bitxhub/dev/plugin/#_2","text":"安装 go1.13+ 设置好$GOPATH等环境","text_tokens":["go1.13","设置","好","+","等","环境","安装","$","gopath"," "],"title":"开发要求","title_tokens":["开发","要求"]},{"location":"bitxhub/dev/plugin/#_3","text":"重要概念 Plugin接口 程序目标 开始编写程序 编译你的Plugin","text_tokens":["概念","重要","plugin","接口","目标","编写","编写程序","编译","你","的","程序","开始"," "],"title":"教程章节","title_tokens":["教程","章节"]},{"location":"bitxhub/dev/plugin/#_4","text":"在解释具体的接口之前，先明确几个概念： 跨链请求 ：如果有两条区块链A和B，A链需要向B链发起任何操作，需要按照IBTP规则向中继链发出一个请求包，我们称之为跨链请求A->B。 IBTP包 ：满足IBTP的一个package，跨链请求都需要通过IBTP包进行。 来源链 ：在跨链请求A->B中，A即为来源链。 目的链 ：在跨链请求A->B中，B即为目的链。","text_tokens":["目的","b","操作","接口","一个",">","规则","-","在","链","ibtp","之前"," ","概念","包","如果","跨链","和","具体","两条","通过","进行","有","区块","需要","请求","我们","package","。","都","发出","的","满足","几个","中继","a","任何","称之为","，","发起","即为","按照","之为","解释","先","：","向","中","来源","明确"],"title":"重要概念","title_tokens":["重要","概念"]},{"location":"bitxhub/dev/plugin/#plugin","text":"为了更加便捷的开发Plugin接入到Pier中来，我们规定了下面一些必要的接口。 type Client interface { // 初始化Plugin服务 Initialize ( configPath string , pierID string , extra [] byte ) error // 启动Plugin服务的接口 Start () error // 停止Plugin服务的接口 Stop () error // Plugin负责将区块链上产生的跨链事件转化为标准的IBTP格式，Pier通过GetIBTP接口获取跨链请求再进行处理 GetIBTP () chan * pb . IBTP // Plugin 负责执行来源链过来的跨链请求，Pier调用SubmitIBTP提交收到的跨链请求。 SubmitIBTP ( * pb . IBTP ) ( * pb . SubmitIBTPResponse , error ) // GetOutMessage 负责在跨链合约中查询历史跨链请求。查询键值中to指定目的链，idx指定序号，查询结果为以Plugin负责的区块链作为来源链的跨链请求。 GetOutMessage ( to string , idx uint64 ) ( * pb . IBTP , error ) // GetInMessage 负责在跨链合约中查询历史跨链请求。查询键值中from指定来源链，idx指定序号，查询结果为以Plugin负责的区块链作为目的链的跨链请求。 GetInMessage ( from string , idx uint64 ) ([][] byte , error ) // GetInMeta 是获取跨链请求相关的Meta信息的接口。以Plugin负责的区块链为目的链的一系列跨链请求的序号信息。如果Plugin负责A链，则可能有多条链和A进行跨链，如B->A:3; C->A:5。返回的map中，key值为来源链ID，value对应该来源链已发送的最新的跨链请求的序号，如{B:3, C:5}。 GetInMeta () ( map [ string ] uint64 , error ) // GetOutMeta 是获取跨链请求相关的Meta信息的接口。以Plugin负责的区块链为来源链的一系列跨链请求的序号信息。如果Plugin负责A链，则A可能和多条链进行跨链，如A->B:3; A->C:5。返回的map中，key值为目的链ID，value对应已发送到该目的链的最新跨链请求的序号，如{B:3, C:5}。 GetOutMeta () ( map [ string ] uint64 , error ) // GetCallbackMeta 是获取跨链请求相关的Meta信息的接口。以Plugin负责的区块链为来源链的一系列跨链请求的序号信息。如果Plugin负责A链，则A可能和多条链进行跨链，如A->B:3; A->C:5；同时由于跨链请求中支持回调操作，即A->B->A为一次完整的跨链操作，我们需要记录回调请求的序号信息，如A->B->:2; A->C—>A:4。返回的map中，key值为目的链ID，value对应到该目的链最新的带回调跨链请求的序号，如{B:2, C:4}。（注意 CallbackMeta序号可能和outMeta是不一致的，这是由于由A发出的跨链请求部分是没有回调的） GetCallbackMeta () ( map [ string ] uint64 , error ) // CommitCallback 执行完IBTP包之后进行一些回调操作。 CommitCallback ( ibtp * pb . IBTP ) error // GetReceipt 获取一个已被执行IBTP的回执 GetReceipt ( ibtp * pb . IBTP ) ( * pb . IBTP , error ) // Name 描述Plugin负责的区块链的自定义名称，一般和业务相关，如司法链等。 Name () string // Type 描述Plugin负责的区块链类型，比如Fabric Type () string }","text_tokens":["目的","getoutmessage","可能","信息","到","为","[","id","不","]","比如","plugin","如","to","合约","处理","}","；","包","通过","如果","事件","区块","(","请求","名称","应该","一系列","历史","以","5","完整","类型","type","被","getinmeta","是","作为","error","一致","）","获取","发送到","一般","将",":","即","操作","司法","commitcallback","一系","在","指定","描述","from","相关","链上","回执","结果","有","这是","pb","注意","getinmessage","/","定义","一些","chan","送到","。","停止","值中","的","启动","没有","value","提交","下面","则","getcallbackmeta","对应","为了","链为","已","规定","pier","getoutmeta","name","同时","c","stop",",","再","接口","一个","便捷",">","必要","submitibtp","中来","支持","callbackmeta","链","返回","调用","调跨","initialize","fabric",")","进行","序号",".","产生","meta","pierid","接入","查询","由","发出","getreceipt","map","开发","byte","最新","自定义","*","interface","submitibtpresponse",";","configpath","中","等","2","getibtp","回调","start","b","一次","负责","收到","部分","client","-","对","ibtp","发送","4","string","outmeta"," ","格式","多条","3","更加","带回","记录","和","跨链","值为","由于","之后","idx","系列","完","执行","初始","需要","我们","—","key","uint64","extra","a","查询键","，","（","服务","标准","自定","转化","来源","了","初始化","过来","业务","该","{"],"title":"Plugin接口","title_tokens":["plugin","接口"]},{"location":"bitxhub/dev/plugin/#_5","text":"本教程以开发一个简单的连接Fabric区块链网络的Plugin为例，最终的程序能够实现从负责的区块链获取 Hello World 信息并返回到跨链平台中。","text_tokens":["为例","能够","一个","负责","信息","到","程序","链","hello","返回"," ","实现","plugin","fabric","本","并","跨链","网络","教程","区块","。","连接","的","开发","最终","以","，","平台","简单","中","world","获取","从"],"title":"程序目的","title_tokens":["目的","程序"]},{"location":"bitxhub/dev/plugin/#_6","text":"首先选择你的工程目录，按照正常的GO程序的流程建立项目 $ go version // 确认你安装的GO版本 $ mkdir ${ YOUR_PROJECT } $ cd ${ YOUR_PROJECT } $ go mod init exmple/fabric-plugin","text_tokens":["确认","go","目录","-","程序"," ","mkdir","流程","exmple","建立","plugin","}","your","你","cd","fabric","正常","init","$","选择","/","安装","mod","的","项目","version","_","首先","版本","project","，","按照","工程","{"],"title":"开始编写你的程序","title_tokens":["编写","你","的","程序","开始"]},{"location":"bitxhub/dev/plugin/#client","text":"首先创建一个 client.go 文件，这个文件是Plugin的核心和入口。 在该文件中，应该定义你的Plugin如何获取client 实例，以及如何启动和停止Plugin服务。 现在我们需要创建一个自定义的Client 结构，跨链网关最终拿到的应该是这个结构的一个实例，先来看看这个结构中都需要什么。 首先来看看 Client自定义 具体结构 type Client struct { meta * ContractMeta consumer * Consumer eventC chan * pb . IBTP pierId string name string } type ContractMeta struct { EventFilter string `json:\"event_filter\"` Username string `json:\"username\"` CCID string `json:\"ccid\"` ChannelID string `json:\"channel_id\"` ORG string `json:\"org\"` } meta：Plugin直接和跨链合约交互，需要保存你的合约的一些基础信息。由于我们需要连接一个Fabric网络，这些Meta信息包括 Fabric中跨链事件的名称、Fabric中的用户名称、Chaincode合约的名称、你的组织名称Org以及组织所在的channel。 consumer：可以理解为Fabric上跨链事件的“监听器”，这个监听器也是一个自定义的结构，具体的结构在后面会详细介绍。 eventC：为跨链网关提供读取监听到的跨链事件的通道。 name：自定的区块链的名称。 pierId：跨链网关注册在跨链平台中后产生的唯一ID，作为应用链的标识。 然后应该提供一个Client的实例化的接口（类似于构造函数），具体代码如下： func ( c * Client ) Initialize ( configPath , pierId string , extra [] byte ) error { eventC := make ( chan * pb . IBTP ) // read config from files fabricConfig , err := UnmarshalConfig ( configPath ) if err != nil { return nil , fmt . Errorf ( \"unmarshal config for plugin :%w\" , err ) } // some basic configs about your chaincode contractmeta := & ContractMeta { EventFilter : fabricConfig . EventFilter , Username : fabricConfig . Username , CCID : fabricConfig . CCID , ChannelID : fabricConfig . ChannelId , ORG : fabricConfig . Org , } // handler for listening on inter-chain events posted on your Fabric mgh , err := newFabricHandler ( contractmeta . EventFilter , eventC , pierId ) if err != nil { return err } done := make ( chan bool ) csm , err := NewConsumer ( configPath , contractmeta , mgh , done ) if err != nil { return err } c . consumer = csm c . eventC = eventC c . meta = contractmeta c . pierId = pierId c . name = fabricConfig . Name c . outMeta = m c . ticker = time . NewTicker ( 2 * time . Second ) c . done = done return nil }","text_tokens":["mgh","唯一","time","信息","上","到","为","创建","[","用户","id","]","!","plugin","}","合约","事件","具体","区块","什么","(","json","contractmeta","来","%","名称","应该","consumer","_","event","type","inter","newconsumer","`","：","是","ccid","详细","作为","error","所在","）","获取","理解","return","会","结构",":","errorf","”","m","读取","channelid","“","在","struct","listening","from","类似","handler","w","=","定义","pb","中后","/","if","on","监听","现在","一些","化","chan","。","停止","监听器","的","通道","启动","csm","filter","先","eventc","newfabrichandler","name","func","c","介绍","make","nil",",","posted","一个","接口","fabricconfig","for","链","bool","\"","files","后面","initialize","你","fabric","your",")","实例","done","ticker","如下",".","文件","产生","configs","&","标识","meta","events","pierid","包括","err","about","都","这些","连接","组织","提供","byte","基础","如何","config","首先","自定义","*","平台","configpath","中","basic","2","构造函数","second","拿到","注册","入口","fmt","代码","go","以及","unmarshal","client","直接","交互","chaincode","-","ibtp","string","outmeta"," ","some","函数","chain","newticker","可以","username","和","跨链","于","unmarshalconfig","网络","org","由于","、","也","需要","我们","channel","这个","最终","extra","构造","，","核心","网关","（","服务","自定","然后","eventfilter","应用","read","保存","看看","该","{"],"title":"Client对象","title_tokens":["client","对象"]},{"location":"bitxhub/dev/plugin/#consumer","text":"consumer 负责监听区块链上的由跨链合约抛出的跨链事件以及和调用chaincode。 我们新建 ./consumer.go 文件 type Consumer struct { eventClient * event . Client meta * ContractMeta msgH MessageHandler channelProvider context . ChannelProvider ChannelClient * channel . Client registration fab . Registration ctx chan bool } eventClient：fabric gosdk提供的事件Client meta Fabric：相关的参数信息 msgH：事件handler，在监听到指定事件之后负责处理的函数 channelProvider：fabric gosdk提供的和chaincode交互 ChannelClient：fabric gosdk 提供的和调用chaincode的对象 registeration：fabric gosdk 提供的订阅特定事件的对象 ctx：用来结束consumer的goroutine","text_tokens":["msgh","channelclient","负责","以及","go","chaincode","client","fab","信息","到","在","交互","bool","对象","抛出"," ","struct","指定","用来","调用","函数","ctx","结束","}","合约","处理","fabric","registeration","和","跨链","事件","链上","registration","gosdk","相关",".","文件","区块","eventclient","handler","/","之后","meta","监听","参数信息","订阅","contractmeta","我们","chan","。","由","channel","新建","的","提供","consumer","messagehandler","event","type","*","，","channelprovider","：","特定","参数","goroutine","context","{"],"title":"consumer","title_tokens":["consumer"]},{"location":"bitxhub/dev/plugin/#event","text":"由于在Fabric上抛出的事件内容是可以自定义的，而跨链请求要在跨链平台上传递的话，需要使用IBTP包，所以我们需要一定的代码来执行这种转换。 我们新建 ./event.go 文件 type Event struct { Index uint64 `json:\"index\"` DstChainID string `json:\"dst_chain_id\"` SrcContractID string `json:\"src_contract_id\"` DstContractID string `json:\"dst_contract_id\"` Func string `json:\"func\"` Args string `json:\"args\"` Argscb string `json:\"argscb\"` Rollback string `json:\"rollback\"` Argsrb string `json:\"argsrb\"` Callback string `json:\"callback\"` Proof [] byte `json:\"proof\"` Extra [] byte `json:\"extra\"` } Event结构也是自定义的，需要和在你的跨链合约中抛出的事件结构一致。一个跨链交易事件，一般来说需要指定目标应用链的ID DstChainID ，目标应用链上智能合约的地址或者ID（Fabric上的chaincode没有合约地址） DstContractID ，这次跨链交易的发起者的合约地址 SrcContractID ，跨链调用的函数名 Func ，该函数的参数 Args ，是否有跨链调用之后要执行的回调函数 Callback ，为了该应用链上对于该事件的证明 Proof ，用户可自定义的部分 Extra 。","text_tokens":["这种","index","rollback","dst","上","[","用户","id","]","包","}","合约","一定","事件","json","请求","来","是否","新建","_","event","type","目标","`","是","所以","srccontractid","一致","）","一般",":","argsrb","结构","在","对于","struct","指定","传递","链上","有","定义","/","。","的","没有","可","交易","为了","使用","或者","argscb","智能","参数","而","func","一个","名","contract","链","\"","调用","你","fabric","callback",".","文件","dstchainid","的话","发起者","byte","自定义","发起","平台","中","内容","证明","回调","代码","go","要","部分","chaincode","ibtp","args","抛出","string"," ","这次","chain","函数","可以","和","跨链","由于","之后","执行","也","src","需要","我们","来说","dstcontractid","转换","proof","一般来说","uint64","extra","，","（","自定","地址","应用","该","{"],"title":"Event","title_tokens":["event"]},{"location":"bitxhub/dev/plugin/#_7","text":"Plugin的配置文件路径是通过Initialize的方法动态传入的，这意味着你可以方便的修改关于你的区块链的参数信息。我们新建文件 ./config.go 文件，负责配置读取的所有操作。 这里使用的是 github.com/spf13/viper 库和TOML文件作为配置，当然你也可以使用任何你熟悉的工具来读取配置。 package main import ( \"path/filepath\" \"strings\" \"github.com/spf13/viper\" ) const ( ConfigName = \"fabric.toml\" ) type Fabric struct { Addr string `toml:\"addr\" json:\"addr\"` Name string `toml:\"name\" json:\"name\"` EventFilter string `mapstructure:\"event_filter\" toml:\"event_filter\" json:\"event_filter\"` Username string `toml:\"username\" json:\"username\"` CCID string `toml:\"ccid\" json:\"ccid\"` ChannelId string `mapstructure:\"channel_id\" toml:\"channel_id\" json:\"channel_id\"` Org string `toml:\"org\" json:\"org\"` } func DefaultConfig () * Fabric { return & Fabric { Addr : \"localhost:10053\" , Name : \"fabric\" , EventFilter : \"CrosschainEventName\" , Username : \"Admin\" , CCID : \"Broker-001\" , ChannelId : \"mychannel\" , Org : \"org2\" , } } func UnmarshalConfig ( configPath string ) ( * Fabric , error ) { viper . SetConfigFile ( filepath . Join ( configPath , ConfigName )) viper . SetConfigType ( \"toml\" ) viper . AutomaticEnv () viper . SetEnvPrefix ( \"FABRIC\" ) replacer := strings . NewReplacer ( \".\" , \"_\" ) viper . SetEnvKeyReplacer ( replacer ) if err := viper . ReadInConfig (); err != nil { return nil , err } config := DefaultConfig () if err := viper . Unmarshal ( config ); err != nil { return nil , err } return config , nil }","text_tokens":["broker","这","setconfigtype","关于","信息","id","!","plugin","}","通过","区块","动态","(","json","所有","来","const","新建","_","event","type","`","是","ccid","作为","error","这里","strings","setconfigfile","mychannel","viper","return",":","操作","工具","spf13","读取","channelid","struct","配置文件","=","if","/","localhost","参数信息","。","的","newreplacer","join","setenvprefix","传入","filter","使用","参数","name","main","库","func","nil",",","automaticenv","crosschaineventname","001","链","\"","initialize","你","fabric","意味着",")",".","文件","&","方便","configname","import","err","addr","setenvkeyreplacer","10053","config","任何","*","toml","当然","路径",";","mapstructure","configpath","admin","意味","replacer","github","com","readinconfig","go","负责","unmarshal","-","配置","string"," ","熟悉","defaultconfig","可以","username","和","unmarshalconfig","org","也","我们","package","path","channel","方法","filepath","，","修改","org2","eventfilter","{"],"title":"读取配置","title_tokens":["配置","读取"]},{"location":"bitxhub/dev/plugin/#submitibtp","text":"该接口主要负责将其他链发送过来的IBTP包解析并构造成当前目的链的交易，发送到目的链的跨链合约中。 如果来源链要求将本链调用合约的结果返回的话，还需要构造相应的IBTP回执发回来源链。 func ( c * Client ) SubmitIBTP ( ibtp * pb . IBTP ) ( * pb . SubmitIBTPResponse , error ) { pd := & pb . Payload {} ret := & pb . SubmitIBTPResponse {} if err := pd . Unmarshal ( ibtp . Payload ); err != nil { return ret , fmt . Errorf ( \"ibtp payload unmarshal: %w\" , err ) } content := & pb . Content {} if err := content . Unmarshal ( pd . Content ); err != nil { return ret , fmt . Errorf ( \"ibtp content unmarshal: %w\" , err ) } if ibtp . Category () == pb . IBTP_UNKNOWN { return nil , fmt . Errorf ( \"invalid ibtp category\" ) } logger . Info ( \"submit ibtp\" , \"id\" , ibtp . ID (), \"contract\" , content . DstContractId , \"func\" , content . Func ) for i , arg := range content . Args { logger . Info ( \"arg\" , strconv . Itoa ( i ), string ( arg )) } if ibtp . Category () == pb . IBTP_RESPONSE && content . Func == \"\" { logger . Info ( \"InvokeIndexUpdate\" , \"ibtp\" , ibtp . ID ()) _ , resp , err := c . InvokeIndexUpdate ( ibtp . From , ibtp . Index , ibtp . Category ()) if err != nil { return nil , err } ret . Status = resp . OK ret . Message = resp . Message return ret , nil } var result [][] byte var chResp * channel . Response callFunc := CallFunc { Func : content . Func , Args : content . Args , } bizData , err := json . Marshal ( callFunc ) if err != nil { ret . Status = false ret . Message = fmt . Sprintf ( \"marshal ibtp %s func %s and args: %s\" , ibtp . ID (), callFunc . Func , err . Error ()) res , _ , err := c . InvokeIndexUpdate ( ibtp . From , ibtp . Index , ibtp . Category ()) if err != nil { return nil , err } chResp = res } else { res , resp , err := c . InvokeInterchain ( ibtp . From , ibtp . Index , content . DstContractId , ibtp . Category (), bizData ) if err != nil { return nil , fmt . Errorf ( \"invoke interchain for ibtp %s to call %s: %w\" , ibtp . ID (), content . Func , err ) } ret . Status = resp . OK ret . Message = resp . Message // if there is callback function, parse returned value result = util . ToChaincodeArgs ( strings . Split ( string ( resp . Data ), \",\" ) ... ) chResp = res } // If is response IBTP, then simply return if ibtp . Category () == pb . IBTP_RESPONSE { return ret , nil } proof , err := c . getProof ( * chResp ) if err != nil { return ret , err } ret . Result , err = c . generateCallback ( ibtp , result , proof , ret . Status ) if err != nil { return nil , err } return ret , nil }","text_tokens":["目的","index","then","else","arg","其他","[","id","!","]","包","}","合约","to","如果","data","itoa","ok","is","i","(","json","%","there","_","...","tochaincodeargs","error","bizdata","message","strings","发送到","并","return","将",":","errorf","strconv","callfunc","unknown","interchain","pd","from","回执","结果","w","=","pb","if","s","成","res","/","generatecallback","送到","。","payload","category","invalid","的","value","invokeinterchain","交易","range","submit","split","func","c","nil",",","接口","response","submitibtp","相应","for","contract","info","链","\"","返回","invoke","调用","var",")","status","callback",".","&","err","content","当前","的话","util","要求","byte","simply","chresp","*","submitibtpresponse",";","result","returned","中","parse","resp","function","fmt","发回","负责","call","unmarshal","client","解析","ibtp","发送","args","本链","string"," ","getproof","and","invokeindexupdate","跨链","还","主要","logger","需要","marshal","dstcontractid","channel","ret","proof","构造","，","false","sprintf","来源","过来","&&","该","{"],"title":"SubmitIBTP","title_tokens":["submitibtp"]},{"location":"bitxhub/dev/plugin/#plugin_1","text":"我们采用GO语言提供的插件模式，实现Pier对于你编写的Plugin的动态加载。 MacOS和Linux平台： 运行下面的命令，能够得到 your_plugin.so 文件。 $ cd ${ YOUR_PROJECT_PATH } $ go build --buildmode = plugin -o your_plugin.so ./*.go 将你编写的动态链接文件，放到Pier配置文件夹下，配合我们提供的Pier，就能接入到跨链平台来。","text_tokens":["文件夹","语言","--","o","将","能够","buildmode","go","-","放到","到","linux","对于","配合","配置"," ","实现","plugin","链接","}","your","你","cd","so","和","跨链","$","加载","macos",".","文件","{","=","件夹","/","build","能","动态","接入","我们","来","编写","。","path","的","提供","命令","下面","_","project","模式","，","平台","*","插件","采用","得到","：","下","pier","就","运行"],"title":"编译你的Plugin","title_tokens":["编译","plugin","的","你"]},{"location":"bitxhub/dev/rule/","text":"验证规则 BitXHub的验证引擎的规则除了内置的规则以外主要是通过WASM字节码来运行逻辑的。该文档将会以rust为例说明验证规则的编写方法。 1. 下载规则模板 在GitHub的BitXHub项目已经提供了规则编写 模板 ，用户可以下载这个模板然后对模板进行改造来形成自己所希望运行的规则逻辑。 2. 规则模板的目录结构 . ├── Cargo.toml └── src ├── app │ ├── contract.rs │ └── mod.rs ├── crypto │ ├── ecdsa.rs │ ├── fabric.rs │ └── mod.rs ├── lib.rs ├── memory.rs └── model ├── mod.rs └── transaction.rs 从上面的目录结构图中，我们可以看到除去rust项目自己本身自带的Cargo.toml文件以外了，目录的源码目录src下面有三个文件夹和两个rs文件，其中lib.rs文件存放着能够被wasm虚拟机export识别的函数，在规则编写中用户不需要理会这个文件，这个是由模板自己预先编写好的能够读取外部输入参数的函数。还有就是memory.rs这个文件是模板用来处理wasm虚拟机的字符串和字节数组输入输出使用的，也是用户不需要理会的文件。 除了上述的两个rs文件，还有三个文件夹，分别是app, crypto以及model。model文件夹可以让用户存放一些他们规则逻辑中需要使用的数据原型，在模板当中我们使用了fabric的ChaincodeAction的proto作为数据原型作为例子来展现如何引用或者定义自己的数据模型。再其次是crypto库，在BitXHub的规划中会逐渐丰富能够提供给用户的方便使用的密码库，这样能够让用户更方便的调用加密函数来编写自己的验证逻辑。 除了上述的目录和文件，整个合约模板最重要的就是app这个目录，用户主要需要编写的文件也是在这个目录中，其中app这个目录下的contract.rs的文件就是用户编写验证规则逻辑的文件。 pub fn verify ( proof : & [ u8 ], validator : & [ u8 ], payload : & [ u8 ]) -> bool { return true } 在模板中我们可以看到这个函数，这个就是用户需要进行逻辑编写的地方，其中该函数的输入由三个参数组成：proof, validator和payload，都是字节数组，用户直接可以用这三个参数完成自己的验证逻辑。如何用proof, validator和payload进行验证就看应用链自己是如何来规定自己的验证逻辑的。 以最简单的椭圆曲线验证为例，在模板库里面提供了一个ecdsa的函数： fn ecdsa_verify ( sig_ptr : i64 , digest_ptr : i64 , pubkey_ptr : i64 , opt : i32 ) -> i32 ; 如果我们的验证逻辑是proof就是ecdsa中的签名，payload就是ecdsa中的digest，然后validator就是公钥，那么验证逻辑就可以简单写成： pub fn verify ( proof : & [ u8 ], validator : & [ u8 ], payload : & [ u8 ]) -> bool { return ecdsa :: verify ( & proof , & payload , & validator , ecdsa :: EcdsaAlgorithmn :: P256 , ); } 更加复杂的逻辑就留给用户自己来实现。 3. 编译代码成为WASM字节码 下面来介绍如何用rust将代码编译成简洁的wasm字节码。 首先我们需要添加rust的nightly版本： rustup toolchain install nightly 更新rust： rustup update 添加需要的目标工具链： rustup target add wasm32-unknown-unknown --toolchain nightly 接下来就可以编译我们的项目了： cargo +nightly build --target wasm32-unknown-unknown --release 我们编译出来的wasm字节码将会在target/wasm32-unknown-unknown/release下面，注意这个时候我们编译出来的wasm字节码的大小是非常大的，我们需要将其精简一下，首先下载工具wasm-gc cargo install --git https://github.com/alexcrichton/wasm-gc 然后使用wasm-gc进行精简： wasm-gcxxx.wasm small-xxx.wasm 获取的small-xxx.wasm就是可以部署到中继链的验证规则。","text_tokens":["sig","原型","这","模板","方便使用","重要","说明","复杂","cargo","到","部署","[","用户","理会","码来","结构图","不","用来","]","true","wasm32","那么","}","合约","处理","椭圆","通过","数据模型","自带","如果","{","字符串","add","成为","rustup","(","就是","来","给","verify","文档","存放","输出","中继","以","_","fn","验证","译成","简单","希望","目标","输入","：","被","是","用","rs","│","作为","ptr","非常","整个","下来","获取","输入输出","nightly","return","会","将","结构",":","当中","工具","读取","规则","在","unknown","├","加密","其","丰富","签名","opt","接下来","形成","件夹","有","update","定义","码","注意","/","一些","payload","。","里面","接下","着","的","model","这样","下面","wasm","ecdsa","简洁","分别","使用","或者","参数","一下","lib","引用","规定","留给","添加","从","所","文件夹","其次","库","digest","介绍",",","已经","能够","好","将会","rust","上述","逐渐","pub",">","一个","下载工具","contract","字节","└","完成","链","bool","除了","实现","逻辑","调用","看到","规划","内置","chaincodeaction","fabric","+",")","编译","进行","small",".","文件","&","方便","build","p256","由","再其次","都","出来","三个","最","提供","app","如何","还有","ecdsaalgorithmn","首先","export","两个","toml","构图",";","看","中","transaction","2","例子","下","alexcrichton","https","大小","让","模型","运行","识别","i32","为例","--","github","精简","crypto","其中","memory","预先","gc","代码","更新","数组","以及","更","com","目录","i64","-","直接","引擎","对","字符","外部","就","bitxhub","─"," ","他们","密码","公钥","函数","更加","3","proto","xxx","除去","可以","和","写成","大","虚拟机","gcxxx","主要","mod","以外","组成","也","src","需要","我们","install","编写","release","proof","方法","validator","toolchain","项目","这个","展现","u8","本身","版本","下载","时候","上面","，","pubkey","自己","git","地方","然后","改造","target","了","应用","虚拟","曲线","编译成","源码","该","1","数据"],"title":"验证规则编写","title_tokens":["编写","验证","规则"]},{"location":"bitxhub/dev/rule/#_1","text":"BitXHub的验证引擎的规则除了内置的规则以外主要是通过WASM字节码来运行逻辑的。该文档将会以rust为例说明验证规则的编写方法。","text_tokens":["为例","说明","将会","rust","规则","字节","引擎","除了","bitxhub","码来","逻辑","内置","通过","主要","以外","编写","。","文档","的","方法","以","wasm","验证","是","该","运行"],"title":"验证规则","title_tokens":["验证","规则"]},{"location":"bitxhub/dev/rule/#1","text":"在GitHub的BitXHub项目已经提供了规则编写 模板 ，用户可以下载这个模板然后对模板进行改造来形成自己所希望运行的规则逻辑。","text_tokens":["github","模板","已经","规则","在","对","bitxhub","用户"," ","逻辑","可以","进行","形成","来","编写","。","的","提供","项目","这个","下载","，","希望","自己","然后","改造","了","所","运行"],"title":"1. 下载规则模板","title_tokens":["下载","模板","规则",".","1"," "]},{"location":"bitxhub/dev/rule/#2","text":". ├── Cargo.toml └── src ├── app │ ├── contract.rs │ └── mod.rs ├── crypto │ ├── ecdsa.rs │ ├── fabric.rs │ └── mod.rs ├── lib.rs ├── memory.rs └── model ├── mod.rs └── transaction.rs 从上面的目录结构图中，我们可以看到除去rust项目自己本身自带的Cargo.toml文件以外了，目录的源码目录src下面有三个文件夹和两个rs文件，其中lib.rs文件存放着能够被wasm虚拟机export识别的函数，在规则编写中用户不需要理会这个文件，这个是由模板自己预先编写好的能够读取外部输入参数的函数。还有就是memory.rs这个文件是模板用来处理wasm虚拟机的字符串和字节数组输入输出使用的，也是用户不需要理会的文件。 除了上述的两个rs文件，还有三个文件夹，分别是app, crypto以及model。model文件夹可以让用户存放一些他们规则逻辑中需要使用的数据原型，在模板当中我们使用了fabric的ChaincodeAction的proto作为数据原型作为例子来展现如何引用或者定义自己的数据模型。再其次是crypto库，在BitXHub的规划中会逐渐丰富能够提供给用户的方便使用的密码库，这样能够让用户更方便的调用加密函数来编写自己的验证逻辑。 除了上述的目录和文件，整个合约模板最重要的就是app这个目录，用户主要需要编写的文件也是在这个目录中，其中app这个目录下的contract.rs的文件就是用户编写验证规则逻辑的文件。 pub fn verify ( proof : & [ u8 ], validator : & [ u8 ], payload : & [ u8 ]) -> bool { return true } 在模板中我们可以看到这个函数，这个就是用户需要进行逻辑编写的地方，其中该函数的输入由三个参数组成：proof, validator和payload，都是字节数组，用户直接可以用这三个参数完成自己的验证逻辑。如何用proof, validator和payload进行验证就看应用链自己是如何来规定自己的验证逻辑的。 以最简单的椭圆曲线验证为例，在模板库里面提供了一个ecdsa的函数： fn ecdsa_verify ( sig_ptr : i64 , digest_ptr : i64 , pubkey_ptr : i64 , opt : i32 ) -> i32 ; 如果我们的验证逻辑是proof就是ecdsa中的签名，payload就是ecdsa中的digest，然后validator就是公钥，那么验证逻辑就可以简单写成： pub fn verify ( proof : & [ u8 ], validator : & [ u8 ], payload : & [ u8 ]) -> bool { return ecdsa :: verify ( & proof , & payload , & validator , ecdsa :: EcdsaAlgorithmn :: P256 , ); } 更加复杂的逻辑就留给用户自己来实现。","text_tokens":["sig","原型","这","模板","方便使用","重要","复杂","cargo","[","用户","理会","用来","结构图","不","]","true","那么","}","合约","处理","椭圆","数据模型","如果","自带","字符串","(","就是","来","给","verify","存放","输出","以","_","fn","验证","简单","输入","：","被","是","用","rs","│","作为","ptr","整个","输入输出","return","会","结构",":","当中","读取","规则","在","├","加密","丰富","签名","opt","件夹","有","定义","一些","payload","。","里面","着","的","model","这样","下面","wasm","ecdsa","分别","使用","或者","参数","lib","引用","规定","留给","从","文件夹","其次","库","digest",",","能够","好","上述","rust","逐渐","pub",">","一个","contract","字节","└","完成","链","bool","除了","实现","逻辑","调用","看到","规划","chaincodeaction","fabric",")","进行",".","文件","&","方便","p256","由","再其次","都","三个","最","提供","app","如何","还有","ecdsaalgorithmn","export","两个","toml","构图",";","看","中","transaction","例子","下","让","模型","i32","识别","为例","crypto","其中","memory","预先","数组","以及","更","目录","i64","-","直接","字符","外部","就","─","bitxhub"," ","他们","密码","公钥","函数","更加","proto","除去","可以","和","写成","虚拟机","主要","mod","以外","组成","也","src","需要","我们","编写","proof","validator","项目","这个","展现","u8","本身","上面","，","pubkey","自己","地方","然后","了","应用","虚拟","曲线","源码","该","{","数据"],"title":"2. 规则模板的目录结构","title_tokens":["结构","模板","规则","目录","2","的","."," "]},{"location":"bitxhub/dev/rule/#3-wasm","text":"下面来介绍如何用rust将代码编译成简洁的wasm字节码。 首先我们需要添加rust的nightly版本： rustup toolchain install nightly 更新rust： rustup update 添加需要的目标工具链： rustup target add wasm32-unknown-unknown --toolchain nightly 接下来就可以编译我们的项目了： cargo +nightly build --target wasm32-unknown-unknown --release 我们编译出来的wasm字节码将会在target/wasm32-unknown-unknown/release下面，注意这个时候我们编译出来的wasm字节码的大小是非常大的，我们需要将其精简一下，首先下载工具wasm-gc cargo install --git https://github.com/alexcrichton/wasm-gc 然后使用wasm-gc进行精简： wasm-gcxxx.wasm small-xxx.wasm 获取的small-xxx.wasm就是可以部署到中继链的验证规则。","text_tokens":["cargo","到","部署","wasm32","add","rustup","就是","来","中继","译成","验证","目标","：","是","用","非常","下来","获取","nightly","会","将",":","工具","规则","unknown","在","其","接下来","update","码","注意","/","接下","。","的","下面","wasm","简洁","使用","一下","添加","介绍","编译","toolchain","下载工具","rust","字节","链","+","进行",".","build","出来","如何","首先","alexcrichton","https","大小","small","--","精简","github","com","gc","代码","更新","-"," ","xxx","可以","大","gcxxx","install","需要","我们","release","项目","这个","版本","下载","时候","，","git","然后","target","编译成","了","就"],"title":"3. 编译代码成为WASM字节码","title_tokens":["wasm","3","编译","代码","字节",".","码","成为"," "]},{"location":"bitxhub/dev/validator/","text":"验证者信息生成 1. 什么是验证者信息 验证者信息是应用链接入中继链后用来验证交易存在性和有效性的重要凭证，常见的验证者信息可以包含应用链背书节点的证书或者公私钥。 应用链的管理员需要根据接入应用链的类型和特性，生成能够验证自己应用链跨链交易的验证者信息，下面我们会以Fabric和Hyperchain为例，介绍如何生成验证者信息。 2. Fabric验证者信息的生成 2.1 Fabric的验证逻辑 Fabric对于智能合约的执行是在背书节点上进行的，每一个背书节点都会模拟执行chaincode，在模拟执行完chaincode之后，背书节点会对模拟的结果和抛出的事件进行封装，之后再进行签名背书。最后将背书结果发送给客户端。客户端在对比模拟执行的结果之后将背书结果发给orderer节点进行排序，最后在提交阶段会抛出chaincode的事件。 2.1.1 Fabric的存储结构 ProcessedTransaction（位于faric-protos-go->peer->transaction.pb.go）即Fabric存储的已经处理的交易结构。其中包含TransactionEnvelope和ValidationCode两个主要的元素。 字段 类型 描述 TransactionEnvelope *common.Envelope 交易信封，存储处理过的交易信息 ValidationCode int32 是否验证 Envelop(位于faric-protos-go->common->common.pb.go)即存储在区块中一条交易的数据结构。其中Payload（位于faric-protos-go->common->common.pb.go）通过解析可以分解成Header和Data。 字段 类型 描述 Payload []byte 交易信息的byte数组，可以解析为下面的Payload Signature []byte 对Payload的签名 字段 类型 描述 Header *Header 身份信息，防止重复 Data []byte 可以解析为下面的Transaction 其中Data则是存储的Transaction（位于faric-protos-go->peer->transaction.pb.go）的信息。一个Transaction可以包含一个或者多个Actions。 字段 类型 描述 Actions []*TransactionAction TransactionAction的数组，TransactionAction结构如下 字段 类型 描述 Header []byte proposal的header Payload []byte 可以解析成下面的ChaincodeActionPayload结构 TransactionAction中的Payload可以解析成ChaincodeActionPayload（位于faric-protos-go->peer->transaction.pb.go）。 字段 类型 描述 ChaincodeProposalPayload []byte 存储chanicode的proposal的信息 Action *ChaincodeEndorsedAction Chaincode执行结果 其中ChaincodeProposalPayload可以解析成ChaincodeProposalPayload（位于aric-protos-go->peer->proposal.pb.go）。 其中Action则是ChaincodeEndorsedAction（位于faric-protos-go->peer->transaction.pb.go） 字段 类型 描述 ProposalResponsePayload []byte 存储chaincode执行结果 Endorsements []*Endorsement 背书信息 对于ProposalResponsePayload，则可以解析成为ProposalResponsePayload(位于faric-protos-go->peer->proposal_response.pb.go) 对于Endorsements，则是Endorsement的数组，每一个proposal都会有chaincode规定的背书节点们进行签名，Endorsement的结构如下： 2.1.2 Pier获取验证信息 根据上述的交易结构体，Pier可以根据交易的哈希查询到相应的交易，并从结构体中拿到中继链需要验证的Proof字段。 l , err := ledger . New ( c . consumer . channelProvider ) if err != nil { return nil , err } t , err := l . QueryTransaction ( response . TransactionID ) if err != nil { return nil , err } pd := & common . Payload {} if err := proto . Unmarshal ( t . TransactionEnvelope . Payload , pd ); err != nil { return nil , err } pt := & peer . Transaction {} if err := proto . Unmarshal ( pd . Data , pt ); err != nil { return nil , err } return pt . Actions [ 0 ]. Payload , nil // => this is proof 2.1.3 BitXHub验证 BitXHub在接受到Pier发来的跨链的请求时，会解析请求的结构，校验ProposalResponse的签名，并且比对Body的内容是否和ProposalResponse解析出来的一致，如果上面的阶段结果都一致，则代表校验成功。 2.2 Fabric的复杂背书 2.2.1 Fabric的背书流程 Fabric的背书主要是 验证 Endorser 节点对交易的签名 验证是否有足够数量的节点对交易背书 背书信息来自指定源 2.2.2 实体的定义 一个实体由 MSP 与 ROLE 定义，即某个组织内的某个角色。其中ROLE支持四种 client, peer, admin, member。例如 Org0.admin 表示 Org0 这个 MSP 下的任意管理员; Org1.member 表示 Org1 这个 MSP 下的任意成员。 2.2.3 表达式 Endorsement Policy 的语法结构如下所示。 EXPR 可以是是 AND 或者 OR 逻辑符。E 是实体或者嵌套的表达式。需要注意的是Fabric暂时只支持1-of-N和MAX-of-N。 // 基础表达式形式 EXPR ( E [, E ... ]) // 需要三个实体都提供签名 AND ( ' Org1 . member ' , ' Org2 . member ' , ' Org3 . member ' ) // 需要两个实体任一提供签名 OR ( ' Org1 . member ' , ' Org2 . member ' ) // 需要Org1的admin提供签名，或者Org2，Org3的member同时提供签名 OR ( ' Org1 . admin ' , AND ( ' Org2 . member ' , ' Org3 . member ' )) 2.2.4 验证引擎的验证 验证引擎根据应用链注册时提供的验证名单进行背书验证。Fabric所需要的验证者信息时一个map，key为背书节点的mspid，value为背书节点的跟证书。 可以看到复杂验证规则中有AND和OR的规则，根据Fabric的特性，背书策略在chaincode部署以后可以升级，所以考虑到验证规则的升级，对复杂规则的判断也需要写在合约中。合约中需要对以下几步进行验证。 首先是对签名数量验证，比如对于 AND('Org1.member', 'Org2.member', 'Org3.member') ，如果背书数组的长度小于3，即可直接驳回。 如果数量对等，则进行逐一校验，需要注意的是拿到endorser的id以后，需要通过key值找到事先存储在BitXHub中的跟证书信息，再对pier发过来的endorser的证书进行验证，比对一致以后再进行验签。 2.2.5 智能合约库 BitXHub提供了背书策略的智能合约库，当部署验证合约时，只要将背书策略的表达式即可完成对背书策略的声明，当一笔跨链交易经过验证引擎时，验证引擎会根据部署的智能合约自动的调用内置的背书策略库，对验证者信息进行合演筛选。 2.3. 验证引擎对Fabric的验证流程 2.3.1 应用链注册 应用链在注册到BitXHub时需要提交验证者的信息，在这里我们将Fabric的验证者信息以json的格式提交到BitXHub进行注册。主要分为下面三个字段： 证书信息：证书信息为Fabric的msp信息，包含了机构、成员、角色以及证书的信息。是msp.MSP的数组。 背书策略的byte的数组。通过Fabric的cauthdsl.FromString()函数生成的策略字节数组 chaincode的id，用来验证交易是由规定的chaincode发出的。 2.3.2 应用链发送跨链交易 应用链会通过IBTP协议发送跨链交易到BitXHub，BitXHub需要对IBTP中的Proof字段进行验证，从而验证跨链交易的有效性。对于Fabric来说Proof字段的内容为交易结构中Transaction.Actions[0].Payload。Pier节点将这个作为Proof字段封装到IBTP然后发送给BitXHub。 2.3.3 验证Proof 验证引擎提供了专门给Fabric的wasm验证库从而简便wasm合约的编写。 1） 首先需要从proof字段中抽取出交易结构，然后对交易结构中的chaincode的id进行校验，只有和注册时表明的chaincode的id相符合才能继续进行验证。 2） 从交易结构中抽取出签名集，签名集是指多个背书节点对proposal背书形成的签名的集合。 3） 将应用链注册时传入的Fabric的msp的配置传入策略生成器，获取可以验证当前应用链的msp的策略验证工具。 3） 将签名集和验证策略传入到策略验证工具进行验证，没有错误即为验证成功。 2.4. Fabric验证者信息生成 Fabric验证者信息的生成主要是通过Fabric的验证代码来实现，我们获取了Fabric验证交易所需要的一下信息来为我们验证Fabric跨链交易提供参数信息。 channelProvider : = sdk . ChannelContext ( meta . ChannelID , fabsdk . WithUser ( meta . Username ), fabsdk . WithOrg ( meta . ORG )) channelClient , err : = channel . New ( channelProvider ) if err != nil { return nil , fmt . Errorf ( \"create channel fabcli fail: %s \\n \" , err . Error ()) } l , err : = ledger . New ( channelProvider ) if err != nil { return nil , err } // Get Fabric Channel Config conf , err : = l . QueryConfig () if err != nil { return nil , err } // Generate Policy Bytes policy , err : = cauthdsl . FromString ( \"AND('Org2MSP.peer', 'Org1MSP.peer')\" ) if err != nil { return nil , err } pBytes , err : = proto . Marshal ( policy ) if err != nil { return nil , err } if err : = ioutil . WriteFile ( \"policy\" , [] byte ( string ( pBytes )), 777 ); err != nil { return nil , err } validator : = & Validator { Cid : meta . CCID , ChainId : \"\" , Policy : string ( pBytes ), } // Generate MSP config bytes var confStrs [] string for i , value : = range conf . MSPs () { confStrs = append ( confStrs , value . String ()) err : = ioutil . WriteFile ( \"conf\" + strconv . Itoa ( i ), [] byte ( value . String ()), 777 ) if err != nil { return nil , err } } validator . ConfByte = confStrs validatorBytes , err : = json . Marshal ( validator ) if err != nil { return nil , err } if err : = ioutil . WriteFile ( \"validator\" , validatorBytes , 777 ); err != nil { return nil , err } 通过上面代码我们可以看出输出的”validator\"文件就是我们所需要的Fabric验证者信息 3. Hyperchain验证者信息的生成 对于Hyperchain的跨链交易的验证相对于Fabric来说就比较简单了，Hyperchain的交易是由多个节点的多签来确认的，所以我们在构建Hyperchain的验证者信息时可以将参与多签的几个节点的公钥作为数组写入文件中，该文件就是我们所需要的验证者信息。验证规则就是将交易中的多个签名用这个公钥数组组成的验证者信息来进行验证。 4. 其他应用链验证者信息的生成 根据上面的两个例子我们可以得出验证者信息生成的核心思想是如何构建能够验证应用链上链交易的凭证，对于其他应用链，应用链管理员只要构建出这样的凭证以及对应的通过该凭证来验证交易的逻辑（即验证规则）就可以将自己的应用链接入到中继链中进行安全有保证的跨链交易了。","text_tokens":["者","们","发给","2.3","协议","包含","信息","上","max","为","create","get","比如","合约","处理","如果","区块","位于","表达式","就是","%","机构","中继","new","_","endorsement","以","语法结构","generate","ioutil","ccid","用","所以","并","return","channelid","筛选","逐一","链接","链中","嵌套","=","成","proposalresponsepayload","参数信息","存储","简便","confbyte","。","中有","心思","peer","'","这样","wasm","角色","或者","有效","例如","policy","库",",","能够","再","字节","完成","common","validatorbytes","即可","成器","conf","出","两个",";","中","公私","channelprovider","例子","确认","达式","参与","以及","append","client","chaincode","-","validationcode","安全","对","发送给","相对","bitxhub","string"," ","3","proto","和","之后","org","完","组成","执行","符合","marshal","当","形式","key","数据结构","长度","2.2","自己","（","msps","继续","有效性","管理","体","凭证","从而","排序","channelclient","2.1","到","sdk","部署","[","用来","来自","流程","l","data","cauthdsl","endorser","请求","符","给","小于","保证","写入","signature","：","是","作为","这里","一致","querytransaction","成功","一笔",":","工具","action","足够","只","规则","证书","strconv","送给","在","fabsdk","指定","0","签名","只要","or","定义","注意","比较简单","faric","的","与","没有","org1msp","交易","背书","则","对应","重复","管理员","一下","所","同时","nil","chanicode","一个","response",">","上述","入到","for","confstrs","错误","实现","调用","抽取","内置","自动","语法","2.4","+","经过","哈希","字段","接入","合演","由","发出","当前","三个","int32","首先","config","内容","几步","核心思想","其中","go","envelope","引擎","解析","配置","抛出","策略","bytes","也","相符合","来说","分解成","proof","validator","这个","多","分为","上面","然后","1","重要","发过来","其他","id","客户端","体中","!","fabcli","envelop","事件","根据上述","名单","is","什么","json","来","代表","是否","几个","类型","验证","简单","集合","入","endorsements","error","段","指","）","获取","存在","判断","会","即","”","信封","对于","org0","actions","pd","描述","相符","链上","/","pbytes","源","成员","value","下面","writefile","比","集是","range","传入","验签","模拟","pier","of","介绍","pt","已经","org1","支持","相应","链","任意","org3","\"","chaincodeendorsedaction","逻辑","看到","var","某个",")","&","文件","查询","出来","组织","提供","表达","byte","基础","如何","驳回","封装","数量","e","比较","ledger","发来","等","admin","签来","拿到","注册","withorg","fmt","unmarshal","分解","值","常见","transactionenvelope","ibtp","发送","4","格式","公钥","and","函数","接受","可以","username","于","主要","时","需要","编写","mspid","找到","核心","expr","发过","queryconfig","应用","表示","过来","过","每","就","复杂","fail","protos","钥","]","身份","t","}","四种","内","withuser","通过","itoa","成为","i","思想","(","chaincodeactionpayload","跟","校验","fromstring","专门","输出","member","consumer","5","...","所示","chainid","事先","性","proposal","header","并且","n","将","transactionid","结构","实体","errorf","body","生成","会以","表明","processedtransaction","构建","节点","形成","结果","有","集","pb","if","s","transactionaction","payload","考虑","提交","orderer","一条","智能","参数","org2msp","规定","aric","从","proposalresponse","看出","c","任一","cid","特性","fabric","对比","channelcontext","进行","防止","chaincodeproposalpayload","如下","this",".","根据","写","以后","meta","err","都","map","*","暂时","transaction","2","链后","下","\\","多个","字","777","为例","代码","数组","直接","hyperchain","最后","只有","客户","role","跨链","升级","链会","、","多签","阶段","才能","我们","msp","生成器","channel","得出","，","元素","org2","声明","了","交易所","该","以下","{","数据"],"title":"验证者信息生成","title_tokens":["信息","者","验证","生成"]},{"location":"bitxhub/dev/validator/#_1","text":"","text_tokens":[],"title":"验证者信息生成","title_tokens":["信息","者","验证","生成"]},{"location":"bitxhub/dev/validator/#1","text":"验证者信息是应用链接入中继链后用来验证交易存在性和有效性的重要凭证，常见的验证者信息可以包含应用链背书节点的证书或者公私钥。 应用链的管理员需要根据接入应用链的类型和特性，生成能够验证自己应用链跨链交易的验证者信息，下面我们会以Fabric和Hyperchain为例，介绍如何生成验证者信息。","text_tokens":["者","为例","介绍","重要","能够","生成","证书","包含","信息","会以","常见","链"," ","用来","特性","钥","hyperchain","链接","fabric","可以","节点","和","跨链","根据","接入","需要","我们","。","的","中继","如何","交易","背书","下面","类型","验证","，","自己","入","或者","有效","是","性","公私","链后","应用","有效性","管理","管理员","凭证","存在"],"title":"1. 什么是验证者信息","title_tokens":["什么","者","验证","是","信息",".","1"," "]},{"location":"bitxhub/dev/validator/#2-fabric","text":"","text_tokens":[],"title":"2. Fabric验证者信息的生成","title_tokens":["者","验证","生成","fabric","2","信息","的","."," "]},{"location":"bitxhub/dev/validator/#21-fabric","text":"Fabric对于智能合约的执行是在背书节点上进行的，每一个背书节点都会模拟执行chaincode，在模拟执行完chaincode之后，背书节点会对模拟的结果和抛出的事件进行封装，之后再进行签名背书。最后将背书结果发送给客户端。客户端在对比模拟执行的结果之后将背书结果发给orderer节点进行排序，最后在提交阶段会抛出chaincode的事件。","text_tokens":["会","将","发给","排序","再","一个","chaincode","上","送给","在","对","对于","发送","发送给","抛出","客户端","最后","签名","合约","fabric","客户","对比","节点","进行","和","事件","之后","结果","完","执行","阶段","。","都","的","提交","背书","封装","orderer","，","模拟","智能","是","每"],"title":"2.1 Fabric的验证逻辑","title_tokens":["逻辑","验证","fabric","2.1","的"," "]},{"location":"bitxhub/dev/validator/#211-fabric","text":"ProcessedTransaction（位于faric-protos-go->peer->transaction.pb.go）即Fabric存储的已经处理的交易结构。其中包含TransactionEnvelope和ValidationCode两个主要的元素。 字段 类型 描述 TransactionEnvelope *common.Envelope 交易信封，存储处理过的交易信息 ValidationCode int32 是否验证 Envelop(位于faric-protos-go->common->common.pb.go)即存储在区块中一条交易的数据结构。其中Payload（位于faric-protos-go->common->common.pb.go）通过解析可以分解成Header和Data。 字段 类型 描述 Payload []byte 交易信息的byte数组，可以解析为下面的Payload Signature []byte 对Payload的签名 字段 类型 描述 Header *Header 身份信息，防止重复 Data []byte 可以解析为下面的Transaction 其中Data则是存储的Transaction（位于faric-protos-go->peer->transaction.pb.go）的信息。一个Transaction可以包含一个或者多个Actions。 字段 类型 描述 Actions []*TransactionAction TransactionAction的数组，TransactionAction结构如下 字段 类型 描述 Header []byte proposal的header Payload []byte 可以解析成下面的ChaincodeActionPayload结构 TransactionAction中的Payload可以解析成ChaincodeActionPayload（位于faric-protos-go->peer->transaction.pb.go）。 字段 类型 描述 ChaincodeProposalPayload []byte 存储chanicode的proposal的信息 Action *ChaincodeEndorsedAction Chaincode执行结果 其中ChaincodeProposalPayload可以解析成ChaincodeProposalPayload（位于aric-protos-go->peer->proposal.pb.go）。 其中Action则是ChaincodeEndorsedAction（位于faric-protos-go->peer->transaction.pb.go） 字段 类型 描述 ProposalResponsePayload []byte 存储chaincode执行结果 Endorsements []*Endorsement 背书信息 对于ProposalResponsePayload，则可以解析成为ProposalResponsePayload(位于faric-protos-go->peer->proposal_response.pb.go) 对于Endorsements，则是Endorsement的数组，每一个proposal都会有chaincode规定的背书节点们进行签名，Endorsement的结构如下：","text_tokens":["们","包含","信息","为","protos","[","身份","]","处理","通过","envelop","data","区块","位于","成为","(","chaincodeactionpayload","是否","_","endorsement","类型","验证","signature","：","endorsements","是","proposal","header","段","）","会","即","结构","信封","action","在","对于","actions","processedtransaction","签名","描述","节点","结果","有","pb","成","proposalresponsepayload","存储","transactionaction","payload","。","faric","peer","的","交易","下面","背书","一条","则","重复","或者","规定","aric","chanicode","已经","一个","response",">","chaincodeendorsedaction","common","fabric",")","防止","进行","chaincodeproposalpayload","如下",".","都","byte","int32","两个","*","中","transaction","多个","字","其中","数组","go","envelope","chaincode","-","validationcode","分解","对","transactionenvelope","解析"," ","可以","和","主要","执行","分解成","数据结构","，","元素","（","过","每","数据"],"title":"2.1.1 Fabric的存储结构","title_tokens":["存储","结构","fabric","2.1","的",".","1"," "]},{"location":"bitxhub/dev/validator/#212-pier","text":"根据上述的交易结构体，Pier可以根据交易的哈希查询到相应的交易，并从结构体中拿到中继链需要验证的Proof字段。 l , err := ledger . New ( c . consumer . channelProvider ) if err != nil { return nil , err } t , err := l . QueryTransaction ( response . TransactionID ) if err != nil { return nil , err } pd := & common . Payload {} if err := proto . Unmarshal ( t . TransactionEnvelope . Payload , pd ); err != nil { return nil , err } pt := & peer . Transaction {} if err := proto . Unmarshal ( pd . Data , pt ); err != nil { return nil , err } return pt . Actions [ 0 ]. Payload , nil // => this is proof","text_tokens":["return","c","拿到","nil","transactionid","结构",":",",","pt","上述","response",">","unmarshal","相应","到","链","transactionenvelope","actions","["," ","0","体中","!","t","pd","common","}","proto","]","l","可以",")","根据上述","哈希","字段","this",".","根据","=","if","&","data","/","is","(","查询","需要","err","payload","。","proof","peer","的","中继","consumer","交易","new","验证","，","ledger",";","channelprovider","transaction","体","pier","querytransaction","并","从","{"],"title":"2.1.2 Pier获取验证信息","title_tokens":["验证","pier","2","2.1","信息",".","获取"," "]},{"location":"bitxhub/dev/validator/#213-bitxhub","text":"BitXHub在接受到Pier发来的跨链的请求时，会解析请求的结构，校验ProposalResponse的签名，并且比对Body的内容是否和ProposalResponse解析出来的一致，如果上面的阶段结果都一致，则代表校验成功。","text_tokens":["会","结构","body","到","在","解析","对","bitxhub","接受","签名","成功","和","跨链","如果","结果","阶段","时","请求","代表","。","都","是否","出来","的","校验","比","，","上面","则","发来","内容","一致","并且","pier","proposalresponse"],"title":"2.1.3 BitXHub验证","title_tokens":["3","验证","2.1",".","bitxhub"," "]},{"location":"bitxhub/dev/validator/#22-fabric","text":"","text_tokens":[],"title":"2.2 Fabric的复杂背书","title_tokens":["复杂","fabric","的","2.2","背书"," "]},{"location":"bitxhub/dev/validator/#221-fabric","text":"Fabric的背书主要是 验证 Endorser 节点对交易的签名 验证是否有足够数量的节点对交易背书 背书信息来自指定源","text_tokens":["足够","信息","对"," ","指定","来自","签名","fabric","节点","有","主要","endorser","源","是否","的","交易","数量","背书","验证","是"],"title":"2.2.1 Fabric的背书流程","title_tokens":["流程","fabric","的",".","2.2","背书","1"," "]},{"location":"bitxhub/dev/validator/#222","text":"一个实体由 MSP 与 ROLE 定义，即某个组织内的某个角色。其中ROLE支持四种 client, peer, admin, member。例如 Org0.admin 表示 Org0 这个 MSP 下的任意管理员; Org1.member 表示 Org1 这个 MSP 下的任意成员。","text_tokens":["即","其中",",","实体","一个","org1","支持","client","任意","org0"," ","四种","某个","role","内",".","定义","msp","。","由","peer","成员","与","的","组织","这个","member","，","角色",";","管理员","例如","admin","下","管理","表示"],"title":"2.2.2 实体的定义","title_tokens":["实体","2","的",".","定义","2.2"," "]},{"location":"bitxhub/dev/validator/#223","text":"Endorsement Policy 的语法结构如下所示。 EXPR 可以是是 AND 或者 OR 逻辑符。E 是实体或者嵌套的表达式。需要注意的是Fabric暂时只支持1-of-N和MAX-of-N。 // 基础表达式形式 EXPR ( E [, E ... ]) // 需要三个实体都提供签名 AND ( ' Org1 . member ' , ' Org2 . member ' , ' Org3 . member ' ) // 需要两个实体任一提供签名 OR ( ' Org1 . member ' , ' Org2 . member ' ) // 需要Org1的admin提供签名，或者Org2，Org3的member同时提供签名 OR ( ' Org1 . admin ' , AND ( ' Org2 . member ' , ' Org3 . member ' ))","text_tokens":["of","结构","达式",",","实体","org1","只","同时","支持","任一","-","max","org3","["," ","逻辑","and","]","签名","语法","fabric",")","可以","和","如下","or","嵌套",".","注意","/","表达式","(","需要","符","。","形式","都","三个","的","'","提供","表达","member","基础","endorsement","e","所示","...","两个","，","暂时","expr","语法结构","org2","或者","policy","是","admin","n","1"],"title":"2.2.3 表达式","title_tokens":["表达式","3","达式","表达",".","2.2"," "]},{"location":"bitxhub/dev/validator/#224","text":"验证引擎根据应用链注册时提供的验证名单进行背书验证。Fabric所需要的验证者信息时一个map，key为背书节点的mspid，value为背书节点的跟证书。 可以看到复杂验证规则中有AND和OR的规则，根据Fabric的特性，背书策略在chaincode部署以后可以升级，所以考虑到验证规则的升级，对复杂规则的判断也需要写在合约中。合约中需要对以下几步进行验证。 首先是对签名数量验证，比如对于 AND('Org1.member', 'Org2.member', 'Org3.member') ，如果背书数组的长度小于3，即可直接驳回。 如果数量对等，则进行逐一校验，需要注意的是拿到endorser的id以后，需要通过key值找到事先存储在BitXHub中的跟证书信息，再对pier发过来的endorser的证书进行验证，比对一致以后再进行验签。","text_tokens":["者","复杂","信息","到","发过来","为","部署","id","比如","合约","如果","通过","名单","endorser","(","跟","小于","校验","member","验证","事先","是","所以","一致","判断","规则","证书","在","对于","逐一","签名","节点","or","注意","存储","。","中有","考虑","的","'","value","背书","比","则","验签","pier","所",",","再","一个","org1","链","org3","特性","看到","fabric",")","即可","进行","写",".","根据","以后","map","提供","驳回","数量","首先","中","等","几步","注册","拿到","数组","chaincode","直接","值","引擎","对","bitxhub"," ","3","and","策略","可以","和","升级","也","时","需要","key","mspid","找到","长度","，","org2","发过","应用","过来","以下"],"title":"2.2.4 验证引擎的验证","title_tokens":["验证","4","的","引擎",".","2.2"," "]},{"location":"bitxhub/dev/validator/#225","text":"BitXHub提供了背书策略的智能合约库，当部署验证合约时，只要将背书策略的表达式即可完成对背书策略的声明，当一笔跨链交易经过验证引擎时，验证引擎会根据部署的智能合约自动的调用内置的背书策略库，对验证者信息进行合演筛选。","text_tokens":["库","会","将","者","达式","信息","完成","对","引擎","筛选","部署","bitxhub","调用","策略","自动","合约","内置","即可","经过","跨链","只要","进行","根据","表达式","时","当","合演","。","的","提供","表达","交易","背书","验证","，","声明","智能","了","一笔"],"title":"2.2.5 智能合约库","title_tokens":["库","合约","智能",".","2.2","5"," "]},{"location":"bitxhub/dev/validator/#23-fabric","text":"","text_tokens":[],"title":"2.3. 验证引擎对Fabric的验证流程","title_tokens":["验证","流程","2.3","fabric","的","引擎","对","."," "]},{"location":"bitxhub/dev/validator/#231","text":"应用链在注册到BitXHub时需要提交验证者的信息，在这里我们将Fabric的验证者信息以json的格式提交到BitXHub进行注册。主要分为下面三个字段： 证书信息：证书信息为Fabric的msp信息，包含了机构、成员、角色以及证书的信息。是msp.MSP的数组。 背书策略的byte的数组。通过Fabric的cauthdsl.FromString()函数生成的策略字节数组 chaincode的id，用来验证交易是由规定的chaincode发出的。","text_tokens":["者","注册","将","数组","以及","生成","证书","包含","信息","到","字节","在","链","chaincode","为","bitxhub"," ","格式","id","用来","函数","策略","fabric",")","进行","通过","主要","、",".","cauthdsl","(","json","时","需要","我们","msp","。","由","发出","成员","三个","的","机构","fromstring","byte","提交","下面","以","背书","分为","交易","验证","，","角色","：","是","应用","了","这里","段","规定","字"],"title":"2.3.1 应用链注册","title_tokens":["注册","2.3","应用","链",".","1"," "]},{"location":"bitxhub/dev/validator/#232","text":"应用链会通过IBTP协议发送跨链交易到BitXHub，BitXHub需要对IBTP中的Proof字段进行验证，从而验证跨链交易的有效性。对于Fabric来说Proof字段的内容为交易结构中Transaction.Actions[0].Payload。Pier节点将这个作为Proof字段封装到IBTP然后发送给BitXHub。","text_tokens":["将","从而","结构","协议","到","送给","对","发送给","ibtp","发送","对于","为","actions","bitxhub","[","0","]","fabric","节点","通过","跨链","进行","字段",".","需要","来说","payload","。","proof","的","这个","交易","封装","验证","，","中","内容","有效","transaction","然后","作为","有效性","应用","pier","链会"],"title":"2.3.2 应用链发送跨链交易","title_tokens":["2.3","发送","2","跨链","应用","链",".","交易"," "]},{"location":"bitxhub/dev/validator/#233-proof","text":"验证引擎提供了专门给Fabric的wasm验证库从而简便wasm合约的编写。 1） 首先需要从proof字段中抽取出交易结构，然后对交易结构中的chaincode的id进行校验，只有和注册时表明的chaincode的id相符合才能继续进行验证。 2） 从交易结构中抽取出签名集，签名集是指多个背书节点对proposal背书形成的签名的集合。 3） 将应用链注册时传入的Fabric的msp的配置传入策略生成器，获取可以验证当前应用链的msp的策略验证工具。 3） 将签名集和验证策略传入到策略验证工具进行验证，没有错误即为验证成功。","text_tokens":["从而","到","为","id","合约","给","校验","专门","验证","集合","proposal","指","成功","）","获取","将","结构","即","工具","生成","表明","签名","节点","相符","形成","集","简便","。","的","没有","交易","背书","wasm","集是","传入","从","库","错误","链","抽取","fabric","进行","字段","成器","当前","出","提供","首先","中","2","多个","注册","chaincode","引擎","对","配置"," ","3","策略","只有","可以","和","符合","才能","时","需要","相符合","编写","msp","生成器","proof","，","然后","继续","了","应用","1"],"title":"2.3.3 验证Proof","title_tokens":["3","验证","2.3","proof","."," "]},{"location":"bitxhub/dev/validator/#24-fabric","text":"Fabric验证者信息的生成主要是通过Fabric的验证代码来实现，我们获取了Fabric验证交易所需要的一下信息来为我们验证Fabric跨链交易提供参数信息。 channelProvider : = sdk . ChannelContext ( meta . ChannelID , fabsdk . WithUser ( meta . Username ), fabsdk . WithOrg ( meta . ORG )) channelClient , err : = channel . New ( channelProvider ) if err != nil { return nil , fmt . Errorf ( \"create channel fabcli fail: %s \\n \" , err . Error ()) } l , err : = ledger . New ( channelProvider ) if err != nil { return nil , err } // Get Fabric Channel Config conf , err : = l . QueryConfig () if err != nil { return nil , err } // Generate Policy Bytes policy , err : = cauthdsl . FromString ( \"AND('Org2MSP.peer', 'Org1MSP.peer')\" ) if err != nil { return nil , err } pBytes , err : = proto . Marshal ( policy ) if err != nil { return nil , err } if err : = ioutil . WriteFile ( \"policy\" , [] byte ( string ( pBytes )), 777 ); err != nil { return nil , err } validator : = & Validator { Cid : meta . CCID , ChainId : \"\" , Policy : string ( pBytes ), } // Generate MSP config bytes var confStrs [] string for i , value : = range conf . MSPs () { confStrs = append ( confStrs , value . String ()) err : = ioutil . WriteFile ( \"conf\" + strconv . Itoa ( i ), [] byte ( value . String ()), 777 ) if err != nil { return nil , err } } validator . ConfByte = confStrs validatorBytes , err : = json . Marshal ( validator ) if err != nil { return nil , err } if err : = ioutil . WriteFile ( \"validator\" , validatorBytes , 777 ); err != nil { return nil , err } 通过上面代码我们可以看出输出的”validator\"文件就是我们所需要的Fabric验证者信息","text_tokens":["者","channelclient","fail","信息","为","sdk","create","[","get","!","]","fabcli","}","withuser","l","通过","itoa","cauthdsl","i","(","json","就是","来","%","fromstring","输出","new","验证","chainid","generate","是","ioutil","ccid","error","n","获取","return",":","errorf","”","生成","strconv","channelid","fabsdk","=","if","s","/","参数信息","confbyte","pbytes","。","peer","的","'","value","org1msp","交易","writefile","range","policy","参数","org2msp","一下","所","看出","nil",",","for","confstrs","cid","\"","实现","var","validatorbytes","fabric","channelcontext",")","+",".","&","文件","conf","meta","err","提供","byte","config","ledger",";","channelprovider","\\","777","withorg","fmt","代码","append","string"," ","and","proto","bytes","可以","username","跨链","org","主要","需要","我们","marshal","msp","channel","validator","上面","，","queryconfig","msps","了","交易所","{"],"title":"2.4. Fabric验证者信息生成","title_tokens":["者","验证","2.4","fabric","生成","信息","."," "]},{"location":"bitxhub/dev/validator/#3-hyperchain","text":"对于Hyperchain的跨链交易的验证相对于Fabric来说就比较简单了，Hyperchain的交易是由多个节点的多签来确认的，所以我们在构建Hyperchain的验证者信息时可以将参与多签的几个节点的公钥作为数组写入文件中，该文件就是我们所需要的验证者信息。验证规则就是将交易中的多个签名用这个公钥数组组成的验证者信息来进行验证。","text_tokens":["者","确认","将","参与","数组","规则","信息","在","对于","相对","hyperchain","公钥","签名","构建","fabric","该","于","节点","可以","跨链","进行","文件","比较简单","多签","组成","时","就是","来说","我们","需要","。","来","由","的","几个","这个","写入","交易","多","比较","验证","，","简单","中","是","用","作为","了","签来","所以","多个","就","所"],"title":"3. Hyperchain验证者信息的生成","title_tokens":["者","3","hyperchain","验证","生成","信息","的","."," "]},{"location":"bitxhub/dev/validator/#4","text":"根据上面的两个例子我们可以得出验证者信息生成的核心思想是如何构建能够验证应用链上链交易的凭证，对于其他应用链，应用链管理员只要构建出这样的凭证以及对应的通过该凭证来验证交易的逻辑（即验证规则）就可以将自己的应用链接入到中继链中进行安全有保证的跨链交易了。","text_tokens":["者","将","即","能够","生成","以及","规则","入到","信息","安全","链","对于","就","其他","逻辑","链接","链中","构建","可以","通过","进行","只要","链上","跨链","有","根据","思想","我们","来","。","心思","保证","的","出","中继","这样","如何","交易","两个","上面","得出","验证","核心","，","对应","（","自己","管理员","是","例子","应用","管理","了","凭证","）","该","核心思想"],"title":"4. 其他应用链验证者信息的生成","title_tokens":["者","验证","生成","信息","应用","的","链",".","4","其他"," "]},{"location":"bitxhub/dev/cmd/bitxhub_client/","text":"bitxhub client 功能 该命令 bitxhub client 提供中继链节点的客户端操作命令。 它包含了账户信息查询、中继链信息、区块查询、节点网络信息、回执查询、交易操作、验证者集查询、删除共识节点、提案治理、did指令。 子命令信息如下: bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client NAME: BitXHub client - BitXHub client command USAGE: BitXHub client command [command options] [arguments...] COMMANDS: account Query account information chain Query bitxhub chain info block Query block network Query network info from node receipt Query receipt tx Transaction manipulation validators Query validator address delVPNode delete a vp node governance governance command did did command 参数 gateway : 指定客户端http服务地址，如果节点开启了TLS功能，则需要传递https地址； cert : 指定节点的CA证书，如果节点开始了TLS功能，需要传递； OPTIONS: --gateway value Specific gateway address (default: \"http://localhost:9091/v1/\") --cert value Specific ca cert file if https is enabled --help, -h show help 子命令 bitxhub client account 账户信息查询 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client account 0x79a1215469FaB6f9c63c1816b45183AD3624bE34 { \"type\": \"normal\", \"balance\": 100000000, \"contract_count\": 0, \"code_hash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" } bitxhub client chain 中继链信息查询 NAME: BitXHub client chain - Query bitxhub chain info USAGE: BitXHub client chain command [command options] [arguments...] COMMANDS: meta Query bitxhub chain meta status Query bitxhub chain status OPTIONS: --help, -h show help - normal : 已处在共识状态 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client chain meta {\"height\":\"1\",\"block_hash\":\"0x0BF41c03bE038e389470dBdC9ed53DF897F178921520AF37877188d1759A7068\"} bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client chain status normal bitxhub client block 区块信息查询 - 可指定区块号或区块Hash bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client block 3 { \"block_header\": { \"number\": \"3\", \"state_root\": \"0xA4E28e95578F5b4276C766810e9673F674a850EE876b319956761fbA1d3d8269\", \"tx_root\": \"0x7ffC813435b4D09acE5A2c6A33a51cd4bDf3b114cb292a3Ad2ca29c44ec8d5FB\", \"receipt_root\": \"0x2b57252fCe72cA03e7C28Ee220Fe8946fD0D6038Ca1398a19A8D5c354aFF68Bc\", \"parent_hash\": \"0xd3363F8f667c891c388fED72BbBE091e6A888b2B70920FA9e115539848e8C9B5\", \"timestamp\": \"1638243559049301000\", \"version\": \"MS4wLjA=\", \"Bloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" }, \"transactions\": { \"Transactions\": [ { \"from\": \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\", \"to\": \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\", \"timestamp\": 1638243558643356000, \"transaction_hash\": \"0x1947a1339F0C27157f76bB40ea4E68b1a9B4b1AFAd0055fBE24885CC6Ea87e63\", \"payload\": \"EgEy\", \"signature\": \"SMIlWc7qFn6r3WdcvJslSSjAl/PzEW0gIxZB+Ey6zRwFx3bjJdJD+JQ1xPAjyUXP8M+Bc2szRN9KoIAw85WIvwE=\" } ] }, \"block_hash\": \"0x39e9364747342A9A48055C13eBbDDE3F19415bfaB19E58375CDa8Eccb4d5c7DB\", \"signature\": \"qQIIEtSdXUxnVD8lXRrvwNJ0gUk4DS9X8w9c9EvlHMsbBSrVSy6+0mUx5ZT/m2coutpzSupDeRiFo5bfmTRK4gE=\" } bitxhub client network 全网节点信息 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client network { \"1\": { \"id\": 1, \"pid\": \"QmXi58fp9ZczF3Z5iz1yXAez3Hy5NYo1R8STHWKEM9XnTL\", \"account\": \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\", \"hosts\": [ \"/ip4/127.0.0.1/tcp/4001/p2p/\" ] }, \"2\": { \"id\": 2, \"pid\": \"QmbmD1kzdsxRiawxu7bRrteDgW1ituXupR8GH6E2EUAHY4\", \"account\": \"0x79a1215469FaB6f9c63c1816b45183AD3624bE34\", \"hosts\": [ \"/ip4/127.0.0.1/tcp/4002/p2p/\" ] }, \"3\": { \"id\": 3, \"pid\": \"QmQUcDYCtqbpn5Nhaw4FAGxQaSSNvdWfAFcpQT9SPiezbS\", \"account\": \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\", \"hosts\": [ \"/ip4/127.0.0.1/tcp/4003/p2p/\" ] }, \"4\": { \"id\": 4, \"pid\": \"QmQW3bFn8XX1t4W14Pmn37bPJUpUVBrBjnPuBZwPog3Qdy\", \"account\": \"0xc0Ff2e0b3189132D815b8eb325bE17285AC898f8\", \"hosts\": [ \"/ip4/127.0.0.1/tcp/4004/p2p/\" ] } } bitxhub client receipt 交易回执查询 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client receipt 0x1947a1339F0C27157f76bB40ea4E68b1a9B4b1AFAd0055fBE24885CC6Ea87e63 { \"tx_hash\": \"0x1947a1339F0C27157f76bB40ea4E68b1a9B4b1AFAd0055fBE24885CC6Ea87e63\", \"ret\": null, \"status\": 0, \"events\": [], \"gas_used\": \"21000\", \"bloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } bitxhub client tx 简单交易 交易发送 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client tx send --key scripts/build/node1/key.json --to 0x97c8B516D19edBf575D72a172Af7F418BE498C37 --amount 2 --type 0 {\"tx_hash\":\"0x08ab0E9175ae67Aed7a085D6813C156e4ED3b49cDf902e02280F6a62d7AaD61E\"} 交易查询 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client tx get 0x1947a1339F0C27157f76bB40ea4E68b1a9B4b1AFAd0055fBE24885CC6Ea87e63 { \"txs\": { \"Transactions\": [ { \"from\": \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\", \"to\": \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\", \"timestamp\": 1638243558643356000, \"transaction_hash\": \"0x1947a1339F0C27157f76bB40ea4E68b1a9B4b1AFAd0055fBE24885CC6Ea87e63\", \"payload\": \"EgEy\", \"signature\": \"SMIlWc7qFn6r3WdcvJslSSjAl/PzEW0gIxZB+Ey6zRwFx3bjJdJD+JQ1xPAjyUXP8M+Bc2szRN9KoIAw85WIvwE=\" } ] }, \"tx_meta\": [ { \"block_hash\": \"Oek2R0c0KppIBVwT673ePxlBW/qxnlg3XNqOzLTVx9s=\", \"block_height\": \"3\" } ] } bitxhub client validators 全网验证人信息 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client validators [ \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\", \"0x79a1215469FaB6f9c63c1816b45183AD3624bE34\", \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\", \"0xc0Ff2e0b3189132D815b8eb325bE17285AC898f8\" ] bitxhub client delVPNode 动态删除共识节点 NAME: BitXHub client delVPNode - delete a vp node USAGE: BitXHub client delVPNode [command options] [arguments...] OPTIONS: --pid value pid of vp node bitxhub client governance 提案治理命令 NAME: BitXHub client governance - governance command USAGE: BitXHub client governance command [command options] [arguments...] COMMANDS: vote vote to a proposal proposals query proposals based on the condition chain appchain manage command rule rule manage command node node manage command role role manage command dapp dapp manage command 规则管理 NAME: BitXHub client governance rule - rule manage command USAGE: BitXHub client governance rule command [command options] [arguments...] COMMANDS: all query all rules info of one chain available query available rule address of a chain status query rule status by rule address and chain id update update master rule with chain id 节点管理 NAME: BitXHub client governance node - node manage command USAGE: BitXHub client governance node command [command options] [arguments...] COMMANDS: status query node status by node pid register register node logout logout node by node pid all query all nodes info 角色管理 NAME: BitXHub client governance role - role manage command USAGE: BitXHub client governance role command [command options] [arguments...] COMMANDS: status query role status by role id register register role update update node for auditAdmin freeze freeze role by role id activate activate role by role id logout logout role by role id all query all roles info dapp管理 NAME: BitXHub client governance dapp - dapp manage command USAGE: BitXHub client governance dapp command [command options] [arguments...] COMMANDS: status query dapp status by dapp id myDapps query dapps by owner addr register register dapp update update dapp freeze freeze dapp by dapp id activate activate dapp by dapp id transfer transfer dapp to other user confirm confirm dapp transfer evaluate evaluate dapp 提案投票 命令参数 NAME: BitXHub client governance vote - vote to a proposal USAGE: BitXHub client governance vote [command options] [arguments...] OPTIONS: --id value proposal id --info value voting information, approve or reject --reason value reason to vote 样例 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client governance vote --info approve --reason test --id 0x9A601dbebf20f3E3362241810C2229F7f97329d6-0 vote successfully! 0x9A601dbebf20f3E3362241810C2229F7f97329d6-0 提案查询 id: 提案id type: 提案类型，当前支持应用链管理 status: 提案状态，是否通过 from: 提案者地址 NAME: BitXHub client governance proposals - query proposals based on the condition USAGE: BitXHub client governance proposals [command options] [arguments...] OPTIONS: --id value proposal id --type value proposal type, currently only AppchainMgr is supported --status value proposal status, one of proposed, approve or reject --from value the address of the account to which the proposal was made 应用链管理 status:查询应用链状态 freeze:应用链冻结 activate:应用链激活 NAME: BitXHub client governance chain - appchain manage command USAGE: BitXHub client governance chain command [command options] [arguments...] COMMANDS: status query chain status by chain id freeze freeze appchain by chain id activate activate chain by chain id bitxhub client did 提案治理命令 NAME: BitXHub client did - did command USAGE: BitXHub client did command [command options] [arguments...] COMMANDS: init init method-registry contract addAdmin add admin role for method-registry contract","text_tokens":["governance","者","command","m2coutpzsupderifo5bfmtrk4ge","proposed","包含","信息","windiyi","send","qmqucdyctqbpn5nhaw4fagxqassnvdwfafcpqt9spiezbs","0x9a601dbebf20f3e3362241810c2229f7f97329d6","号","manage","治理","!","[","condition","id","node1","get","客户端","]","commands","cert","；","register","}","to","usage","0x0000000000000000000000000000000000000000000000000000000000000000","0x7ffc813435b4d09ace5a2c6a33a51cd4bdf3b114cb292a3ad2ca29c44ec8d5fb","bc2szrn9koiaw85wivwe","如果","通过","开启","{","delvpnode","is","区块","操作命令","used","txs","based","add","(","0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","specific","qqiietsdxuxnvd8lxrrvwnj0guk4ds9x8w9c9evlhmsbbsrvsy6","json","node3","0x1947a1339f0c27157f76bb40ea4e68b1a9b4b1afad0055fbe24885cc6ea87e63","动态","with","0x79a1215469fab6f9c63c1816b45183ad3624be34","parent","是否","receipt","options","qmqw3bfn8xx1t4w14pmn37bpjupuvbrbjnpubzwpog3qdy","中继","supported","only","version","_","activate","...","类型","mydapps","验证","type","timestamp","signature","简单","confirm","one","manipulation","proposal","header","0xd3363f8f667c891c388fed72bbbe091e6a888b2b70920fa9e115539848e8c9b5","共识","pzew0gixzb","address","bloom","tls","rule","evaluate",":","操作","冻结","0xc0ff2e0b3189132d815b8eb325be17285ac898f8","规则","reject","appchainmgr","证书","logout","addadmin","0.1","users","dapp","transfer","指定","传递","0","0x2b57252fce72ca03e7c28ee220fe8946fd0d6038ca1398a19a8d5c354aff68bc","节点","arguments","from","处在","回执","0x08ab0e9175ae67aed7a085d6813c156e4ed3b49cdf902e02280f6a62d7aad61e","nodes","other","or","account","集","=","if","on","/","localhost","1638243559049301000","update","vp","did","tx","状态","payload","。","auditadmin","show","的","value","可","the","was","交易","4003","则","0x39e9364747342a9a48055c13ebbdde3f19415bfab19e58375cda8eccb4d5c7db","information","proposals","角色","master","default","激活","0x0bf41c03be038e389470dbdc9ed53df897f178921520af37877188d1759a7068","参数","hosts","已","root","qmbmd1kzdsxriawxu7brrtedgw1ituxupr8gh6e2euahy4","query","vote","name","pid","1638243558643356000","egey","指令","gateway","of","enabled",",","appchain","available","reason","支持","for","contract","info","链","\"","state","user","100000000","smilwc7qfn6r3wdcvjslssjal","+","ip4",")","status","repo","height","如下","test","all",".","0mux5zt","null","rules","roles","build","meta","events","count","qmxi58fp9zczf3z5iz1yxaez3hy5nyo1r8sthwkem9xntl","查询","0x97c8b516d19edbf575d72a172af7f418be498c37","network","addr","9091","ms4wlja","当前","node","number","hash","提供","amount","命令","样例","子","提案","或","normal","transactions","tcp","freeze","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013","transaction","block","2","gas","admin","https","owner","功能","21000","--","删除","validators","help","client","-","code","1","发送","h","bitxhub","4"," ","dapps","投票","3","by","chain","and","它","approve","init","qxnlg3xnqozltvx9s","客户","role","4002","which","delete","网络","、","全网","0xa4e28e95578f5b4276c766810e9673f674a850ee876b319956761fba1d3d8269","jq1xpajyuxp8m","人","需要","4004","registry","ey6zrwfx3bjjdjd","ideaprojects","127.0","ret","scripts","key","validator","made","method","p2p","file","4001","a","http","v1","voting","，","balance","服务","currently","successfully","地址","ca","了","管理","应用","oek2r0c0kppibvwt673epxlbw","该","开始","账户"],"title":"bitxhub client","title_tokens":["client","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_client/#bitxhub-client","text":"","text_tokens":[],"title":"bitxhub client","title_tokens":["client","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_client/#_1","text":"该命令 bitxhub client 提供中继链节点的客户端操作命令。 它包含了账户信息查询、中继链信息、区块查询、节点网络信息、回执查询、交易操作、验证者集查询、删除共识节点、提案治理、did指令。 子命令信息如下: bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client NAME: BitXHub client - BitXHub client command USAGE: BitXHub client command [command options] [arguments...] COMMANDS: account Query account information chain Query bitxhub chain info block Query block network Query network info from node receipt Query receipt tx Transaction manipulation validators Query validator address delVPNode delete a vp node governance governance command did did command","text_tokens":["governance","者","command","包含","信息","windiyi","治理","[","客户端","]","commands","usage","delvpnode","区块","操作命令","node3","receipt","options","中继","...","验证","manipulation","共识","address",":","操作","users","节点","arguments","from","回执","account","集","=","/","vp","did","tx","。","的","交易","information","query","name","指令","info","链","repo","如下","build","查询","network","node","提供","命令","子","提案","transaction","block","--","删除","validators","client","-","bitxhub"," ","chain","它","客户","delete","网络","、","ideaprojects","scripts","validator","a","了","该","账户"],"title":"功能","title_tokens":["功能"]},{"location":"bitxhub/dev/cmd/bitxhub_client/#_2","text":"gateway : 指定客户端http服务地址，如果节点开启了TLS功能，则需要传递https地址； cert : 指定节点的CA证书，如果节点开始了TLS功能，需要传递； OPTIONS: --gateway value Specific gateway address (default: \"http://localhost:9091/v1/\") --cert value Specific ca cert file if https is enabled --help, -h show help","text_tokens":["--","gateway",":","enabled",",","help","证书","-","\"","h"," ","指定","传递","客户端","cert","；","客户",")","节点","如果","开启","is","if","/","localhost","(","specific","需要","show","9091","options","的","value","file","http","v1","，","则","服务","default","地址","ca","了","https","address","tls","功能","开始"],"title":"参数","title_tokens":["参数"]},{"location":"bitxhub/dev/cmd/bitxhub_client/#_3","text":"","text_tokens":[],"title":"子命令","title_tokens":["命令","子"]},{"location":"bitxhub/dev/cmd/bitxhub_client/#bitxhub-client-account","text":"账户信息查询 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client account 0x79a1215469FaB6f9c63c1816b45183AD3624bE34 { \"type\": \"normal\", \"balance\": 100000000, \"contract_count\": 0, \"code_hash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" }","text_tokens":["--",":",",","client","windiyi","信息","contract","code","users","\"","bitxhub"," ","0","100000000","}","0x0000000000000000000000000000000000000000000000000000000000000000","repo","account","=","/","build","count","查询","node3","0x79a1215469fab6f9c63c1816b45183ad3624be34","ideaprojects","scripts","hash","_","type","balance","normal","{","账户"],"title":"bitxhub client account","title_tokens":["client","account","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_client/#bitxhub-client-chain","text":"中继链信息查询 NAME: BitXHub client chain - Query bitxhub chain info USAGE: BitXHub client chain command [command options] [arguments...] COMMANDS: meta Query bitxhub chain meta status Query bitxhub chain status OPTIONS: --help, -h show help - normal : 已处在共识状态 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client chain meta {\"height\":\"1\",\"block_hash\":\"0x0BF41c03bE038e389470dBdC9ed53DF897F178921520AF37877188d1759A7068\"} bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client chain status normal","text_tokens":["--",":","command",",","help","client","-","信息","info","windiyi","链","users","1","\"","h","bitxhub","["," ","chain","]","commands","}","usage","arguments","status","处在","repo","height","=","/","build","meta","查询","状态","node3","show","ideaprojects","scripts","options","hash","中继","_","...","normal","0x0bf41c03be038e389470dbdc9ed53df897f178921520af37877188d1759a7068","block","已","共识","query","name","{"],"title":"bitxhub client chain","title_tokens":["client","chain","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_client/#bitxhub-client-block","text":"区块信息查询 - 可指定区块号或区块Hash bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client block 3 { \"block_header\": { \"number\": \"3\", \"state_root\": \"0xA4E28e95578F5b4276C766810e9673F674a850EE876b319956761fbA1d3d8269\", \"tx_root\": \"0x7ffC813435b4D09acE5A2c6A33a51cd4bDf3b114cb292a3Ad2ca29c44ec8d5FB\", \"receipt_root\": \"0x2b57252fCe72cA03e7C28Ee220Fe8946fD0D6038Ca1398a19A8D5c354aFF68Bc\", \"parent_hash\": \"0xd3363F8f667c891c388fED72BbBE091e6A888b2B70920FA9e115539848e8C9B5\", \"timestamp\": \"1638243559049301000\", \"version\": \"MS4wLjA=\", \"Bloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" }, \"transactions\": { \"Transactions\": [ { \"from\": \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\", \"to\": \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\", \"timestamp\": 1638243558643356000, \"transaction_hash\": \"0x1947a1339F0C27157f76bB40ea4E68b1a9B4b1AFAd0055fBE24885CC6Ea87e63\", \"payload\": \"EgEy\", \"signature\": \"SMIlWc7qFn6r3WdcvJslSSjAl/PzEW0gIxZB+Ey6zRwFx3bjJdJD+JQ1xPAjyUXP8M+Bc2szRN9KoIAw85WIvwE=\" } ] }, \"block_hash\": \"0x39e9364747342A9A48055C13eBbDDE3F19415bfaB19E58375CDa8Eccb4d5c7DB\", \"signature\": \"qQIIEtSdXUxnVD8lXRrvwNJ0gUk4DS9X8w9c9EvlHMsbBSrVSy6+0mUx5ZT/m2coutpzSupDeRiFo5bfmTRK4gE=\" }","text_tokens":["--","1638243558643356000","egey",":",",","m2coutpzsupderifo5bfmtrk4ge","client","-","信息","windiyi","users","号","\"","state","bitxhub","["," ","指定","3","]","0x2b57252fce72ca03e7c28ee220fe8946fd0d6038ca1398a19a8d5c354aff68bc","}","to","smilwc7qfn6r3wdcvjslssjal","0x7ffc813435b4d09ace5a2c6a33a51cd4bdf3b114cb292a3ad2ca29c44ec8d5fb","+","bc2szrn9koiaw85wivwe","from","repo","=","区块","0xa4e28e95578f5b4276c766810e9673f674a850ee876b319956761fba1d3d8269","0mux5zt","/","build","1638243559049301000","jq1xpajyuxp8m","qqiietsdxuxnvd8lxrrvwnj0guk4ds9x8w9c9evlhmsbbsrvsy6","tx","0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","查询","node3","0x97c8b516d19edbf575d72a172af7f418be498c37","0x1947a1339f0c27157f76bb40ea4e68b1a9b4b1afad0055fbe24885cc6ea87e63","payload","parent","ey6zrwfx3bjjdjd","ideaprojects","receipt","ms4wlja","scripts","number","hash","可","version","_","或","timestamp","signature","0x39e9364747342a9a48055c13ebbdde3f19415bfab19e58375cda8eccb4d5c7db","transactions","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013","transaction","block","header","0xd3363f8f667c891c388fed72bbbe091e6a888b2b70920fa9e115539848e8c9b5","pzew0gixzb","root","bloom","{"],"title":"bitxhub client block","title_tokens":["client","bitxhub","block"," "]},{"location":"bitxhub/dev/cmd/bitxhub_client/#bitxhub-client-network","text":"全网节点信息 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client network { \"1\": { \"id\": 1, \"pid\": \"QmXi58fp9ZczF3Z5iz1yXAez3Hy5NYo1R8STHWKEM9XnTL\", \"account\": \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\", \"hosts\": [ \"/ip4/127.0.0.1/tcp/4001/p2p/\" ] }, \"2\": { \"id\": 2, \"pid\": \"QmbmD1kzdsxRiawxu7bRrteDgW1ituXupR8GH6E2EUAHY4\", \"account\": \"0x79a1215469FaB6f9c63c1816b45183AD3624bE34\", \"hosts\": [ \"/ip4/127.0.0.1/tcp/4002/p2p/\" ] }, \"3\": { \"id\": 3, \"pid\": \"QmQUcDYCtqbpn5Nhaw4FAGxQaSSNvdWfAFcpQT9SPiezbS\", \"account\": \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\", \"hosts\": [ \"/ip4/127.0.0.1/tcp/4003/p2p/\" ] }, \"4\": { \"id\": 4, \"pid\": \"QmQW3bFn8XX1t4W14Pmn37bPJUpUVBrBjnPuBZwPog3Qdy\", \"account\": \"0xc0Ff2e0b3189132D815b8eb325bE17285AC898f8\", \"hosts\": [ \"/ip4/127.0.0.1/tcp/4004/p2p/\" ] } }","text_tokens":["pid","--",":",",","0xc0ff2e0b3189132d815b8eb325be17285ac898f8","client","windiyi","信息","1","users","0.1","qmqucdyctqbpn5nhaw4fagxqassnvdwfafcpqt9spiezbs","\"","4","bitxhub","["," ","id","3","]","}","ip4","4002","节点","repo","account","=","全网",".","/","build","qmxi58fp9zczf3z5iz1yxaez3hy5nyo1r8sthwkem9xntl","0x97c8b516d19edbf575d72a172af7f418be498c37","node3","4004","0x79a1215469fab6f9c63c1816b45183ad3624be34","network","ideaprojects","127.0","scripts","qmqw3bfn8xx1t4w14pmn37bpjupuvbrbjnpubzwpog3qdy","p2p","4001","4003","tcp","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013","2","hosts","qmbmd1kzdsxriawxu7brrtedgw1ituxupr8gh6e2euahy4","{"],"title":"bitxhub client network","title_tokens":["client","network","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_client/#bitxhub-client-receipt","text":"交易回执查询 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client receipt 0x1947a1339F0C27157f76bB40ea4E68b1a9B4b1AFAd0055fBE24885CC6Ea87e63 { \"tx_hash\": \"0x1947a1339F0C27157f76bB40ea4E68b1a9B4b1AFAd0055fBE24885CC6Ea87e63\", \"ret\": null, \"status\": 0, \"events\": [], \"gas_used\": \"21000\", \"bloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" }","text_tokens":["21000","--",":",",","client","windiyi","users","\"","bitxhub","["," ","0","]","}","status","repo","回执","null","=","used","/","build","events","tx","0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","查询","node3","0x1947a1339f0c27157f76bb40ea4e68b1a9b4b1afad0055fbe24885cc6ea87e63","ideaprojects","receipt","ret","scripts","hash","交易","_","gas","bloom","{"],"title":"bitxhub client receipt","title_tokens":["client","bitxhub","receipt"," "]},{"location":"bitxhub/dev/cmd/bitxhub_client/#bitxhub-client-tx","text":"简单交易","text_tokens":["交易","简单"],"title":"bitxhub client tx","title_tokens":["client","tx","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_client/#_4","text":"bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client tx send --key scripts/build/node1/key.json --to 0x97c8B516D19edBf575D72a172Af7F418BE498C37 --amount 2 --type 0 {\"tx_hash\":\"0x08ab0E9175ae67Aed7a085D6813C156e4ED3b49cDf902e02280F6a62d7AaD61E\"}","text_tokens":["--",":","client","windiyi","send","users","\"","bitxhub"," ","node1","0","to","}","0x08ab0e9175ae67aed7a085d6813c156e4ed3b49cdf902e02280f6a62d7aad61e","repo",".","=","/","build","tx","json","0x97c8b516d19edbf575d72a172af7f418be498c37","node3","ideaprojects","key","scripts","hash","amount","_","type","2","{"],"title":"交易发送","title_tokens":["发送","交易"]},{"location":"bitxhub/dev/cmd/bitxhub_client/#_5","text":"bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client tx get 0x1947a1339F0C27157f76bB40ea4E68b1a9B4b1AFAd0055fBE24885CC6Ea87e63 { \"txs\": { \"Transactions\": [ { \"from\": \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\", \"to\": \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\", \"timestamp\": 1638243558643356000, \"transaction_hash\": \"0x1947a1339F0C27157f76bB40ea4E68b1a9B4b1AFAd0055fBE24885CC6Ea87e63\", \"payload\": \"EgEy\", \"signature\": \"SMIlWc7qFn6r3WdcvJslSSjAl/PzEW0gIxZB+Ey6zRwFx3bjJdJD+JQ1xPAjyUXP8M+Bc2szRN9KoIAw85WIvwE=\" } ] }, \"tx_meta\": [ { \"block_hash\": \"Oek2R0c0KppIBVwT673ePxlBW/qxnlg3XNqOzLTVx9s=\", \"block_height\": \"3\" } ] }","text_tokens":["--","1638243558643356000","egey",":",",","client","windiyi","users","\"","bitxhub","["," ","get","3","]","to","smilwc7qfn6r3wdcvjslssjal","bc2szrn9koiaw85wivwe","+","}","qxnlg3xnqozltvx9s","from","repo","height","=","txs","/","build","meta","jq1xpajyuxp8m","tx","0x97c8b516d19edbf575d72a172af7f418be498c37","node3","0x1947a1339f0c27157f76bb40ea4e68b1a9b4b1afad0055fbe24885cc6ea87e63","payload","ey6zrwfx3bjjdjd","ideaprojects","scripts","hash","_","timestamp","signature","transactions","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013","transaction","block","pzew0gixzb","oek2r0c0kppibvwt673epxlbw","{"],"title":"交易查询","title_tokens":["交易","查询"]},{"location":"bitxhub/dev/cmd/bitxhub_client/#bitxhub-client-validators","text":"全网验证人信息 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client validators [ \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\", \"0x79a1215469FaB6f9c63c1816b45183AD3624bE34\", \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\", \"0xc0Ff2e0b3189132D815b8eb325bE17285AC898f8\" ]","text_tokens":["--",",","validators","0xc0ff2e0b3189132d815b8eb325be17285ac898f8","client","windiyi","信息","users","\"","bitxhub","["," ","]","repo","=","全网","/","build","人","0x97c8b516d19edbf575d72a172af7f418be498c37","node3","0x79a1215469fab6f9c63c1816b45183ad3624be34","ideaprojects","scripts","验证","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013"],"title":"bitxhub client validators","title_tokens":["client","bitxhub","validators"," "]},{"location":"bitxhub/dev/cmd/bitxhub_client/#bitxhub-client-delvpnode","text":"动态删除共识节点 NAME: BitXHub client delVPNode - delete a vp node USAGE: BitXHub client delVPNode [command options] [arguments...] OPTIONS: --pid value pid of vp node","text_tokens":["pid","--","of",":","command","删除","client","-","bitxhub","["," ","]","usage","节点","arguments","delete","delvpnode","动态","vp","options","node","value","a","...","共识","name"],"title":"bitxhub client delVPNode","title_tokens":["delvpnode","client","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_client/#bitxhub-client-governance","text":"提案治理命令 NAME: BitXHub client governance - governance command USAGE: BitXHub client governance command [command options] [arguments...] COMMANDS: vote vote to a proposal proposals query proposals based on the condition chain appchain manage command rule rule manage command node node manage command role role manage command dapp dapp manage command","text_tokens":["governance","appchain",":","command","client","-","dapp","manage","治理","bitxhub","["," ","condition","]","commands","chain","to","usage","role","arguments","based","on","options","node","the","命令","a","...","提案","proposals","proposal","rule","vote","query","name"],"title":"bitxhub client governance","title_tokens":["governance","client","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_client/#_6","text":"NAME: BitXHub client governance rule - rule manage command USAGE: BitXHub client governance rule command [command options] [arguments...] COMMANDS: all query all rules info of one chain available query available rule address of a chain status query rule status by rule address and chain id update update master rule with chain id","text_tokens":["governance","of","available",":","command","client","-","info","manage","bitxhub","["," ","id","by","]","commands","chain","and","usage","arguments","status","all","update","rules","with","options","a","...","master","one","rule","address","query","name"],"title":"规则管理","title_tokens":["管理","规则"]},{"location":"bitxhub/dev/cmd/bitxhub_client/#_7","text":"NAME: BitXHub client governance node - node manage command USAGE: BitXHub client governance node command [command options] [arguments...] COMMANDS: status query node status by node pid register register node logout logout node by node pid all query all nodes info","text_tokens":["governance","pid",":","command","client","-","logout","info","manage","bitxhub","["," ","register","by","]","commands","usage","arguments","nodes","status","all","options","node","...","query","name"],"title":"节点管理","title_tokens":["节点","管理"]},{"location":"bitxhub/dev/cmd/bitxhub_client/#_8","text":"NAME: BitXHub client governance role - role manage command USAGE: BitXHub client governance role command [command options] [arguments...] COMMANDS: status query role status by role id register register role update update node for auditAdmin freeze freeze role by role id activate activate role by role id logout logout role by role id all query all roles info","text_tokens":["governance",":","command","client","-","for","logout","info","manage","bitxhub","["," ","id","register","by","]","commands","usage","role","arguments","status","all","update","roles","auditadmin","options","node","activate","...","freeze","query","name"],"title":"角色管理","title_tokens":["管理","角色"]},{"location":"bitxhub/dev/cmd/bitxhub_client/#dapp","text":"NAME: BitXHub client governance dapp - dapp manage command USAGE: BitXHub client governance dapp command [command options] [arguments...] COMMANDS: status query dapp status by dapp id myDapps query dapps by owner addr register register dapp update update dapp freeze freeze dapp by dapp id activate activate dapp by dapp id transfer transfer dapp to other user confirm confirm dapp transfer evaluate evaluate dapp","text_tokens":["governance",":","command","client","-","dapp","manage","bitxhub","["," ","dapps","id","register","by","transfer","]","commands","user","to","usage","arguments","other","status","update","addr","options","activate","...","mydapps","confirm","freeze","evaluate","query","owner","name"],"title":"dapp管理","title_tokens":["管理","dapp"]},{"location":"bitxhub/dev/cmd/bitxhub_client/#_9","text":"命令参数 NAME: BitXHub client governance vote - vote to a proposal USAGE: BitXHub client governance vote [command options] [arguments...] OPTIONS: --id value proposal id --info value voting information, approve or reject --reason value reason to vote 样例 bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 client governance vote --info approve --reason test --id 0x9A601dbebf20f3E3362241810C2229F7f97329d6-0 vote successfully! 0x9A601dbebf20f3E3362241810C2229F7f97329d6-0","text_tokens":["governance","--",":","command",",","reject","client","-","windiyi","info","0x9a601dbebf20f3e3362241810c2229f7f97329d6","users","bitxhub","["," ","id","0","]","!","approve","to","usage","arguments","test","repo","or","reason","=","/","build","node3","ideaprojects","scripts","options","value","a","命令","样例","voting","...","information","successfully","参数","proposal","vote","name"],"title":"提案投票","title_tokens":["投票","提案"]},{"location":"bitxhub/dev/cmd/bitxhub_client/#_10","text":"id: 提案id type: 提案类型，当前支持应用链管理 status: 提案状态，是否通过 from: 提案者地址 NAME: BitXHub client governance proposals - query proposals based on the condition USAGE: BitXHub client governance proposals [command options] [arguments...] OPTIONS: --id value proposal id --type value proposal type, currently only AppchainMgr is supported --status value proposal status, one of proposed, approve or reject --from value the address of the account to which the proposal was made","text_tokens":["governance","者","--","of",":","command",",","appchainmgr","proposed","支持","client","-","reject","链","bitxhub","["," ","condition","id","]","approve","to","usage","arguments","from","status","通过","which","or","account","is","based","on","状态","是否","当前","options","made","supported","value","the","was","only","...","类型","提案","type","，","proposals","one","地址","proposal","应用","管理","address","query","name","currently"],"title":"提案查询","title_tokens":["提案","查询"]},{"location":"bitxhub/dev/cmd/bitxhub_client/#_11","text":"status:查询应用链状态 freeze:应用链冻结 activate:应用链激活 NAME: BitXHub client governance chain - appchain manage command USAGE: BitXHub client governance chain command [command options] [arguments...] COMMANDS: status query chain status by chain id freeze freeze appchain by chain id activate activate chain by chain id","text_tokens":["governance","appchain",":","command","冻结","client","-","链","manage","bitxhub","["," ","id","by","chain","]","commands","usage","arguments","status","查询","状态","options","activate","...","激活","freeze","应用","query","name"],"title":"应用链管理","title_tokens":["管理","应用","链"]},{"location":"bitxhub/dev/cmd/bitxhub_client/#bitxhub-client-did","text":"提案治理命令 NAME: BitXHub client did - did command USAGE: BitXHub client did command [command options] [arguments...] COMMANDS: init init method-registry contract addAdmin add admin role for method-registry contract","text_tokens":[":","command","client","-","contract","addadmin","for","治理","bitxhub","["," ","]","commands","usage","role","arguments","init","add","did","registry","method","options","命令","...","提案","admin","name"],"title":"bitxhub client did","title_tokens":["client","did","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/","text":"bitxhub 中继链命令描述如下： bitxhub -h NAME: BitXHub - A leading inter-blockchain platform USAGE: bitxhub [ global options ] command [ command options ] [ arguments... ] COMMANDS: config Operate bitxhub config init Initialize BitXHub local configuration start Start a long-running start process key Create and show key information version BitXHub version cert Certification tools client BitXHub client command help, h Shows a list of commands or help for one command 参数解释 repo : 可选参数，指定bitxhub节点配置文件所在目录，如果不指定，默认使用$HOME/.bitxhub目录。 GLOBAL OPTIONS: --repo value BitXHub storage repo path --help, -h show help --version, -v print the version 子命令描述 bitxhub config 显示当前节点配置：如未指定 repo 则默认使用 ~/.bitxhub/ 路径，若路径下存在旧配置，则提示覆盖与否。 示例说明 $ bitxhub config { \"cert\" : { \"agency_cert_path\" : \"certs/agency.cert\" , \"ca_cert_path\" : \"certs/ca.cert\" , \"node_cert_path\" : \"certs/node.cert\" , \"verify\" : true } , \"executor\" : { \"type\" : \"serial\" } , \"gateway\" : { \"AllowedOrigins\" : [ \"*\" ] } , \"genesis\" : { \"admins\" : [ { \"address\" : \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\" , \"weight\" : 2 } , { \"address\" : \"0x79a1215469FaB6f9c63c1816b45183AD3624bE34\" , \"weight\" : 2 } , { \"address\" : \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\" , \"weight\" : 2 } , { \"address\" : \"0xc0Ff2e0b3189132D815b8eb325bE17285AC898f8\" , \"weight\" : 2 } ] , \"strategy\" : { \"appchainmgr\" : \"SimpleMajority\" , \"nodemgr\" : \"SimpleMajority\" , \"rulemgr\" : \"SimpleMajority\" , \"servicemgr\" : \"SimpleMajority\" } } , \"license\" : { \"key\" : \"133847740289a8dc5447bfbaedf10ed5ee9460110e4ba6b455e33cf941253527f18dd721515c5142fcea9b6415ddad6b3f1696011a4bbc86f35833ae9296a3ea\" , \"verifier\" : \"https://172.16.5.3:11443/v1/validation\" } , \"limiter\" : { \"capacity\" : 10000 , \"interval\" : 50000000 , \"quantum\" : 500 } , \"log\" : { \"dir\" : \"logs\" , \"filename\" : \"bitxhub.log\" , \"level\" : \"info\" , \"module\" : { \"api\" : \"info\" , \"consensus\" : \"info\" , \"coreapi\" : \"info\" , \"executor\" : \"info\" , \"p2p\" : \"info\" , \"profile\" : \"info\" , \"router\" : \"info\" , \"storage\" : \"info\" } , \"report_caller\" : false } , \"monitor\" : { \"Enable\" : true } , \"order\" : { \"plugin\" : \"plugins/raft.so\" } , \"ping\" : { \"duration\" : 15000000000 , \"enable\" : true } , \"port\" : { \"gateway\" : 9091 , \"grpc\" : 60011 , \"monitor\" : 40011 , \"pprof\" : 53121 } , \"pprof\" : { \"duration\" : 30000000000 , \"enable\" : true, \"mode\" : \"memory\" , \"ptype\" : \"http\" } , \"repo_root\" : \"/Users/xxx/.bitxhub\" , \"security\" : { \"EnableTLS\" : false, \"pem_file_path\" : \"certs/node.cert\" , \"server_key_path\" : \"certs/node.priv\" } , \"solo\" : false, \"title\" : \"BitXHub configuration file\" , \"txpool\" : { \"batch_size\" : 500 , \"batch_timeout\" : 500000000 } } bitxhub init 初始化节点配置：如未指定 repo 则默认使用 ~/.bitxhub/ 路径。 示例说明 $ bitxhub init initializing bitxhub at /Users/xxx/.bitxhub bitxhub configuration file already exists reinitializing would overwrite your configuration, Y/N? y bitxhub start 该命令 bitxhub start 显示BitXHub的版本信息。它会在命令行显示版本、构建日期、操作系统/架构和Go编译器版本。 NAME: bitxhub start - Start a long-running start process USAGE: bitxhub start [ command options ] [ arguments... ] OPTIONS: --passwd value bitxhub key password --config value bitxhub config path --network value bitxhub network config path --order value bitxhub order config path 参数解释 passwd ：指定节点私钥密码； config ：指定节点配置路径，一般指 bitxhub.toml ； network ：指定节点p2p网络配置文件，一般指 network.toml ； order ：指定节点共识配置文件，一般指 order.toml 。 若不指定以上配置，则默认至bitxhub --repo路径下寻找 。 示例说明 $ bitxhub --repo <node_config_path> start # 控制台输出 BitXHub version: dev-fixx-1.6-2a2f39f App build date: 2021 -11-25T16:43:19 System version: darwin/amd64 Golang version: go1.14.15 time = \"2021-11-29T18:07:37.722\" level = info msg = \"MemPool batch size = 200\" module = order time = \"2021-11-29T18:07:37.722\" level = info msg = \"MemPool tx slice size = 200\" module = order time = \"2021-11-29T18:07:37.722\" level = info msg = \"MemPool batch seqNo = 6\" module = order time = \"2021-11-29T18:07:37.723\" level = info msg = \"MemPool pool size = 50000\" module = order time = \"2021-11-29T18:07:37.723\" level = info msg = \"Raft localID = 1\" module = order time = \"2021-11-29T18:07:37.723\" level = info msg = \"Raft lastExec = 6 \" module = order time = \"2021-11-29T18:07:37.723\" level = info msg = \"Raft snapshotCount = 1000\" module = order time = \"2021-11-29T18:07:37.723\" level = info msg = \"GRPC service started\" module = api port = 60011 time = \"2021-11-29T18:07:37.723\" level = info msg = \"Gateway service started\" module = api port = 9091 bitxhub key 功能 该命令 bitxhub key 提供针对bitxhub节点的私钥管理。它包含了私钥生成、私钥格式转换、私钥查看、地址查看。子命令信息如下: NAME: BitXHub key - Create and show key information USAGE: BitXHub key command [ command options ] [ arguments... ] COMMANDS: gen Create new Secp256k1 private key in specified directory show Show BitXHub key from repo address Show address from Secp256k1 private key 子命令 bitxhub key gen NAME: BitXHub key gen - Create new Secp256k1 private key in specified directory USAGE: BitXHub key gen [ command options ] [ arguments... ] OPTIONS: --target value Specific target directory --passwd value Specify password 参数解释 target ：指定生成路径； passwd ：指定私钥密码。 示例说明 $ bitxhub key gen --target ~/.bitxhub # 控制台输出 key.json key is generated under directory /Users/xxx/.bitxhub bitxhub key show 显示 key.json 具体内容。 key.json 展示 示例说明 bitxhub key show { \"type\" : 3 , \"cipher\" : { \"data\" : \"18bc2c685cc79d7098fa1f3b97f14541121b61b1d3492ef4f298c84844e7b380fa8e8a84dc44d910aa9dafddc0347c670bace2c74d8553a4c843ae58ce4aeb78\" , \"cipher\" : \"AES-256\" } } bitxhub key address 显示 key.json 地址。 示例说明 bitxhub key address --path ./key.json --passwd 123 0x3Db84D019fCd3A845e2fB3A21B56812Ffd933f19 bitxhub version 功能 该命令 bitxhub version 显示BitXHub的版本信息。它会在命令行显示版本、构建日期、操作系统/架构和Go编译器版本。 NAME: bitxhub version - BitXHub version USAGE: bitxhub version [ arguments... ] 示例说明 $ bitxhub version BitXHub version: dev-fixx-1.6-2a2f39f App build date: 2021 -11-25T15:01:28 System version: darwin/amd64 Golang version: go1.14.15 bitxhub cert 功能 该命令 bitxhub cert 提供一系列x509标准的证书工具，服务于中继链节点的准入机制。它包含了CA生成、CSR描述生成、证书签发、证书解析、证书私钥生成以及证书校验。说明信息如下: NAME: BitXHub cert - Certification tools USAGE: BitXHub cert command [ command options ] [ arguments... ] COMMANDS: ca Generate ca cert and private key csr Generate csr file issue Issue certification by ca parse parse certification priv Generate and show private key for certificate verify verify cert 子命令 bitxhub cert ca 生成根CA证书 bitxhub cert ca -h NAME: BitXHub cert ca - Generate ca cert and private key USAGE: BitXHub cert ca [ arguments... ] 示例说明 $ bitxhub --repo = $HOME /cert cert ca # 在repo目录下生成如下文件 ├── ca.cert ├── ca.priv bitxhub cert csr 生成CSR描述信息。 NAME: BitXHub cert csr - Generate csr file USAGE: BitXHub cert csr [ command options ] [ arguments... ] OPTIONS: --key value Specify Secp256r1 private key path --org value Specify organization name --target value Specific target directory 参数解释 key : 指定私钥路径； org : 指定被签发人组织名称； target : 指定目标CSR路径； bitxhub cert issue 证书签发。 NAME: BitXHub cert issue - Issue certification by ca USAGE: BitXHub cert issue [ command options ] [ arguments... ] OPTIONS: --csr value Specify csr path --is_ca value Specify whether it 's ca --key value Specify ca' s secp256r1 private key path --cert value Specify ca certification path --target value Specific target directory 参数解释 csr : 指定CSR描述文件路径； is_ca : 指定签发人是否为CA证书； key : 指定当前签发人私钥路径； cert : 指定当前签发人证书路径； target : 指定生成的证书路径。 bitxhub cert parse 证书解析。 NAME: BitXHub cert parse - parse certification USAGE: BitXHub cert parse [ command options ] [ arguments... ] OPTIONS: --path value certification path 参数解释 path : 指定证书路径。 bitxhub cert priv 生成或展示用于p2p网络通信的私钥。 NAME: BitXHub cert priv - Generate and show private key for certificate USAGE: BitXHub cert priv command [ command options ] [ arguments... ] COMMANDS: gen Create new private key pid Show pid from private key 子命令 私钥生成 bitxhub cert priv gen NAME: BitXHub cert priv gen - Create new private key USAGE: BitXHub cert priv gen [ command options ] [ arguments... ] OPTIONS: --name value Specific private key name --target value Specific target directory 示例说明 bitxhub cert priv gen --name server --target ./ server.priv key is generated under directory /Users/xxx/GolandProjectsTest/bitxhub-docs bitxhub cert priv pid 获取libp2p节点pid。 NAME: BitXHub cert priv pid - Show pid from private key USAGE: BitXHub cert priv pid [ command options ] [ arguments... ] OPTIONS: --path value Specific private key path 示例说明 bitxhub cert priv pid --path ./server.priv # 控制台输出 QmWw4hPtm51jpxzKjyYMe3E7bNei9wdoug6B1rZqSwVSL4 bitxhub client 功能 该命令 bitxhub client 提供中继链节点的客户端操作命令。它包含了账户信息查询、中继链信息、区块查询、节点网络信息、回执查询、交易操作、验证者集查询、删除共识节点、提案治理。 子命令信息如下: NAME: BitXHub client - BitXHub client command USAGE: BitXHub client command [ command options ] [ arguments... ] COMMANDS: account Query account information chain Query bitxhub chain info block Query block network Query network info from node receipt Query receipt tx Transaction manipulation validators Query validator address delVPNode delete a vp node governance governance command 参数解释 gateway : 指定客户端http服务地址，如果节点开启了TLS功能，则需要传递https地址； cert : 指定节点的CA证书，如果节点开始了TLS功能，需要传递； OPTIONS: --gateway value Specific gateway address ( default: \"http://localhost:9091/v1/\" ) --cert value Specific ca cert file if https is enabled --help, -h show help 子命令 bitxhub client account 账户信息查询。 bitxhub client account 0x79a1215469FaB6f9c63c1816b45183AD3624bE34 # 控制台输出 { \"type\" : \"normal\" , \"balance\" : 100000000 , \"contract_count\" : 0 , \"code_hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" } bitxhub client chain 中继链信息查询。 NAME: BitXHub client chain - Query bitxhub chain info USAGE: BitXHub client chain command [ command options ] [ arguments... ] COMMANDS: meta Query bitxhub chain meta status Query bitxhub chain status OPTIONS: --help, -h show help bitxhub client chain meta 查询中继链信息。 示例说明 bitxhub client chain meta # 控制台输出 { \"height\" : \"1\" , \"block_hash\" : \"0x0BF41c03bE038e389470dBdC9ed53DF897F178921520AF37877188d1759A7068\" } bitxhub client chain status 查询中继链状态是否可用。 示例说明 # normal: 已处在共识状态 # abnormal：未共识状态，集群没有正常运行 $ bitxhub client chain status # 控制台输出 normal bitxhub client block 区块信息查询， 可指定区块号或区块Hash 。 示例说明 $ bitxhub client block 1 # 控制台输出 { \"block_header\" : { \"number\" : \"1\" , \"state_root\" : \"0xC3A3B54F593e638D8a9FAbf66b781EFcb14D0f013D7c3E3a02ef698294f6BBF5\" } , \"block_hash\" : \"0x0BF41c03bE038e389470dBdC9ed53DF897F178921520AF37877188d1759A7068\" , \"signature\" : \"74DK6FeGnAYBJ0pJ4bLwIaT9cp9YwIscenKsRc7myXUBQfvvLKhIpZqPJkf8tAI7V8u89SLOAdz94fo/ajKi+wA=\" } bitxhub client network 全网节点信息。 示例说明 $ bitxhub client network # 控制台输出 { \"1\" : { \"id\" : 1 , \"pid\" : \"QmXi58fp9ZczF3Z5iz1yXAez3Hy5NYo1R8STHWKEM9XnTL\" , \"account\" : \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\" , \"hosts\" : [ \"/ip4/127.0.0.1/tcp/4001/p2p/\" ] } , \"2\" : { \"id\" : 2 , \"pid\" : \"QmbmD1kzdsxRiawxu7bRrteDgW1ituXupR8GH6E2EUAHY4\" , \"account\" : \"0x79a1215469FaB6f9c63c1816b45183AD3624bE34\" , \"hosts\" : [ \"/ip4/127.0.0.1/tcp/4002/p2p/\" ] } , \"3\" : { \"id\" : 3 , \"pid\" : \"QmQUcDYCtqbpn5Nhaw4FAGxQaSSNvdWfAFcpQT9SPiezbS\" , \"account\" : \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\" , \"hosts\" : [ \"/ip4/127.0.0.1/tcp/4003/p2p/\" ] } , \"4\" : { \"id\" : 4 , \"pid\" : \"QmQW3bFn8XX1t4W14Pmn37bPJUpUVBrBjnPuBZwPog3Qdy\" , \"account\" : \"0xc0Ff2e0b3189132D815b8eb325bE17285AC898f8\" , \"hosts\" : [ \"/ip4/127.0.0.1/tcp/4004/p2p/\" ] } } bitxhub client receipt 交易回执查询。 示例说明 $ bitxhub client receipt 0x08ab0E9175ae67Aed7a085D6813C156e4ED3b49cDf902e02280F6a62d7AaD61E # 控制台输出 { \"tx_hash\" : \"0x08ab0E9175ae67Aed7a085D6813C156e4ED3b49cDf902e02280F6a62d7AaD61E\" , \"ret\" : null, \"status\" : 0 , \"events\" : [] } bitxhub client tx 交易发送与交易查询。 NAME: BitXHub client tx - Transaction manipulation USAGE: BitXHub client tx command [ command options ] [ arguments... ] COMMANDS: get Query transaction send Send transaction OPTIONS: --help, -h show help bitxhub client tx send 交易发送 示例说明 $ bitxhub client tx send --key scripts/build/node1/key.json --to 0x97c8B516D19edBf575D72a172Af7F418BE498C37 --amount 2 --type 0 # 控制台输出 { \"tx_hash\" : \"0x08ab0E9175ae67Aed7a085D6813C156e4ED3b49cDf902e02280F6a62d7AaD61E\" } bitxhub client tx get 交易查询 示例说明 $ bitxhub client tx get 0x08ab0E9175ae67Aed7a085D6813C156e4ED3b49cDf902e02280F6a62d7AaD61E # 控制台输出 { \"tx\" : { \"from\" : \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\" , \"to\" : \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\" , \"timestamp\" : \"1638168425560507000\" , \"transaction_hash\" : \"0x08ab0E9175ae67Aed7a085D6813C156e4ED3b49cDf902e02280F6a62d7AaD61E\" , \"payload\" : \"EAI=\" , \"nonce\" : \"2\" , \"signature\" : \"mdOdSzAOTDxfZ0VphvyDyir1lE8w31rUaSTtnj1us9NMhtUPVHz5bLcOBdZrmUfnaVhL3xGQxK3/P7WHmihxIQA=\" } , \"tx_meta\" : { \"block_hash\" : \"HoMgbS+NeCRds5Qc/58NfHXA+jVCuhUcsc7p9IvJxMc=\" , \"block_height\" : \"3\" }} bitxhub client validators 全网验证人信息。 示例说明 $ bitxhub client validators # 控制台输出 [ \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\" , \"0x79a1215469FaB6f9c63c1816b45183AD3624bE34\" , \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\" , \"0xc0Ff2e0b3189132D815b8eb325bE17285AC898f8\" ] bitxhub client delVPNode 动态删除共识节点 NAME: BitXHub client delVPNode - delete a vp node USAGE: BitXHub client delVPNode [ command options ] [ arguments... ] OPTIONS: --pid value pid of vp node bitxhub client governance 提案治理命令。 NAME: BitXHub client governance - governance command USAGE: BitXHub client governance command [ command options ] [ arguments... ] COMMANDS: vote vote to a proposal proposals query proposals based on the condition chain appchain manage command bitxhub client governance vote 提案投票。 NAME: BitXHub client governance vote - vote to a proposal USAGE: BitXHub client governance vote [ command options ] [ arguments... ] OPTIONS: --id value proposal id --info value voting information, approve or reject --reason value reason to vote 参数解释 id ：必选参数。提案id，生成提案时将在控制台打印。 info ：必选参数。是否通过提案。approve为通过，reject为拒绝。 reason ：必选参数。投票理由说明。 示例说明 $ bitxhub client governance vote --info approve --reason test --id 0x9A601dbebf20f3E3362241810C2229F7f97329d6-0 # 控制台输出 vote successfully! 0x9A601dbebf20f3E3362241810C2229F7f97329d6-0 bitxhub client governance proposals 提案查询。用于查询中继链提案的内容以及相关的状态。命令说明如下： NAME: BitXHub client governance proposals - query proposals based on the condition USAGE: BitXHub client governance proposals [ command options ] [ arguments... ] OPTIONS: --id value proposal id --type value proposal type, currently only AppchainMgr is supported --status value proposal status, one of proposed, approve or reject --from value the address of the account to which the proposal was made 参数解释 id : 提案id； type : 提案类型，当前支持应用链管理； status : 提案状态，是否通过； from : 提案者地址。 示例说明 $ bitxhub client governance proposals --id 0x0FDDC68A2300cF9CB0a217123D5f656e0943C1Da-0 --type AppchainMgr --status proposed --from 0x0FDDC68A2300cF9CB0a217123D5f656e0943C1Da # 控制台输出 Id Type Status ApproveNum RejectNum ElectorateNum ThresholdNum Des -- ---- ------ ---------- --------- ------------- ------------ --- 0x9A601dbebf20f3E3362241810C2229F7f97329d6-0 AppchainMgr proposed 1 0 4 3 register bitxhub client governance chain 应用链管理。命令说明如下： NAME: BitXHub client governance chain - appchain manage command USAGE: BitXHub client governance chain command [ command options ] [ arguments... ] COMMANDS: status query chain status by chain id freeze freeze appchain by chain id activate activate chain by chain id 参数解释 status :查询应用链状态； freeze :应用链冻结； activate :应用链激活。 示例说明 # 管理员治理投票通过后，应用链状态从registing转换为available $ bitxhub client governance chain status --id 0x0FDDC68A2300cF9CB0a217123D5f656e0943C1Da # 控制台输出 appchain 0x0FDDC68A2300cF9CB0a217123D5f656e0943C1Da is available","text_tokens":["者","10000","说明","tools","包含","信息","started","172.16","qmqucdyctqbpn5nhaw4fagxqassnvdwfafcpqt9spiezbs","为","治理","create","condition","get","node1","不","未","cert","directory","如果","通信","$","delvpnode","registing","区块","based","18bc2c685cc79d7098fa1f3b97f14541121b61b1d3492ef4f298c84844e7b380fa8e8a84dc44d910aa9dafddc0347c670bace2c74d8553a4c843ae58ce4aeb78","0x79a1215469fab6f9c63c1816b45183ad3624be34","limiter","中继","new","_","准入","inter","one","generate","被","manipulation","一般","操作","enable","133847740289a8dc5447bfbaedf10ed5ee9460110e4ba6b455e33cf941253527f18dd721515c5142fcea9b6415ddad6b3f1696011a4bbc86f35833ae9296a3ea","msg","旧","log","0x08ab0e9175ae67aed7a085d6813c156e4ed3b49cdf902e02280f6a62d7aad61e","回执","=","on","tx","。","thresholdnum","'","可","架构","information","解释","默认","0x0bf41c03be038e389470dbdc9ed53df897f178921520af37877188d1759a7068","system","0xc3a3b54f593e638d8a9fabf66b781efcb14d0f013d7c3e3a02ef698294f6bbf5","global","开始","已","qmbmd1kzdsxriawxu7brrtedgw1ituxupr8gh6e2euahy4","提示",",","编译","golandprojectstest","darwin","solo","state","256","in","your","qmww4hptm51jpxzkjyyme3e7bnei9wdoug6b1rzqswvsl4","test","certs","events","number","40011","子","caller","或","configuration","tcp","freeze","block","https","运行","interval","start","删除","electoratenum","以及","validators","help","client","-","bitxhub","19"," ","投票","3","01","43","和","delete","org","it","30000000000","用于","overwrite","server","key","scripts","寻找","balance","libp2p","管理","操作命令","若","账户","governance","command","proposed","[","executor","register","commands","理由","plugin","csr","logs","raft","weight","07","timeout","开启","title","amd64","查看","data","ptype","specific","plugins","aes","validation","qmqw3bfn8xx1t4w14pmn37bpjupuvbrbjnpubzwpog3qdy","list","only","11","signature","timestamp","0x0fddc68a2300cf9cb0a217123d5f656e0943c1da","：","可用","pem","priv","print",":","1638168425560507000","工具","api","冻结","0xc0ff2e0b3189132d815b8eb325be17285ac898f8","证书","在","mode","certificate","cipher","指定","dev","go1.14","0","pool","quantum","from","处在","or","系统","account","控制台","根","vp","fixx","网络通信","verifier","6","后","的","15000000000","没有","与","交易","50000","4003","则","default","使用","---------","管理员","lastexec","query","name","15","password","available","docs","gen",">","500","机制","for","info","platform","----","nonce","initialize","+","rulemgr","集群","repo","count","0x97c8b516d19edbf575d72a172af7f418be498c37","9091","当前","app","命令","config","私钥","certification","提案","mempool","路径","report","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013","内容","capacity","security","v","go","code","解析","28","配置","体内","拒绝","simplemajority","密码","xxx","so","4002","which","private","grpc","全网","人","date","validator","made","签发","p2p","file","long","a","4001","homgbs","voting","5.3","地址","------------","初始化","consensus","----------","1","coreapi","37.722","blockchain","time","send","0x9a601dbebf20f3e3362241810c2229f7f97329d6","issue","id","客户端","!","如","to","profile","usage","ajki","dir","jvcuhucsc7p9ivjxmc","genesis","具体","is","json","specify","是否","verify","名称","至","version","必选","类型","验证","目标","rejectnum","would","58nfhxa","共识","address","指","所在","获取","存在","2021","针对","necrds5qc","appchainmgr","users","传递","描述","arguments","storage","init","reason","operate","/","状态","未指定","show","local","#","value","the","命令行","snapshotcount","seqno","展示","proposals","激活","module","root","vote","pid","of","appchain","gateway","exists","支持","golang","secp256k1","链","\"","process","pprof","serial","74dk6fegnaybj0pj4blwiat9cp9ywiscenksrc7myxubqfvvlkhipzqpjkf8tai7v8u89sloadz94fo","txpool","ip4",")","37.723","status","height","文件","---","500000000","qmxi58fp9zczf3z5iz1yxaez3hy5nyo1r8sthwkem9xntl","查询","network","wa","hash","组织","提供","eai","home","版本信息","200","toml","normal","1000","功能","order","--","memory","monitor","strategy","日期","以上","发送","4","25t16","格式","by","and","chain","router","于","系列","localid","duration","时","需要","agency","打印","ret","level","25t15","admins","显示","~","false","标准","覆盖","successfully","编译器","应用","approvenum","currently","initializing","示例","号","manage","true","]","；","}","0x0000000000000000000000000000000000000000000000000000000000000000","1.6","generated","通过","(","动态","receipt","size","options","2a2f39f","校验","50000000","supported","输出","一系列","activate","...","type","at","under","service","header","proposal","n","y","tls","将","生成","reject","一系","0.1","0x3db84d019fcd3a845e2fb3a21b56812ffd933f19","├","操作系统","already","与否","p7whmihxiqa","构建","配置文件","节点","控制","specified","相关","port","集","s","if","localhost","123","具体内容","payload","servicemgr","mdodszaotdxfz0vphvydyir1le8w31ruasttnj1us9nmhtupvhz5blcobdzrmufnavhl3xgqxk3","was","<","passwd","参数","hosts","batch","从","filename","enabled","organization","它会","allowedorigins","contract","53121","------","100000000","whether","29t18","enabletls","如下","选",".","null","build","meta","nodemgr","node","leading","slice","amount","x509","11443","*","-------------","parse","transaction","2","下","des","目录","license","secp256r1","h","─","它","ping","approve","客户","abnormal","正常","shows","网络","、","初始","4004","running","127.0","path","转换","?","60011","http","v1","reinitializing","版本","，","服务","ca","target","了","该","{"],"title":"中继链BitXHub","title_tokens":["bitxhub","链","中继"]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub","text":"中继链命令描述如下： bitxhub -h NAME: BitXHub - A leading inter-blockchain platform USAGE: bitxhub [ global options ] command [ command options ] [ arguments... ] COMMANDS: config Operate bitxhub config init Initialize BitXHub local configuration start Start a long-running start process key Create and show key information version BitXHub version cert Certification tools client BitXHub client command help, h Shows a list of commands or help for one command 参数解释 repo : 可选参数，指定bitxhub节点配置文件所在目录，如果不指定，默认使用$HOME/.bitxhub目录。 GLOBAL OPTIONS: --repo value BitXHub storage repo path --help, -h show help --version, -v print the version","text_tokens":["command","blockchain","tools","create","[","不","]","commands","cert","usage","如果","$","options","中继","list","version","...","inter","one","：","所在","print",":","指定","配置文件","描述","arguments","节点","storage","init","or","operate","/","。","show","local","value","可","the","information","解释","默认","使用","参数","global","name","of",",","for","链","platform","process","initialize","repo","如下","选",".","文件","leading","home","命令","config","certification","configuration","start","--","v","help","目录","client","-","配置","h","bitxhub"," ","and","shows","running","path","key","long","a","，"],"title":"bitxhub","title_tokens":["bitxhub"]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#_1","text":"","text_tokens":[],"title":"子命令描述","title_tokens":["命令","描述","子"]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-config","text":"显示当前节点配置：如未指定 repo 则默认使用 ~/.bitxhub/ 路径，若路径下存在旧配置，则提示覆盖与否。 示例说明 $ bitxhub config { \"cert\" : { \"agency_cert_path\" : \"certs/agency.cert\" , \"ca_cert_path\" : \"certs/ca.cert\" , \"node_cert_path\" : \"certs/node.cert\" , \"verify\" : true } , \"executor\" : { \"type\" : \"serial\" } , \"gateway\" : { \"AllowedOrigins\" : [ \"*\" ] } , \"genesis\" : { \"admins\" : [ { \"address\" : \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\" , \"weight\" : 2 } , { \"address\" : \"0x79a1215469FaB6f9c63c1816b45183AD3624bE34\" , \"weight\" : 2 } , { \"address\" : \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\" , \"weight\" : 2 } , { \"address\" : \"0xc0Ff2e0b3189132D815b8eb325bE17285AC898f8\" , \"weight\" : 2 } ] , \"strategy\" : { \"appchainmgr\" : \"SimpleMajority\" , \"nodemgr\" : \"SimpleMajority\" , \"rulemgr\" : \"SimpleMajority\" , \"servicemgr\" : \"SimpleMajority\" } } , \"license\" : { \"key\" : \"133847740289a8dc5447bfbaedf10ed5ee9460110e4ba6b455e33cf941253527f18dd721515c5142fcea9b6415ddad6b3f1696011a4bbc86f35833ae9296a3ea\" , \"verifier\" : \"https://172.16.5.3:11443/v1/validation\" } , \"limiter\" : { \"capacity\" : 10000 , \"interval\" : 50000000 , \"quantum\" : 500 } , \"log\" : { \"dir\" : \"logs\" , \"filename\" : \"bitxhub.log\" , \"level\" : \"info\" , \"module\" : { \"api\" : \"info\" , \"consensus\" : \"info\" , \"coreapi\" : \"info\" , \"executor\" : \"info\" , \"p2p\" : \"info\" , \"profile\" : \"info\" , \"router\" : \"info\" , \"storage\" : \"info\" } , \"report_caller\" : false } , \"monitor\" : { \"Enable\" : true } , \"order\" : { \"plugin\" : \"plugins/raft.so\" } , \"ping\" : { \"duration\" : 15000000000 , \"enable\" : true } , \"port\" : { \"gateway\" : 9091 , \"grpc\" : 60011 , \"monitor\" : 40011 , \"pprof\" : 53121 } , \"pprof\" : { \"duration\" : 30000000000 , \"enable\" : true, \"mode\" : \"memory\" , \"ptype\" : \"http\" } , \"repo_root\" : \"/Users/xxx/.bitxhub\" , \"security\" : { \"EnableTLS\" : false, \"pem_file_path\" : \"certs/node.cert\" , \"server_key_path\" : \"certs/node.priv\" } , \"solo\" : false, \"title\" : \"BitXHub configuration file\" , \"txpool\" : { \"batch_size\" : 500 , \"batch_timeout\" : 500000000 } }","text_tokens":["10000","coreapi","说明","示例","172.16","[","executor","true","]","cert","如","plugin","}","logs","profile","raft","dir","weight","timeout","genesis","$","title","ptype","0x79a1215469fab6f9c63c1816b45183ad3624be34","plugins","verify","size","limiter","validation","50000000","_","type","：","address","pem","存在","priv",":","api","0xc0ff2e0b3189132d815b8eb325be17285ac898f8","appchainmgr","enable","users","133847740289a8dc5447bfbaedf10ed5ee9460110e4ba6b455e33cf941253527f18dd721515c5142fcea9b6415ddad6b3f1696011a4bbc86f35833ae9296a3ea","mode","指定","旧","与否","节点","quantum","log","storage","port","/","。","未指定","verifier","servicemgr","15000000000","则","默认","使用","module","root","batch","提示","filename","gateway",",","500","allowedorigins","info","solo","\"","53121","pprof","serial","txpool","rulemgr","repo","certs","enabletls",".","500000000","nodemgr","0x97c8b516d19edbf575d72a172af7f418be498c37","9091","当前","node","40011","config","caller","11443","*","路径","report","configuration","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013","2","下","https","capacity","order","interval","security","memory","monitor","strategy","license","配置","bitxhub"," ","simplemajority","xxx","ping","router","so","grpc","30000000000","duration","agency","server","path","key","level","admins","p2p","file","显示","60011","http","v1","，","~","false","5.3","覆盖","ca","consensus","若","{"],"title":"bitxhub config","title_tokens":["config","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-init","text":"初始化节点配置：如未指定 repo 则默认使用 ~/.bitxhub/ 路径。 示例说明 $ bitxhub init initializing bitxhub at /Users/xxx/.bitxhub bitxhub configuration file already exists reinitializing would overwrite your configuration, Y/N? y","text_tokens":[",","说明","initializing","exists","示例","users","配置","bitxhub"," ","指定","xxx","如","already","your","节点","repo","init","$",".","/","初始","overwrite","。","未指定","?","file","reinitializing","则","at","路径","~","configuration","默认","：","使用","would","初始化","n","y"],"title":"bitxhub init","title_tokens":["init","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-start","text":"该命令 bitxhub start 显示BitXHub的版本信息。它会在命令行显示版本、构建日期、操作系统/架构和Go编译器版本。 NAME: bitxhub start - Start a long-running start process USAGE: bitxhub start [ command options ] [ arguments... ] OPTIONS: --passwd value bitxhub key password --config value bitxhub config path --network value bitxhub network config path --order value bitxhub order config path 参数解释 passwd ：指定节点私钥密码； config ：指定节点配置路径，一般指 bitxhub.toml ； network ：指定节点p2p网络配置文件，一般指 network.toml ； order ：指定节点共识配置文件，一般指 order.toml 。 若不指定以上配置，则默认至bitxhub --repo路径下寻找 。 示例说明 $ bitxhub --repo <node_config_path> start # 控制台输出 BitXHub version: dev-fixx-1.6-2a2f39f App build date: 2021 -11-25T16:43:19 System version: darwin/amd64 Golang version: go1.14.15 time = \"2021-11-29T18:07:37.722\" level = info msg = \"MemPool batch size = 200\" module = order time = \"2021-11-29T18:07:37.722\" level = info msg = \"MemPool tx slice size = 200\" module = order time = \"2021-11-29T18:07:37.722\" level = info msg = \"MemPool batch seqNo = 6\" module = order time = \"2021-11-29T18:07:37.723\" level = info msg = \"MemPool pool size = 50000\" module = order time = \"2021-11-29T18:07:37.723\" level = info msg = \"Raft localID = 1\" module = order time = \"2021-11-29T18:07:37.723\" level = info msg = \"Raft lastExec = 6 \" module = order time = \"2021-11-29T18:07:37.723\" level = info msg = \"Raft snapshotCount = 1000\" module = order time = \"2021-11-29T18:07:37.723\" level = info msg = \"GRPC service started\" module = api port = 60011 time = \"2021-11-29T18:07:37.723\" level = info msg = \"Gateway service started\" module = api port = 9091","text_tokens":["37.722","command","说明","time","信息","示例","started","[","不","]","；","usage","raft","1.6","07","$","amd64","size","options","2a2f39f","输出","至","version","_","11","...","：","service","共识","指","2021","一般",":","操作","api","在","msg","指定","dev","go1.14","操作系统","构建","配置文件","pool","arguments","节点","控制","系统","port","=","/","控制台","tx","fixx","。","6","#","的","value","snapshotcount","命令行","seqno","50000","架构","<","则","passwd","解释","默认","system","参数","module","batch","lastexec","name","15","password","gateway","编译",">","它会","darwin","golang","info","\"","process","37.723","29t18","repo",".","文件","build","network","9091","node","app","slice","命令","config","私钥","版本信息","200","toml","mempool","路径","下","1000","order","start","--","go","-","日期","以上","配置","bitxhub","25t16"," ","19","密码","43","和","网络","、","grpc","localid","running","date","path","key","level","p2p","long","显示","a","寻找","60011","版本","，","编译器","该","若","1"],"title":"bitxhub start","title_tokens":["start","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-key","text":"","text_tokens":[],"title":"bitxhub key","title_tokens":["key","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#_2","text":"该命令 bitxhub key 提供针对bitxhub节点的私钥管理。它包含了私钥生成、私钥格式转换、私钥查看、地址查看。子命令信息如下: NAME: BitXHub key - Create and show key information USAGE: BitXHub key command [ command options ] [ arguments... ] COMMANDS: gen Create new Secp256k1 private key in specified directory show Show BitXHub key from repo address Show address from Secp256k1 private key","text_tokens":["针对","name",":","command","gen","生成","包含","信息","-","secp256k1","create","bitxhub","["," ","格式","and","]","它","commands","in","usage","节点","arguments","specified","directory","from","如下","repo","private","、","查看","。","show","key","转换","options","的","提供","命令","new","私钥","子","...","information","地址","管理","了","address","该"],"title":"功能","title_tokens":["功能"]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#_3","text":"","text_tokens":[],"title":"子命令","title_tokens":["命令","子"]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-key-gen","text":"NAME: BitXHub key gen - Create new Secp256k1 private key in specified directory USAGE: BitXHub key gen [ command options ] [ arguments... ] OPTIONS: --target value Specific target directory --passwd value Specify password 参数解释 target ：指定生成路径； passwd ：指定私钥密码。 示例说明 $ bitxhub key gen --target ~/.bitxhub # 控制台输出 key.json key is generated under directory /Users/xxx/.bitxhub","text_tokens":["--","password",":","command","gen","说明","生成","-","示例","secp256k1","users","create","bitxhub","["," ","指定","密码","xxx","]","in","；","usage","arguments","specified","directory","控制","generated","$","private",".","is","/","控制台","specific","json","。","specify","key","#","options","value","输出","new","私钥","...","under","路径","~","passwd","解释","：","target","参数","name"],"title":"bitxhub key gen","title_tokens":["key","gen","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-key-show","text":"显示 key.json 具体内容。 key.json 展示 示例说明 bitxhub key show { \"type\" : 3 , \"cipher\" : { \"data\" : \"18bc2c685cc79d7098fa1f3b97f14541121b61b1d3492ef4f298c84844e7b380fa8e8a84dc44d910aa9dafddc0347c670bace2c74d8553a4c843ae58ce4aeb78\" , \"cipher\" : \"AES-256\" } }","text_tokens":[":",",","说明","-","示例","\"","体内","bitxhub","cipher"," ","256","3","}","具体",".","data","18bc2c685cc79d7098fa1f3b97f14541121b61b1d3492ef4f298c84844e7b380fa8e8a84dc44d910aa9dafddc0347c670bace2c74d8553a4c843ae58ce4aeb78","具体内容","json","。","show","key","aes","显示","展示","type","内容","{"],"title":"bitxhub key show","title_tokens":["show","key","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-key-address","text":"显示 key.json 地址。 示例说明 bitxhub key address --path ./key.json --passwd 123 0x3Db84D019fCd3A845e2fB3A21B56812Ffd933f19","text_tokens":["--","json","。","说明","passwd","path","key","地址","123","0x3db84d019fcd3a845e2fb3a21b56812ffd933f19","示例","address",".","显示","bitxhub","/"," "],"title":"bitxhub key address","title_tokens":["address","key","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-version","text":"","text_tokens":[],"title":"bitxhub version","title_tokens":["version","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#_4","text":"该命令 bitxhub version 显示BitXHub的版本信息。它会在命令行显示版本、构建日期、操作系统/架构和Go编译器版本。 NAME: bitxhub version - BitXHub version USAGE: bitxhub version [ arguments... ] 示例说明 $ bitxhub version BitXHub version: dev-fixx-1.6-2a2f39f App build date: 2021 -11-25T15:01:28 System version: darwin/amd64 Golang version: go1.14.15","text_tokens":["15","name",":","操作","编译","说明","go","它会","-","信息","日期","示例","在","darwin","golang","28","bitxhub","["," ","dev","go1.14","操作系统","]","01","构建","usage","arguments","1.6","和","系统","$","、","amd64",".","/","build","fixx","。","date","2a2f39f","25t15","的","命令行","app","显示","命令","version","11","版本信息","版本","...","架构","system","编译器","该","2021"],"title":"功能","title_tokens":["功能"]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-cert","text":"","text_tokens":[],"title":"bitxhub cert","title_tokens":["bitxhub","cert"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#_5","text":"该命令 bitxhub cert 提供一系列x509标准的证书工具，服务于中继链节点的准入机制。它包含了CA生成、CSR描述生成、证书签发、证书解析、证书私钥生成以及证书校验。说明信息如下: NAME: BitXHub cert - Certification tools USAGE: BitXHub cert command [ command options ] [ arguments... ] COMMANDS: ca Generate ca cert and private key csr Generate csr file issue Issue certification by ca parse parse certification priv Generate and show private key for certificate verify verify cert","text_tokens":["priv","name",":","command","工具","说明","生成","以及","tools","证书","一系","机制","包含","信息","链","解析","-","for","certificate","bitxhub","["," ","issue","by","]","cert","它","csr","commands","and","usage","描述","于","节点","arguments","如下","private","、","系列","。","show","key","verify","options","的","校验","签发","一系列","中继","提供","file","命令","私钥","...","x509","certification","准入","，","标准","服务","generate","parse","ca","了","该"],"title":"功能","title_tokens":["功能"]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#_6","text":"","text_tokens":[],"title":"子命令","title_tokens":["命令","子"]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-cert-ca","text":"生成根CA证书 bitxhub cert ca -h NAME: BitXHub cert ca - Generate ca cert and private key USAGE: BitXHub cert ca [ arguments... ] 示例说明 $ bitxhub --repo = $HOME /cert cert ca # 在repo目录下生成如下文件 ├── ca.cert ├── ca.priv","text_tokens":["priv","--",":","说明","生成","目录","证书","-","示例","在","├","h","bitxhub","["," ","─","and","cert","]","usage","arguments","repo","如下","$","private",".","=","文件","/","根","key","#","home","...","generate","ca","下","name"],"title":"bitxhub cert ca","title_tokens":["ca","bitxhub","cert"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-cert-csr","text":"生成CSR描述信息。 NAME: BitXHub cert csr - Generate csr file USAGE: BitXHub cert csr [ command options ] [ arguments... ] OPTIONS: --key value Specify Secp256r1 private key path --org value Specify organization name --target value Specific target directory 参数解释 key : 指定私钥路径； org : 指定被签发人组织名称； target : 指定目标CSR路径；","text_tokens":["--",":","command","organization","生成","-","信息","secp256r1","bitxhub","["," ","指定","]","cert","csr","；","usage","描述","arguments","directory","private","org","specific","人","。","specify","path","key","options","名称","签发","组织","value","file","私钥","...","路径","目标","解释","generate","被","target","参数","name"],"title":"bitxhub cert csr","title_tokens":["csr","bitxhub","cert"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-cert-issue","text":"证书签发。 NAME: BitXHub cert issue - Issue certification by ca USAGE: BitXHub cert issue [ command options ] [ arguments... ] OPTIONS: --csr value Specify csr path --is_ca value Specify whether it 's ca --key value Specify ca' s secp256r1 private key path --cert value Specify ca certification path --target value Specific target directory 参数解释 csr : 指定CSR描述文件路径； is_ca : 指定签发人是否为CA证书； key : 指定当前签发人私钥路径； cert : 指定当前签发人证书路径； target : 指定生成的证书路径。","text_tokens":["--",":","command","生成","证书","-","secp256r1","为","issue","bitxhub","["," ","指定","by","]","cert","csr","；","usage","描述","arguments","whether","directory","private","is","it","s","文件","specific","人","。","specify","path","key","是否","options","当前","的","签发","'","value","_","私钥","...","certification","路径","解释","ca","target","参数","name"],"title":"bitxhub cert issue","title_tokens":["issue","bitxhub","cert"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-cert-parse","text":"证书解析。 NAME: BitXHub cert parse - parse certification USAGE: BitXHub cert parse [ command options ] [ arguments... ] OPTIONS: --path value certification path 参数解释 path : 指定证书路径。","text_tokens":["--",":","command","证书","-","解析","bitxhub","["," ","指定","]","cert","usage","arguments","。","path","options","value","...","certification","路径","解释","parse","参数","name"],"title":"bitxhub cert parse","title_tokens":["parse","bitxhub","cert"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-cert-priv","text":"生成或展示用于p2p网络通信的私钥。 NAME: BitXHub cert priv - Generate and show private key for certificate USAGE: BitXHub cert priv command [ command options ] [ arguments... ] COMMANDS: gen Create new private key pid Show pid from private key 子命令 私钥生成","text_tokens":["pid","name",":","command","gen","生成","-","for","certificate","bitxhub","["," ","create","and","cert","]","commands","usage","arguments","通信","from","网络","private","用于","网络通信","。","show","key","options","的","p2p","命令","new","私钥","展示","...","子","或","generate","priv"],"title":"bitxhub cert priv","title_tokens":["priv","bitxhub","cert"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-cert-priv-gen","text":"NAME: BitXHub cert priv gen - Create new private key USAGE: BitXHub cert priv gen [ command options ] [ arguments... ] OPTIONS: --name value Specific private key name --target value Specific target directory 示例说明 bitxhub cert priv gen --name server --target ./ server.priv key is generated under directory /Users/xxx/GolandProjectsTest/bitxhub-docs","text_tokens":["--","name",":","command","gen","golandprojectstest","docs","说明","-","示例","users","create","bitxhub","["," ","xxx","]","cert","usage","arguments","directory","generated","private",".","is","/","specific","server","key","options","value","new","...","under","target","priv"],"title":"bitxhub cert priv gen","title_tokens":["cert","gen","priv","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-cert-priv-pid","text":"获取libp2p节点pid。 NAME: BitXHub cert priv pid - Show pid from private key USAGE: BitXHub cert priv pid [ command options ] [ arguments... ] OPTIONS: --path value Specific private key path 示例说明 bitxhub cert priv pid --path ./server.priv # 控制台输出 QmWw4hPtm51jpxzKjyYMe3E7bNei9wdoug6B1rZqSwVSL4","text_tokens":["pid","--","name",":","command","说明","-","示例","bitxhub","["," ","]","cert","usage","qmww4hptm51jpxzkjyyme3e7bnei9wdoug6b1rzqswvsl4","节点","from","arguments","控制","private",".","/","控制台","specific","。","show","path","key","获取","options","server","#","value","输出","...","libp2p","priv"],"title":"bitxhub cert priv pid","title_tokens":["pid","cert","priv","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client","text":"","text_tokens":[],"title":"bitxhub client","title_tokens":["client","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#_7","text":"该命令 bitxhub client 提供中继链节点的客户端操作命令。它包含了账户信息查询、中继链信息、区块查询、节点网络信息、回执查询、交易操作、验证者集查询、删除共识节点、提案治理。 子命令信息如下: NAME: BitXHub client - BitXHub client command USAGE: BitXHub client command [ command options ] [ arguments... ] COMMANDS: account Query account information chain Query bitxhub chain info block Query block network Query network info from node receipt Query receipt tx Transaction manipulation validators Query validator address delVPNode delete a vp node governance governance command 参数解释 gateway : 指定客户端http服务地址，如果节点开启了TLS功能，则需要传递https地址； cert : 指定节点的CA证书，如果节点开始了TLS功能，需要传递； OPTIONS: --gateway value Specific gateway address ( default: \"http://localhost:9091/v1/\" ) --cert value Specific ca cert file if https is enabled --help, -h show help","text_tokens":["governance","者","command","包含","信息","治理","[","客户端","]","commands","cert","；","usage","如果","开启","delvpnode","is","区块","操作命令","(","specific","receipt","options","中继","...","验证","manipulation","共识","address","tls",":","操作","证书","指定","传递","节点","arguments","from","回执","account","集","if","/","localhost","vp","tx","。","show","的","value","交易","则","information","default","解释","参数","query","name","gateway","enabled",",","info","链","\"",")","如下","查询","network","9091","node","提供","命令","子","提案","transaction","block","https","功能","--","删除","validators","help","client","-","h","bitxhub"," ","chain","它","客户","delete","网络","、","需要","validator","file","a","http","v1","，","服务","地址","ca","了","该","开始","账户"],"title":"功能","title_tokens":["功能"]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#_8","text":"","text_tokens":[],"title":"子命令","title_tokens":["命令","子"]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-account","text":"账户信息查询。 bitxhub client account 0x79a1215469FaB6f9c63c1816b45183AD3624bE34 # 控制台输出 { \"type\" : \"normal\" , \"balance\" : 100000000 , \"contract_count\" : 0 , \"code_hash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" }","text_tokens":[":",",","client","信息","contract","code","\"","bitxhub"," ","0","100000000","}","0x0000000000000000000000000000000000000000000000000000000000000000","控制","account","控制台","count","查询","。","0x79a1215469fab6f9c63c1816b45183ad3624be34","#","hash","输出","_","type","balance","normal","{","账户"],"title":"bitxhub client account","title_tokens":["client","account","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-chain","text":"中继链信息查询。 NAME: BitXHub client chain - Query bitxhub chain info USAGE: BitXHub client chain command [ command options ] [ arguments... ] COMMANDS: meta Query bitxhub chain meta status Query bitxhub chain status OPTIONS: --help, -h show help","text_tokens":["--",":","command",",","help","client","-","信息","info","链","h","bitxhub","["," ","chain","]","commands","usage","arguments","status","meta","查询","。","show","options","中继","...","query","name"],"title":"bitxhub client chain","title_tokens":["client","chain","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-chain-meta","text":"查询中继链信息。 示例说明 bitxhub client chain meta # 控制台输出 { \"height\" : \"1\" , \"block_hash\" : \"0x0BF41c03bE038e389470dBdC9ed53DF897F178921520AF37877188d1759A7068\" }","text_tokens":[":",",","说明","client","信息","示例","链","1","\"","bitxhub"," ","chain","}","控制","height","控制台","meta","查询","。","#","hash","输出","中继","_","0x0bf41c03be038e389470dbdc9ed53df897f178921520af37877188d1759a7068","block","{"],"title":"bitxhub client chain meta","title_tokens":["meta","chain","client","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-chain-status","text":"查询中继链状态是否可用。 示例说明 # normal: 已处在共识状态 # abnormal：未共识状态，集群没有正常运行 $ bitxhub client chain status # 控制台输出 normal","text_tokens":[":","说明","client","示例","链","bitxhub"," ","未","chain","abnormal","集群","正常","处在","status","控制","$","控制台","状态","查询","。","是否","#","没有","中继","输出","，","normal","：","可用","已","共识","运行"],"title":"bitxhub client chain status","title_tokens":["chain","client","status","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-block","text":"区块信息查询， 可指定区块号或区块Hash 。 示例说明 $ bitxhub client block 1 # 控制台输出 { \"block_header\" : { \"number\" : \"1\" , \"state_root\" : \"0xC3A3B54F593e638D8a9FAbf66b781EFcb14D0f013D7c3E3a02ef698294f6BBF5\" } , \"block_hash\" : \"0x0BF41c03bE038e389470dBdC9ed53DF897F178921520AF37877188d1759A7068\" , \"signature\" : \"74DK6FeGnAYBJ0pJ4bLwIaT9cp9YwIscenKsRc7myXUBQfvvLKhIpZqPJkf8tAI7V8u89SLOAdz94fo/ajKi+wA=\" }","text_tokens":[":",",","说明","client","信息","示例","号","\"","state","bitxhub"," ","指定","}","74dk6fegnaybj0pj4blwiat9cp9ywiscenksrc7myxubqfvvlkhipzqpjkf8tai7v8u89sloadz94fo","+","ajki","控制","$","{","=","区块","/","控制台","查询","。","#","wa","number","hash","输出","可","_","，","或","signature","0x0bf41c03be038e389470dbdc9ed53df897f178921520af37877188d1759a7068","0xc3a3b54f593e638d8a9fabf66b781efcb14d0f013d7c3e3a02ef698294f6bbf5","block","header","root","1"],"title":"bitxhub client block","title_tokens":["client","bitxhub","block"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-network","text":"全网节点信息。 示例说明 $ bitxhub client network # 控制台输出 { \"1\" : { \"id\" : 1 , \"pid\" : \"QmXi58fp9ZczF3Z5iz1yXAez3Hy5NYo1R8STHWKEM9XnTL\" , \"account\" : \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\" , \"hosts\" : [ \"/ip4/127.0.0.1/tcp/4001/p2p/\" ] } , \"2\" : { \"id\" : 2 , \"pid\" : \"QmbmD1kzdsxRiawxu7bRrteDgW1ituXupR8GH6E2EUAHY4\" , \"account\" : \"0x79a1215469FaB6f9c63c1816b45183AD3624bE34\" , \"hosts\" : [ \"/ip4/127.0.0.1/tcp/4002/p2p/\" ] } , \"3\" : { \"id\" : 3 , \"pid\" : \"QmQUcDYCtqbpn5Nhaw4FAGxQaSSNvdWfAFcpQT9SPiezbS\" , \"account\" : \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\" , \"hosts\" : [ \"/ip4/127.0.0.1/tcp/4003/p2p/\" ] } , \"4\" : { \"id\" : 4 , \"pid\" : \"QmQW3bFn8XX1t4W14Pmn37bPJUpUVBrBjnPuBZwPog3Qdy\" , \"account\" : \"0xc0Ff2e0b3189132D815b8eb325bE17285AC898f8\" , \"hosts\" : [ \"/ip4/127.0.0.1/tcp/4004/p2p/\" ] } }","text_tokens":["pid",":",",","说明","0xc0ff2e0b3189132d815b8eb325be17285ac898f8","client","信息","示例","0.1","qmqucdyctqbpn5nhaw4fagxqassnvdwfafcpqt9spiezbs","\"","4","bitxhub","["," ","id","3","]","}","ip4","4002","节点","控制","$","{","account",".","全网","/","控制台","qmxi58fp9zczf3z5iz1yxaez3hy5nyo1r8sthwkem9xntl","0x97c8b516d19edbf575d72a172af7f418be498c37","4004","。","0x79a1215469fab6f9c63c1816b45183ad3624be34","network","127.0","#","qmqw3bfn8xx1t4w14pmn37bpjupuvbrbjnpubzwpog3qdy","输出","p2p","4001","4003","tcp","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013","2","hosts","qmbmd1kzdsxriawxu7brrtedgw1ituxupr8gh6e2euahy4","1"],"title":"bitxhub client network","title_tokens":["client","network","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-receipt","text":"交易回执查询。 示例说明 $ bitxhub client receipt 0x08ab0E9175ae67Aed7a085D6813C156e4ED3b49cDf902e02280F6a62d7AaD61E # 控制台输出 { \"tx_hash\" : \"0x08ab0E9175ae67Aed7a085D6813C156e4ED3b49cDf902e02280F6a62d7AaD61E\" , \"ret\" : null, \"status\" : 0 , \"events\" : [] }","text_tokens":[":",",","说明","client","示例","\"","bitxhub","["," ","0","]","}","0x08ab0e9175ae67aed7a085d6813c156e4ed3b49cdf902e02280f6a62d7aad61e","控制","status","回执","$","null","控制台","events","tx","查询","。","receipt","ret","#","hash","输出","交易","_","{"],"title":"bitxhub client receipt","title_tokens":["client","bitxhub","receipt"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-tx","text":"交易发送与交易查询。 NAME: BitXHub client tx - Transaction manipulation USAGE: BitXHub client tx command [ command options ] [ arguments... ] COMMANDS: get Query transaction send Send transaction OPTIONS: --help, -h show help","text_tokens":["--",":","command",",","help","client","-","send","发送","h","bitxhub","["," ","get","]","commands","usage","arguments","tx","查询","。","show","options","与","交易","...","manipulation","transaction","query","name"],"title":"bitxhub client tx","title_tokens":["client","tx","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-tx-send","text":"交易发送 示例说明 $ bitxhub client tx send --key scripts/build/node1/key.json --to 0x97c8B516D19edBf575D72a172Af7F418BE498C37 --amount 2 --type 0 # 控制台输出 { \"tx_hash\" : \"0x08ab0E9175ae67Aed7a085D6813C156e4ED3b49cDf902e02280F6a62d7AaD61E\" }","text_tokens":["--",":","说明","client","示例","send","发送","\"","bitxhub"," ","node1","0","to","}","0x08ab0e9175ae67aed7a085d6813c156e4ed3b49cdf902e02280f6a62d7aad61e","控制","$",".","/","build","控制台","tx","json","0x97c8b516d19edbf575d72a172af7f418be498c37","key","scripts","#","hash","输出","amount","交易","_","type","2","{"],"title":"bitxhub client tx send","title_tokens":["tx","client","send","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-tx-get","text":"交易查询 示例说明 $ bitxhub client tx get 0x08ab0E9175ae67Aed7a085D6813C156e4ED3b49cDf902e02280F6a62d7AaD61E # 控制台输出 { \"tx\" : { \"from\" : \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\" , \"to\" : \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\" , \"timestamp\" : \"1638168425560507000\" , \"transaction_hash\" : \"0x08ab0E9175ae67Aed7a085D6813C156e4ED3b49cDf902e02280F6a62d7AaD61E\" , \"payload\" : \"EAI=\" , \"nonce\" : \"2\" , \"signature\" : \"mdOdSzAOTDxfZ0VphvyDyir1lE8w31rUaSTtnj1us9NMhtUPVHz5bLcOBdZrmUfnaVhL3xGQxK3/P7WHmihxIQA=\" } , \"tx_meta\" : { \"block_hash\" : \"HoMgbS+NeCRds5Qc/58NfHXA+jVCuhUcsc7p9IvJxMc=\" , \"block_height\" : \"3\" }}","text_tokens":[":","1638168425560507000",",","说明","necrds5qc","client","示例","\"","bitxhub"," ","get","3","nonce","to","p7whmihxiqa","}","+","0x08ab0e9175ae67aed7a085d6813c156e4ed3b49cdf902e02280f6a62d7aad61e","控制","from","jvcuhucsc7p9ivjxmc","height","$","=","/","控制台","meta","tx","查询","0x97c8b516d19edbf575d72a172af7f418be498c37","payload","#","mdodszaotdxfz0vphvydyir1le8w31ruasttnj1us9nmhtupvhz5blcobdzrmufnavhl3xgqxk3","hash","输出","eai","homgbs","交易","_","timestamp","signature","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013","transaction","block","2","58nfhxa","{"],"title":"bitxhub client tx get","title_tokens":["get","tx","client","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-validators","text":"全网验证人信息。 示例说明 $ bitxhub client validators # 控制台输出 [ \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\" , \"0x79a1215469FaB6f9c63c1816b45183AD3624bE34\" , \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\" , \"0xc0Ff2e0b3189132D815b8eb325bE17285AC898f8\" ]","text_tokens":[",","说明","validators","0xc0ff2e0b3189132d815b8eb325be17285ac898f8","client","信息","示例","\"","bitxhub","["," ","]","控制","$","全网","控制台","人","0x97c8b516d19edbf575d72a172af7f418be498c37","。","0x79a1215469fab6f9c63c1816b45183ad3624be34","#","输出","验证","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013"],"title":"bitxhub client validators","title_tokens":["client","bitxhub","validators"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-delvpnode","text":"动态删除共识节点 NAME: BitXHub client delVPNode - delete a vp node USAGE: BitXHub client delVPNode [ command options ] [ arguments... ] OPTIONS: --pid value pid of vp node","text_tokens":["pid","--","of",":","command","删除","client","-","bitxhub","["," ","]","usage","节点","arguments","delete","delvpnode","动态","vp","options","node","value","a","...","共识","name"],"title":"bitxhub client delVPNode","title_tokens":["delvpnode","client","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-governance","text":"提案治理命令。 NAME: BitXHub client governance - governance command USAGE: BitXHub client governance command [ command options ] [ arguments... ] COMMANDS: vote vote to a proposal proposals query proposals based on the condition chain appchain manage command","text_tokens":["governance","appchain",":","command","client","-","manage","治理","bitxhub","["," ","condition","]","commands","chain","to","usage","arguments","based","on","。","options","the","命令","a","...","提案","proposals","proposal","vote","query","name"],"title":"bitxhub client governance","title_tokens":["governance","client","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-governance-vote","text":"提案投票。 NAME: BitXHub client governance vote - vote to a proposal USAGE: BitXHub client governance vote [ command options ] [ arguments... ] OPTIONS: --id value proposal id --info value voting information, approve or reject --reason value reason to vote 参数解释 id ：必选参数。提案id，生成提案时将在控制台打印。 info ：必选参数。是否通过提案。approve为通过，reject为拒绝。 reason ：必选参数。投票理由说明。 示例说明 $ bitxhub client governance vote --info approve --reason test --id 0x9A601dbebf20f3E3362241810C2229F7f97329d6-0 # 控制台输出 vote successfully! 0x9A601dbebf20f3E3362241810C2229F7f97329d6-0","text_tokens":["governance","--","将",":","command",",","说明","生成","reject","client","-","示例","info","0x9a601dbebf20f3e3362241810c2229f7f97329d6","在","拒绝","为","bitxhub","["," ","id","投票","0","]","!","理由","approve","to","usage","arguments","控制","通过","test","or","$","reason","控制台","时","。","打印","是否","#","options","value","输出","a","voting","...","必选","提案","，","information","解释","：","successfully","参数","proposal","vote","name"],"title":"bitxhub client governance vote","title_tokens":["governance","client","vote","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-governance-proposals","text":"提案查询。用于查询中继链提案的内容以及相关的状态。命令说明如下： NAME: BitXHub client governance proposals - query proposals based on the condition USAGE: BitXHub client governance proposals [ command options ] [ arguments... ] OPTIONS: --id value proposal id --type value proposal type, currently only AppchainMgr is supported --status value proposal status, one of proposed, approve or reject --from value the address of the account to which the proposal was made 参数解释 id : 提案id； type : 提案类型，当前支持应用链管理； status : 提案状态，是否通过； from : 提案者地址。 示例说明 $ bitxhub client governance proposals --id 0x0FDDC68A2300cF9CB0a217123D5f656e0943C1Da-0 --type AppchainMgr --status proposed --from 0x0FDDC68A2300cF9CB0a217123D5f656e0943C1Da # 控制台输出 Id Type Status ApproveNum RejectNum ElectorateNum ThresholdNum Des -- ---- ------ ---------- --------- ------------- ------------ --- 0x9A601dbebf20f3E3362241810C2229F7f97329d6-0 AppchainMgr proposed 1 0 4 3 register","text_tokens":["governance","者","command","说明","proposed","示例","0x9a601dbebf20f3e3362241810c2229f7f97329d6","[","condition","id","register","]","；","to","usage","通过","$","is","based","是否","options","supported","中继","输出","only","...","类型","type","rejectnum","one","0x0fddc68a2300cf9cb0a217123d5f656e0943c1da","：","proposal","address",":","appchainmgr","reject","0","arguments","from","控制","相关","or","account","on","控制台","状态","。","#","thresholdnum","的","value","the","was","proposals","解释","---------","参数","query","name","of",",","支持","链","----","------","status","如下","---","查询","当前","命令","提案","-------------","内容","--","electoratenum","以及","des","client","-","4","bitxhub"," ","3","approve","which","用于","made","，","地址","应用","管理","approvenum","------------","----------","1","currently"],"title":"bitxhub client governance proposals","title_tokens":["governance","proposals","client","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_cmd/#bitxhub-client-governance-chain","text":"应用链管理。命令说明如下： NAME: BitXHub client governance chain - appchain manage command USAGE: BitXHub client governance chain command [ command options ] [ arguments... ] COMMANDS: status query chain status by chain id freeze freeze appchain by chain id activate activate chain by chain id 参数解释 status :查询应用链状态； freeze :应用链冻结； activate :应用链激活。 示例说明 # 管理员治理投票通过后，应用链状态从registing转换为available $ bitxhub client governance chain status --id 0x0FDDC68A2300cF9CB0a217123D5f656e0943C1Da # 控制台输出 appchain 0x0FDDC68A2300cF9CB0a217123D5f656e0943C1Da is available","text_tokens":["governance","available","--","appchain",":","command","说明","冻结","client","-","示例","链","manage","治理","为","bitxhub","["," ","id","投票","by","chain","]","commands","；","usage","arguments","控制","status","通过","如下","$","registing","is","控制台","查询","状态","。","#","options","后","转换","输出","命令","activate","...","，","激活","freeze","：","解释","管理员","0x0fddc68a2300cf9cb0a217123d5f656e0943c1da","参数","管理","应用","query","name","从"],"title":"bitxhub client governance chain","title_tokens":["governance","chain","client","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_key/","text":"bitxhub key 功能 该命令 bitxhub key 提供针对bitxhub节点的私钥管理。 它包含了私钥生成、私钥查看、地址查看。 子命令信息如下: NAME: BitXHub key - Create and show key information USAGE: BitXHub key command [command options] [arguments...] COMMANDS: gen Create new Secp256k1 private key in specified directory show Show BitXHub key from repo address Show address from Secp256k1 private key 子命令 bitxhub key gen 生成节点私钥 target: 指定生成路径 passwd: 指定私钥密码 NAME: BitXHub key gen - Create new Secp256k1 private key in specified directory USAGE: BitXHub key gen [command options] [arguments...] OPTIONS: --target value Specific target directory --passwd value Specify password 样例 bitxhub key gen --target ~/.bitxhub key.json key is generated under directory /Users/windiyi/.bitxhub bitxhub key show 样例： bitxhub key show { \"type\": 3, \"cipher\": { \"data\": \"18bc2c685cc79d7098fa1f3b97f14541121b61b1d3492ef4f298c84844e7b380fa8e8a84dc44d910aa9dafddc0347c670bace2c74d8553a4c843ae58ce4aeb78\", \"cipher\": \"AES-256\" } } bitxhub key address 样例： bitxhub key address --path ./key.json --passwd 123 0x3Db84D019fCd3A845e2fB3A21B56812Ffd933f19","text_tokens":["command","包含","信息","windiyi","create","[","]","commands","}","usage","directory","generated","data","查看","is","18bc2c685cc79d7098fa1f3b97f14541121b61b1d3492ef4f298c84844e7b380fa8e8a84dc44d910aa9dafddc0347c670bace2c74d8553a4c843ae58ce4aeb78","specific","json","specify","options","aes","new","...","under","type","：","address","针对",":","生成","users","0x3db84d019fcd3a845e2fb3a21b56812ffd933f19","cipher","指定","节点","arguments","specified","from","/","123","。","show","的","value","information","passwd","name","password","gen",",","secp256k1","\"","256","in","repo","如下",".","提供","命令","私钥","样例","子","路径","功能","--","-","bitxhub"," ","密码","3","and","它","private","、","path","key","~","地址","target","管理","了","该","{"],"title":"bitxhub key","title_tokens":["key","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_key/#bitxhub-key","text":"","text_tokens":[],"title":"bitxhub key","title_tokens":["key","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_key/#_1","text":"该命令 bitxhub key 提供针对bitxhub节点的私钥管理。 它包含了私钥生成、私钥查看、地址查看。 子命令信息如下: NAME: BitXHub key - Create and show key information USAGE: BitXHub key command [command options] [arguments...] COMMANDS: gen Create new Secp256k1 private key in specified directory show Show BitXHub key from repo address Show address from Secp256k1 private key","text_tokens":["针对","name",":","command","gen","生成","包含","信息","-","secp256k1","create","bitxhub","["," ","and","]","它","commands","in","usage","节点","arguments","specified","directory","from","如下","repo","private","、","查看","。","show","key","options","的","提供","命令","new","私钥","子","...","information","地址","管理","了","address","该"],"title":"功能","title_tokens":["功能"]},{"location":"bitxhub/dev/cmd/bitxhub_key/#_2","text":"","text_tokens":[],"title":"子命令","title_tokens":["命令","子"]},{"location":"bitxhub/dev/cmd/bitxhub_key/#bitxhub-key-gen","text":"生成节点私钥 target: 指定生成路径 passwd: 指定私钥密码 NAME: BitXHub key gen - Create new Secp256k1 private key in specified directory USAGE: BitXHub key gen [command options] [arguments...] OPTIONS: --target value Specific target directory --passwd value Specify password 样例 bitxhub key gen --target ~/.bitxhub key.json key is generated under directory /Users/windiyi/.bitxhub","text_tokens":["--","password",":","command","gen","生成","-","windiyi","secp256k1","users","create","bitxhub","["," ","指定","密码","]","in","usage","节点","specified","directory","arguments","generated","private",".","is","/","specific","json","specify","key","options","value","new","私钥","样例","...","under","路径","~","passwd","target","name"],"title":"bitxhub key gen","title_tokens":["key","gen","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_key/#bitxhub-key-show","text":"样例： bitxhub key show { \"type\": 3, \"cipher\": { \"data\": \"18bc2c685cc79d7098fa1f3b97f14541121b61b1d3492ef4f298c84844e7b380fa8e8a84dc44d910aa9dafddc0347c670bace2c74d8553a4c843ae58ce4aeb78\", \"cipher\": \"AES-256\" } }","text_tokens":[":",",","-","\"","bitxhub","cipher","256"," ","3","}","data","18bc2c685cc79d7098fa1f3b97f14541121b61b1d3492ef4f298c84844e7b380fa8e8a84dc44d910aa9dafddc0347c670bace2c74d8553a4c843ae58ce4aeb78","show","key","aes","样例","type","：","{"],"title":"bitxhub key show","title_tokens":["show","key","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_key/#bitxhub-key-address","text":"样例： bitxhub key address --path ./key.json --passwd 123 0x3Db84D019fCd3A845e2fB3A21B56812Ffd933f19","text_tokens":["--","json","passwd","：","path","key","123","0x3db84d019fcd3a845e2fb3a21b56812ffd933f19","address",".","/","样例","bitxhub"," "],"title":"bitxhub key address","title_tokens":["address","key","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_start/","text":"bitxhub start 该命令 bitxhub start 显示BitXHub的版本信息。 它会在命令行显示版本、构建日期、操作系统/架构和Go编译器版本。 例如: bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 start BitXHub version: dev-fixx-1.6-2a2f39f App build date: 2021-11-25T16:43:19 System version: darwin/amd64 Golang version: go1.14.15 time=\"2021-11-29T18:07:37.722\" level=info msg=\"MemPool batch size = 200\" module=order time=\"2021-11-29T18:07:37.722\" level=info msg=\"MemPool tx slice size = 200\" module=order time=\"2021-11-29T18:07:37.722\" level=info msg=\"MemPool batch seqNo = 6\" module=order time=\"2021-11-29T18:07:37.723\" level=info msg=\"MemPool pool size = 50000\" module=order time=\"2021-11-29T18:07:37.723\" level=info msg=\"Raft localID = 1\" module=order time=\"2021-11-29T18:07:37.723\" level=info msg=\"Raft lastExec = 6 \" module=order time=\"2021-11-29T18:07:37.723\" level=info msg=\"Raft snapshotCount = 1000\" module=order time=\"2021-11-29T18:07:37.723\" level=info msg=\"GRPC service started\" module=api port=60011 time=\"2021-11-29T18:07:37.723\" level=info msg=\"Gateway service started\" module=api port=9091 参数 passwd：指定节点私钥密码 若不指定以上配置，则默认至bitxhub --repo路径下寻找 NAME: bitxhub start - Start a long-running start process USAGE: bitxhub start [command options] [arguments...] OPTIONS: --passwd value bitxhub key password","text_tokens":["37.722","command","time","windiyi","信息","started","[","不","]","raft","usage","1.6","07","amd64","node3","size","2a2f39f","options","至","version","11","...","：","service","2021",":","操作","api","在","users","msg","dev","指定","go1.14","操作系统","构建","pool","节点","arguments","系统","port","=","/","tx","fixx","。","6","的","snapshotcount","value","命令行","seqno","50000","架构","则","passwd","默认","例如","system","参数","module","batch","lastexec","name","15","password","gateway","编译","它会","darwin","golang","info","\"","process","37.723","29t18","repo",".","build","9091","app","slice","命令","私钥","版本信息","200","mempool","路径","下","1000","order","start","--","go","-","日期","以上","配置","bitxhub","25t16"," ","19","密码","43","和","、","grpc","localid","running","date","ideaprojects","key","scripts","level","long","显示","60011","寻找","a","版本","，","编译器","该","若","1"],"title":"bitxhub start","title_tokens":["start","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_start/#bitxhub-start","text":"该命令 bitxhub start 显示BitXHub的版本信息。 它会在命令行显示版本、构建日期、操作系统/架构和Go编译器版本。 例如: bitxhub --repo=/Users/windiyi/IdeaProjects/bitxhub/scripts/build/node3 start BitXHub version: dev-fixx-1.6-2a2f39f App build date: 2021-11-25T16:43:19 System version: darwin/amd64 Golang version: go1.14.15 time=\"2021-11-29T18:07:37.722\" level=info msg=\"MemPool batch size = 200\" module=order time=\"2021-11-29T18:07:37.722\" level=info msg=\"MemPool tx slice size = 200\" module=order time=\"2021-11-29T18:07:37.722\" level=info msg=\"MemPool batch seqNo = 6\" module=order time=\"2021-11-29T18:07:37.723\" level=info msg=\"MemPool pool size = 50000\" module=order time=\"2021-11-29T18:07:37.723\" level=info msg=\"Raft localID = 1\" module=order time=\"2021-11-29T18:07:37.723\" level=info msg=\"Raft lastExec = 6 \" module=order time=\"2021-11-29T18:07:37.723\" level=info msg=\"Raft snapshotCount = 1000\" module=order time=\"2021-11-29T18:07:37.723\" level=info msg=\"GRPC service started\" module=api port=60011 time=\"2021-11-29T18:07:37.723\" level=info msg=\"Gateway service started\" module=api port=9091","text_tokens":["37.722","time","windiyi","信息","started","raft","1.6","07","amd64","node3","size","2a2f39f","version","11","service","2021",":","操作","api","在","users","msg","dev","go1.14","操作系统","构建","pool","系统","port","=","/","tx","fixx","。","6","的","snapshotcount","命令行","seqno","50000","架构","例如","system","module","batch","lastexec","15","gateway","编译","它会","darwin","golang","info","\"","37.723","29t18","repo",".","build","9091","app","slice","命令","版本信息","200","mempool","1000","order","start","--","go","-","日期","bitxhub","25t16"," ","19","43","和","、","grpc","localid","date","ideaprojects","scripts","level","显示","60011","版本","编译器","该","1"],"title":"bitxhub start","title_tokens":["start","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_start/#_1","text":"passwd：指定节点私钥密码 若不指定以上配置，则默认至bitxhub --repo路径下寻找 NAME: bitxhub start - Start a long-running start process USAGE: bitxhub start [command options] [arguments...] OPTIONS: --passwd value bitxhub key password","text_tokens":["--","start","password",":","command","-","以上","配置","bitxhub","["," ","指定","process","密码","不","]","usage","节点","arguments","repo","running","key","options","value","至","long","a","私钥","寻找","...","，","则","路径","passwd","默认","：","下","name","若"],"title":"参数","title_tokens":["参数"]},{"location":"bitxhub/dev/cmd/bitxhub_version/","text":"bitxhub version 该命令 bitxhub version 显示BitXHub的版本信息。 它会在命令行显示版本、构建日期、操作系统/架构和Go编译器版本。 例如: BitXHub version: dev-release-1.11-48106fe App build date: 2021-11-30T11:26:16 System version: darwin/amd64 Golang version: go1.14.15 语法 该命令 bitxhub version 不含参数. bitxhub version NAME: bitxhub version - BitXHub version USAGE: bitxhub version [arguments...]","text_tokens":["30t11","15","name",":","操作","编译","go","含","它会","-","信息","日期","darwin","在","golang","bitxhub","["," ","dev","go1.14","操作系统","不","]","语法","构建","usage","arguments","和","系统","、","amd64",".","/","build","release","。","48106fe","date","16","的","命令行","app","显示","version","命令","11","版本信息","版本","...","架构","26","例如","1.11","system","参数","编译器","该","2021"],"title":"bitxhub version","title_tokens":["version","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_version/#bitxhub-version","text":"该命令 bitxhub version 显示BitXHub的版本信息。 它会在命令行显示版本、构建日期、操作系统/架构和Go编译器版本。 例如: BitXHub version: dev-release-1.11-48106fe App build date: 2021-11-30T11:26:16 System version: darwin/amd64 Golang version: go1.14.15","text_tokens":["30t11","15",":","操作","编译","go","它会","-","信息","日期","darwin","在","golang","bitxhub"," ","dev","go1.14","操作系统","构建","和","系统","、","amd64",".","/","build","release","。","48106fe","date","16","的","命令行","app","显示","命令","version","11","版本信息","版本","架构","26","例如","1.11","system","编译器","该","2021"],"title":"bitxhub version","title_tokens":["version","bitxhub"," "]},{"location":"bitxhub/dev/cmd/bitxhub_version/#_1","text":"该命令 bitxhub version 不含参数.","text_tokens":["不","该","含","参数",".","命令","version","bitxhub"," "],"title":"语法","title_tokens":["语法"]},{"location":"bitxhub/dev/cmd/bitxhub_version/#bitxhub-version_1","text":"NAME: bitxhub version - BitXHub version USAGE: bitxhub version [arguments...]","text_tokens":["name",":","]","usage","...","arguments","-","version","bitxhub","["," "],"title":"bitxhub version","title_tokens":["version","bitxhub"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/","text":"Pier命令行 pier 命令有多组子命令，其作用是与应用链或中继链交互， pier 命令描述如下： NAME: Pier - Manipulate the crosschain node USAGE: pier [ global options ] command [ command options ] [ arguments... ] VERSION: 0 .0.0 COMMANDS: appchain Command about appchain in bitxhub client Command about appchain in pier id Get appchain id init Initialize pier core local configuration config Initialize pier plugins configuration interchain Query interchain info p2p Command about p2p rule Command about rule start Start a long-running daemon process version Show version about ap proposals proposals manage command show Show pier key from repo help, h Shows a list of commands or help for one command 参数解释 --repo ：可选参数，指定pier节点配置文件所在目录，如果不指定，默认使用$HOME/.bitxhub目录。 --tls ：可选参数，用于pier节点与bitxhub进行tls加密传输。如果不指定，默认为false。 GLOBAL OPTIONS: --repo value Pier repository path --tls enable tls between pier and bitxhub or not --help, -h show help --version, -v print the version 子命令描述 pier appchain pier appchain 命令用于中继模式下，跨链网关Pier向中继链bitXHub实现应用链相关信息的注册、更新、变更等操作。 用法 NAME: Pier appchain - Command about appchain in bitxhub USAGE: Pier appchain command [ command options ] [ arguments... ] COMMANDS: method Command about appchain method did Command about appchain did register Register pier to bitxhub update update appchain in bitxhub activate activate appchain in bitxhub logout logout appchain in bitxhub get Get appchain info OPTIONS: --help, -h show help 具体描述 pier appchain 具体描述与使用示例参考 中继模式管理 。 pier client pier client 命令用于直连模式的应用链管理。 用法 NAME: Pier client - Command about appchain in pier USAGE: Pier client command [ command options ] [ arguments... ] COMMANDS: register Register appchain in pier update Update appchain in pier audit Audit appchain in pier get Get appchain info rule register appchain validation rule OPTIONS: --help, -h show help 具体描述 pier appchain 具体描述与使用示例参考 直连模式管理 。 pier id pier id 命令用于获取所绑定的应用链地址。 用法 NAME: pier id - Get appchain id USAGE: pier id [arguments...] 具体描述 样例： $ pier --repo $HOME /.pier1 id # 控制台输出 0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb pier init pier init 命令用于初始化pier相关配置。如生成公私钥、ca证书等。 用法 NAME: Pier init - Initialize pier core local configuration USAGE: Pier init command [ command options ] [ arguments... ] COMMANDS: relay Initialize pier relay mode configuration direct Initialize pier direct mode configuration union Initialize pier union mode configuration OPTIONS: --http-port value Specify http port ( default: 44544 ) --pprof-port value Specify pprof port ( default: 44555 ) --enable-tls Enable TLS or not --tlsca value Specify TLS CA certificate path ( default: \"certs/ca.pem\" ) --common-name value Specify common name to verify ( default: \"localhost\" ) --ha value Specify if pier will run in single mode or high availability mode ( default: \"single\" ) --help, -h show help 具体描述 参数解释 --http-port ：可选参数，指定监听的http端口号，默认为44544。 --pprof-port ：可选参数，指定pprof的端口号，默认为44555. --enable-tls ：可选参数，是否进行TLS加密传输，默认为false。 --tlsca ：可选参数，TLS CA路径，默认为certs/ca.pem。 --common-name ：可选参数，指定ca证书的域名。默认为localhost。 --ha ：可选参数，选择网关是否高可用，高可用功能为商业版本，默认只有单个网关。 pier init delay 中继模式网关初始化，命令参数如下： NAME: Pier init relay - Initialize pier relay mode configuration USAGE: Pier init relay [ command options ] [ arguments... ] OPTIONS: --addrs value Specify bitxhub nodes ' address ( default: \"localhost:60011\" , \"localhost:60012\" , \"localhost:60013\" , \"localhost:60014\" ) --quorum value Specify the quorum number of BitXHub ( default: 2 ) --validators value Specify validators of bitxhub ( default: \"0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd\" , \"0xe93b92f1da08f925bdee44e91e7768380ae83307\" , \"0xb18c8575e3284e79b92100025a31378feb8100d6\" , \"0x856E2B9A5FA82FD1B031D1FF6863864DBAC7995D\" ) 具体描述 参数解释 --addrs ：可选参数，指定bixhub各节点地址及端口号。 --quorum ：可选参数，指定bixhub集群的quorum个数，与具体共识算法与节点规模相关。 --validators ：可选参数，指定bitxhub管理员节点地址。 pier init direct 直连模式网关初始化，命令参数如下： NAME: Pier init direct - Initialize pier direct mode configuration USAGE: Pier init direct [ command options ] [ arguments... ] OPTIONS: --peers value Specify counter party peers to connect 具体描述 参数解释 --peers ：必选参数，指定直连模式下pier的网络信息（包含自己）。 样例： 其中地址为pier启动时所在地址，端口号可任意指定可用端口， # 初始化pier1相关配置，配置文件目录为$HOME/.pier1 $ PID1 = $( pier --repo .pier1 p2p id ) $ PID2 = $( pier --repo .pier1 p2p id ) $ pier --repo .pier1 init direct --peers /ip4/127.0.0.1/tcp/3001/p2p/ $PID1 --peers /ip4/127.0.0.1/tcp/3002/p2p/ $PID2 Pier init union 大规模模式下的初始化配置，命令如下： NAME: Pier init union - Initialize pier union mode configuration USAGE: Pier init union [ command options ] [ arguments... ] OPTIONS: --addrs value Specify bitxhub nodes ' address ( default: \"localhost:60011\" , \"localhost:60012\" , \"localhost:60013\" , \"localhost:60014\" ) --connectors value Specify the remote union peers to connect 具体描述 参数解释 --addrs ：可选参数，指定bixhub各节点地址及端口号。 --connectors ：必选参数，指定大规模模式下pier的网络信息（包含自己）。 样例： 其中地址为pier启动时所在地址，端口号可任意指定可用端口， # 初始化pier1相关配置，配置文件目录为$HOME/.pier1 $ PID1 = $( pier --repo .pier1 p2p id ) $ PID2 = $( pier --repo .pier1 p2p id ) $ pier --repo .pier1 init union --peers /ip4/127.0.0.1/tcp/3001/p2p/ $PID1 --peers /ip4/127.0.0.1/tcp/3002/p2p/ $PID2 pier config pier config 命令用于配置应用链相关信息。 用法 NAME: Pier config - Initialize pier plugins configuration USAGE: Pier config command [ command options ] [ arguments... ] COMMANDS: fabric Initialize pier and fabric plugin configuration ethereum Initialize pier and ethereum plugin configuration OPTIONS: --redownload Re-download plugin or not --help, -h show help 具体描述 参数解释 --redownload ：可选参数，是否重新下载插件，默认为true。 子命令 pier config fabric 配置fabric插件相关配置信息，并下载 pier-client-fabric 二进制文件，命令描述如下： NAME: Pier config fabric - Initialize pier and fabric plugin configuration USAGE: Pier config fabric [ command options ] [ arguments... ] OPTIONS: --crypto-config value Specify the path to crypto-config directory --config value Specify the path to fabric config.yaml --event-filter value Specify the event filter on fabric chaincode --username value Specify the username to invoke fabric chaincode --ccid value Specify chaincode id to invoke --channel-id value Specify channel id --org value Specify the organization 参数解释 --crypto-config ：必选参数，指定fabric的文件目录，一般与repo目录一致。 --config ：可选参数，指定fabric的config.yaml文件目录，默认在$repo/fabric目录下。 --event-filter ：可选参数。根据eventname过滤所需要的event pier interchain pier interchain 命令用于查询应用链的跨链交易信息。 用法 NAME: Pier interchain - Query interchain info USAGE: Pier interchain command [ command options ] [ arguments... ] COMMANDS: ibtp Query ibtp by id OPTIONS: --key value Specific key.json path --help, -h show help 具体描述 参数解释 --key ：必选参数指定pier的key.json文件。 子命令 USAGE: Pier interchain command [command options] [arguments...] COMMANDS: ibtp Query ibtp by id 样例： pier --repo $HOME /.pier1 interchain --key $HOME /.pier1/key.json ibtp --id 0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-1 # 控制台输出 INFO [ 16 :52:41.917 ] Establish connection with bitxhub localhost:60013 successfully module = rpcx Tx hash: 0x82d3434e0a295B22A8e55884FEdd137d19e8cBDc32d5B593AD6D9AFB5cf59600 tx:<from:<RawAddress: [ 255 129 153 250 228 140 128 139 69 102 125 160 204 170 238 131 155 26 16 203 ] Address: \"\" > to:<RawAddress: [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 ] Address: \"\" > timestamp:1638435054429909000 transaction_hash:<RawHash: [ 130 211 67 78 10 41 91 34 168 229 88 132 254 221 19 125 25 232 203 220 50 213 181 147 173 109 154 251 92 245 150 0 ] Hash: \"\" > IBTP:<from: \"0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb\" to: \"0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1\" index:1 timestamp:1638435054428680000 proof: \"k\\206\\262s\\3774\\374\\341\\235k\\200N\\377Z?WG\\255\\244\\352\\242/\\035I\\300\\036R\\335\\267\\207[K\" payload: \"\\022\\221\\001\\n*0x5bFe03Dbd09817d4957693f672cc31A133Bb6084\\022*0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f\\032\\020interchainCharge\\\"\\001A\\\"\\001B\\\"\\002102\\000:\\022interchainRollbackB\\001AB\\00210\" > nonce:4 signature: \"T)\\313\\333~\\316f\\372.\\010\\235\\234\\222J\\314@<\\202\\260\\243\\367b\\035\\016\\366\\326y\\3515\\020\\222\\256 $ \\010\\314\\035/\\271H\\217|~\\302\\233\\353b\\275\\267ir\\t\\242\\376\\224\\307q\\217l\\232\\037DP\\n\\317\\000\" extra: \"1\" > tx_meta:<block_hash: \"\\326{90^\\355a\\236\\342\\235i\\302\\374+\\352VI\\030\\242\\211\\335x\\371w\\221>(\\254%o\\212\\222\" block_height:14 > pier p2p pier p2p 命令用于直连模式下pier网络通信的pid。 用法 NAME: Pier p2p - Command about p2p USAGE: Pier p2p command [command options] [arguments...] COMMANDS: id get pier unique id in p2p network 具体描述 样例： # 初始化pier1相关配置，配置文件目录为$HOME/.pier1 $ pier --repo $HOME /.pier1 p2p id #控制台输出 QmNpQvh8Lm7gwt3sDqwJ1pgNn6taJLqdgtRVyZWhsD5bND pier rule pier rule 命令用于中继模式下pier向中继链部署应用链验证规则。 用法 NAME: Pier rule - Command about rule USAGE: Pier rule command [command options] [arguments...] COMMANDS: deploy Deploy validation rule update update master rule logout logout validation rule OPTIONS: --help, -h show help 具体描述 pier rule 具体描述与使用示例参考 直连模式管理 的部署验证规则模块。 pier start pier start 命令用于启动pier。 用法 NAME: pier start - Start a long-running daemon process USAGE: pier start [arguments...] 具体描述 样例 ： $ pier --repo $HOME /.pier1 start # 控制台输出 Pier version: dev-release-1.6-1b5b79f App build date: 2021 -12-01T17:50:14 System version: darwin/amd64 Golang version: go1.15.13 INFO [ 17 :07:29.150 ] Establish connection with bitxhub localhost:60013 successfully module = app 2021 -12-02T17:07:29.171+0800 [ DEBUG ] plugin: starting plugin: path = /bin/sh args = \"[sh -c /Users/liruoxin/testRelay/release1.6/eth1/plugins/eth-client]\" 2021 -12-02T17:07:29.178+0800 [ DEBUG ] plugin: plugin started: path = /bin/sh pid = 74023 2021 -12-02T17:07:29.178+0800 [ DEBUG ] plugin: waiting for RPC address: path = /bin/sh 2021 -12-02T17:07:29.283+0800 [ DEBUG ] plugin.sh: 2021 -12-02T17:07:29.283+0800 [ DEBUG ] client: plugin address: network = unix address = /var/folders/xr/pnhf9j6n2k5_fysm6s0xkgt00000gn/T/plugin718241634 2021 -12-02T17:07:29.283+0800 [ DEBUG ] plugin: using plugin: version = 4 2021 -12-02T17:07:29.284+0800 [ TRACE ] plugin.stdio: waiting for stdio data 2021 -12-02T17:07:29.287+0800 [ DEBUG ] plugin.sh: 2021 -12-02T17:07:29.287+0800 [ INFO ] client: Basic appchain info: broker address = 0xFb23Af09e3E8D83fd5575De9558920Bf351F05E8 ethereum node ip = ws://127.0.0.1:8546 2021 -12-02T17:07:29.416+0800 [ DEBUG ] plugin.sh: 2021 -12-02T17:07:29.416+0800 [ INFO ] client: ContractABI: addr = 0x5bfe03dbd09817d4957693f672cc31a133bb6084 name = transfer.abi Client Type: ethereum Pprof on localhost:44555 ………… pier version pier version 命令用于查询版本号。 用法 NAME: pier version - Show version about ap USAGE: pier version [arguments...] 具体描述 样例 ： $ pier --repo $HOME /.pier1 version Pier version: dev-release-1.11-e1e7c14 App build date: 2021 -12-01T17:50:14 System version: darwin/amd64 Golang version: go1.15.13","text_tokens":["^","using","o","181","eth","14","各","信息","包含","started","267ir","为","端口","372","get","不","13","229","directory","如果","通信","307q","$","直连","debug","xr","0x856e2b9a5fa82fd1b031d1ff6863864dbac7995d","中继","_","one","ccid","rule","并","一般","pid2","操作","enable","sh","020","002102","255","ws","rawhash","377z","=","on","tx","0xfb23af09e3e8d83fd5575de9558920bf351f05e8","。","3001","connection","154","启动","'","可","counter","解释","默认","system","global","liruoxin",",","200n","darwin","pid1","256","1b5b79f","02t17","invoke","common","in","tlsca","certs","run","unique","number","子","或","插件","configuration","tcp","between","公私","core","26","block","party","start","139","大规模","030","validators","help","client","-","chaincode","bitxhub","high"," ","19","213","245","|","org","202","326y","217","302","用于","go1.15","key","pnhf9j6n2k5","035","下载","262s","folders","035i","自己","（","150","204","管理","355a","…","353b","44555","index","326","342","broker","command","abi","155","0xb18c8575e3284e79b92100025a31378feb8100d6","3774","部署","[","deploy","register","commands","plugin","bin","07","manipulate","amd64","data","224","032","specific","plugins","e1e7c14","validation","list","timestamp","signature","：","可用","是","254","341","一致","pem","207","availability","print","147",":","50","规则","证书","在","mode","certificate","interchain","367b","102","指定","dev","transfer","其","0","00210","qmnpqvh8lm7gwt3sdqwj1pgnn6tajlqdgtrvyzwhsd5bnd","from","or","release1.6","控制台","242","352vi","网络通信","yaml","ethereum","可任意","与","的","交易","传输","374","default","fysm6s0xkgt00000gn","使用","管理员","rawaddress","74023","query","ip","name","所","250","29.150","connectors","audit",">","for","info","规模","实现","rpcx","0x5bfe03dbd09817d4957693f672cc31a133bb6084","nonce","initialize","+","集群","文件目录","repo","多组","single","267","waiting","about","testrelay","will","direct","44544","140","app","命令","daemon","config","路径","单个","222","basic","29.416","211","17","260","crypto","其中","v","206","更新","重新","251","配置","作用","366","peers","221","redownload","date","method","proof","352","271h","p2p","域名","long","a","001b","向","地址","初始化","个数","口号","1","130","243","id","如","to","usage","67","具体","{","relay","222j","选择","json","with","16","specify","是否","verify","132","version","必选","event","验证","1.11","共识","address","所在","）","获取","商业","0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd","2021","220","376","logout","rpc","users","234","加密","238","crosschain","描述","arguments","init","228","/","repository","bixhub","监听","217l","233","及","show","local","#","131","value","the","命令行","contractabi","proposals","203","module","pier","60012","pid","of","appchain","golang","链","任意","\"","1638435054428680000","153","10","process","pier1","41","34","pprof","317","var","333","ip4",")","eventname","41.917","height","高","128","文件","union","29.171","查询","235i","212","network","0.0","hash","home","170","0xe93b92f1da08f925bdee44e91e7768380ae83307","88","等","功能","--","注册","加密传输","52","020interchaincharge","ibtp","args","4","绑定","by","335x","and","ha","314","username","进制","时","需要","release","125","quorum","false","~","371w","successfully","参考","应用","69","173","129","模块","0xff8199fae48c808b45667da0ccaaee839b1a10cb","235","示例","manage","01t17","true","钥","]","160","t","unix","1.6","29.283","037dp","29.287","starting","stdio","establish","plugin718241634","(","trace","25","ap","275","options","输出","activate","...","模式","001a","type","delay","244","n","tls","生成","316f","022","313","8546","0.1","000","remote","配置文件","节点","控制","nodes","相关","port","有","update","if","localhost","connect","29.284","did","payload","@","<","filter","master","端口号","参数","109","k","c","0x82d3434e0a295b22a8e55884fedd137d19e8cbdc32d5b593ad6d9afb5cf59600","60013","78","organization","001","335","过滤","016","eth1","0800","3002","fabric","进行","300","如下","选",".","根据","大规","meta","build","re","92","addr","node","变更","1638435054429909000","wg","0xa5dd12e27ee5e79ce0b50adb376414351c8eea5f","样例","91","*","transaction","2","\\","下","022interchainrollbackb","254%","60014","12","010","二进制","算法","目录","交互","036r","h","236","not","只有","addrs","235k","90","shows","跨链","网络","、","版本号","download","初始","29.178","running","用法","127.0","path","channel","0x23fb0e7ef676467563d37d820f1b1fddb0f9a2e1","001ab","?","60011","http","extra","168","版本","，","网关","ca","232","3515"],"title":"跨链网关Pier","title_tokens":["网关","pier","跨链"]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier","text":"pier 命令有多组子命令，其作用是与应用链或中继链交互， pier 命令描述如下： NAME: Pier - Manipulate the crosschain node USAGE: pier [ global options ] command [ command options ] [ arguments... ] VERSION: 0 .0.0 COMMANDS: appchain Command about appchain in bitxhub client Command about appchain in pier id Get appchain id init Initialize pier core local configuration config Initialize pier plugins configuration interchain Query interchain info p2p Command about p2p rule Command about rule start Start a long-running daemon process version Show version about ap proposals proposals manage command show Show pier key from repo help, h Shows a list of commands or help for one command 参数解释 --repo ：可选参数，指定pier节点配置文件所在目录，如果不指定，默认使用$HOME/.bitxhub目录。 --tls ：可选参数，用于pier节点与bitxhub进行tls加密传输。如果不指定，默认为false。 GLOBAL OPTIONS: --repo value Pier repository path --tls enable tls between pier and bitxhub or not --help, -h show help --version, -v print the version","text_tokens":["command","manage","为","[","id","get","不","]","commands","usage","如果","$","manipulate","ap","plugins","options","中继","list","version","...","one","：","是","rule","所在","tls","print",":","enable","interchain","加密","指定","其","0","crosschain","配置文件","描述","arguments","from","节点","init","or","有","/","repository","。","show","local","与","value","the","可","传输","proposals","解释","默认","使用","参数","global","query","pier","name","of","appchain",",","for","info","链","process","in","initialize","进行","repo","如下","选",".","多组","文件","about","0.0","node","home","命令","daemon","config","子","或","configuration","between","core","start","--","加密传输","v","help","目录","交互","-","client","配置","h","bitxhub","作用"," ","and","not","shows","用于","running","path","key","p2p","long","a","，","false","应用"],"title":"Pier命令行","title_tokens":["pier","命令","命令行"]},{"location":"bitxhub/dev/cmd/pier_cmd/#_1","text":"","text_tokens":[],"title":"子命令描述","title_tokens":["命令","描述","子"]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-appchain","text":"pier appchain 命令用于中继模式下，跨链网关Pier向中继链bitXHub实现应用链相关信息的注册、更新、变更等操作。 用法 NAME: Pier appchain - Command about appchain in bitxhub USAGE: Pier appchain command [ command options ] [ arguments... ] COMMANDS: method Command about appchain method did Command about appchain did register Register pier to bitxhub update update appchain in bitxhub activate activate appchain in bitxhub logout logout appchain in bitxhub get Get appchain info OPTIONS: --help, -h show help 具体描述 pier appchain 具体描述与使用示例参考 中继模式管理 。","text_tokens":["注册","--","appchain",":","command","操作",",","更新","help","-","信息","logout","info","链","示例","h","bitxhub","["," ","实现","register","get","]","commands","in","to","usage","描述","arguments","跨链","相关","具体","、","update","did","用于","about","。","用法","show","method","options","的","与","变更","中继","命令","activate","...","模式","，","网关","使用","向","等","参考","下","应用","管理","pier","name"],"title":"pier appchain","title_tokens":["pier","appchain"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-client","text":"pier client 命令用于直连模式的应用链管理。 用法 NAME: Pier client - Command about appchain in pier USAGE: Pier client command [ command options ] [ arguments... ] COMMANDS: register Register appchain in pier update Update appchain in pier audit Audit appchain in pier get Get appchain info rule register appchain validation rule OPTIONS: --help, -h show help 具体描述 pier appchain 具体描述与使用示例参考 直连模式管理 。","text_tokens":["--","appchain",":","command",",","audit","help","client","-","示例","info","链","h","["," ","register","get","]","commands","in","usage","描述","arguments","具体","update","直连","用于","about","。","用法","show","options","的","与","validation","命令","...","模式","使用","参考","应用","管理","rule","pier","name"],"title":"pier client","title_tokens":["pier","client"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-id","text":"pier id 命令用于获取所绑定的应用链地址。 用法 NAME: pier id - Get appchain id USAGE: pier id [arguments...] 具体描述 样例： $ pier --repo $HOME /.pier1 id # 控制台输出 0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb","text_tokens":["--","appchain",":","0xff8199fae48c808b45667da0ccaaee839b1a10cb","-","链","绑定"," ","[","id","get","pier1","]","usage","描述","arguments","控制","repo","具体","$",".","/","控制台","用于","。","用法","获取","#","的","输出","home","命令","样例","...","：","地址","应用","pier","name","所"],"title":"pier id","title_tokens":["pier","id"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-init","text":"pier init 命令用于初始化pier相关配置。如生成公私钥、ca证书等。 用法 NAME: Pier init - Initialize pier core local configuration USAGE: Pier init command [ command options ] [ arguments... ] COMMANDS: relay Initialize pier relay mode configuration direct Initialize pier direct mode configuration union Initialize pier union mode configuration OPTIONS: --http-port value Specify http port ( default: 44544 ) --pprof-port value Specify pprof port ( default: 44555 ) --enable-tls Enable TLS or not --tlsca value Specify TLS CA certificate path ( default: \"certs/ca.pem\" ) --common-name value Specify common name to verify ( default: \"localhost\" ) --ha value Specify if pier will run in single mode or high availability mode ( default: \"single\" ) --help, -h show help 具体描述 参数解释 --http-port ：可选参数，指定监听的http端口号，默认为44544。 --pprof-port ：可选参数，指定pprof的端口号，默认为44555. --enable-tls ：可选参数，是否进行TLS加密传输，默认为false。 --tlsca ：可选参数，TLS CA路径，默认为certs/ca.pem。 --common-name ：可选参数，指定ca证书的域名。默认为localhost。 --ha ：可选参数，选择网关是否高可用，高可用功能为商业版本，默认只有单个网关。","text_tokens":["口号","command","端口","为","[","钥","]","commands","如","to","usage","具体","relay","选择","(","specify","是否","verify","options","...","：","可用","tls","pem","商业","availability",":","生成","enable","证书","mode","certificate","加密","指定","描述","arguments","init","相关","port","or","if","/","localhost","监听","。","show","local","的","value","可","传输","default","端口号","解释","默认","参数","pier","name",",","\"","pprof","common","in","initialize","tlsca",")","进行","certs","高","选",".","single","union","run","will","direct","44544","命令","路径","configuration","单个","公私","core","等","功能","--","加密传输","help","-","配置","h","high"," ","not","ha","只有","、","用于","初始","用法","path","域名","http","版本","，","网关","false","ca","初始化","44555"],"title":"pier init","title_tokens":["pier","init"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-init-delay","text":"中继模式网关初始化，命令参数如下： NAME: Pier init relay - Initialize pier relay mode configuration USAGE: Pier init relay [ command options ] [ arguments... ] OPTIONS: --addrs value Specify bitxhub nodes ' address ( default: \"localhost:60011\" , \"localhost:60012\" , \"localhost:60013\" , \"localhost:60014\" ) --quorum value Specify the quorum number of BitXHub ( default: 2 ) --validators value Specify validators of bitxhub ( default: \"0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd\" , \"0xe93b92f1da08f925bdee44e91e7768380ae83307\" , \"0xb18c8575e3284e79b92100025a31378feb8100d6\" , \"0x856E2B9A5FA82FD1B031D1FF6863864DBAC7995D\" ) 具体描述 参数解释 --addrs ：可选参数，指定bixhub各节点地址及端口号。 --quorum ：可选参数，指定bixhub集群的quorum个数，与具体共识算法与节点规模相关。 --validators ：可选参数，指定bitxhub管理员节点地址。","text_tokens":["command","0xb18c8575e3284e79b92100025a31378feb8100d6","各","端口","[","]","usage","具体","relay","(","specify","0x856e2b9a5fa82fd1b031d1ff6863864dbac7995d","options","中继","...","模式","：","共识","address","0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd",":","mode","指定","描述","arguments","nodes","节点","init","相关","localhost","bixhub","及","。","的","与","'","value","the","可","default","端口号","解释","管理员","参数","pier","name","60012","of","60013",",","\"","规模","initialize","集群",")","如下","选","number","命令","configuration","0xe93b92f1da08f925bdee44e91e7768380ae83307","2","--","60014","validators","算法","-","bitxhub"," ","addrs","初始","quorum","60011","，","网关","地址","管理","初始化","个数","口号"],"title":"pier init delay","title_tokens":["pier","init","delay"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-init-direct","text":"直连模式网关初始化，命令参数如下： NAME: Pier init direct - Initialize pier direct mode configuration USAGE: Pier init direct [ command options ] [ arguments... ] OPTIONS: --peers value Specify counter party peers to connect 具体描述 参数解释 --peers ：必选参数，指定直连模式下pier的网络信息（包含自己）。 样例： 其中地址为pier启动时所在地址，端口号可任意指定可用端口， # 初始化pier1相关配置，配置文件目录为$HOME/.pier1 $ PID1 = $( pier --repo .pier1 p2p id ) $ PID2 = $( pier --repo .pier1 p2p id ) $ pier --repo .pier1 init direct --peers /ip4/127.0.0.1/tcp/3001/p2p/ $PID1 --peers /ip4/127.0.0.1/tcp/3002/p2p/ $PID2","text_tokens":["command","包含","信息","为","端口","[","id","]","to","usage","具体","$","直连","(","specify","options","...","模式","必选","：","可用","所在","）",":","pid2","0.1","mode","指定","描述","arguments","init","相关","=","/","connect","。","3001","可任意","#","的","启动","value","counter","解释","端口号","参数","pier","name","pid1","任意","pier1","3002","initialize","ip4",")","文件目录","repo","如下",".","文件","direct","home","命令","样例","configuration","tcp","下","party","--","其中","目录","-","配置"," ","网络","peers","初始","时","127.0","p2p","，","网关","（","自己","地址","初始化","口号"],"title":"pier init direct","title_tokens":["pier","init","direct"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-init-union","text":"大规模模式下的初始化配置，命令如下： NAME: Pier init union - Initialize pier union mode configuration USAGE: Pier init union [ command options ] [ arguments... ] OPTIONS: --addrs value Specify bitxhub nodes ' address ( default: \"localhost:60011\" , \"localhost:60012\" , \"localhost:60013\" , \"localhost:60014\" ) --connectors value Specify the remote union peers to connect 具体描述 参数解释 --addrs ：可选参数，指定bixhub各节点地址及端口号。 --connectors ：必选参数，指定大规模模式下pier的网络信息（包含自己）。 样例： 其中地址为pier启动时所在地址，端口号可任意指定可用端口， # 初始化pier1相关配置，配置文件目录为$HOME/.pier1 $ PID1 = $( pier --repo .pier1 p2p id ) $ PID2 = $( pier --repo .pier1 p2p id ) $ pier --repo .pier1 init union --peers /ip4/127.0.0.1/tcp/3001/p2p/ $PID1 --peers /ip4/127.0.0.1/tcp/3002/p2p/ $PID2","text_tokens":["command","各","信息","包含","端口","为","[","id","]","to","usage","具体","$","(","specify","options","...","模式","必选","：","可用","address","所在","）",":","pid2","0.1","mode","指定","remote","描述","arguments","nodes","节点","init","相关","=","localhost","connect","bixhub","/","及","。","3001","可任意","#","的","启动","'","value","the","可","default","端口号","解释","参数","pier","name","60012","60013","connectors",",","pid1","任意","\"","规模","pier1","3002","initialize","ip4",")","文件目录","repo","如下","选",".","文件","union","大规","home","命令","样例","configuration","tcp","下","--","60014","其中","大规模","目录","-","配置","bitxhub"," ","addrs","网络","peers","初始","时","127.0","p2p","60011","，","自己","（","地址","初始化","口号"],"title":"Pier init union","title_tokens":["pier","init","union"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-config","text":"pier config 命令用于配置应用链相关信息。 用法 NAME: Pier config - Initialize pier plugins configuration USAGE: Pier config command [ command options ] [ arguments... ] COMMANDS: fabric Initialize pier and fabric plugin configuration ethereum Initialize pier and ethereum plugin configuration OPTIONS: --redownload Re-download plugin or not --help, -h show help 具体描述 参数解释 --redownload ：可选参数，是否重新下载插件，默认为true。 子命令","text_tokens":["--",":","command",",","help","重新","-","信息","链","配置","为","h","["," ","true","]","commands","and","plugin","not","initialize","usage","fabric","描述","arguments","相关","or","具体","选","re","download","用于","redownload","。","用法","plugins","ethereum","show","是否","options","可","命令","config","...","下载","子","，","插件","configuration","解释","：","默认","参数","应用","pier","name"],"title":"pier config","title_tokens":["pier","config"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-config-fabric","text":"配置fabric插件相关配置信息，并下载 pier-client-fabric 二进制文件，命令描述如下： NAME: Pier config fabric - Initialize pier and fabric plugin configuration USAGE: Pier config fabric [ command options ] [ arguments... ] OPTIONS: --crypto-config value Specify the path to crypto-config directory --config value Specify the path to fabric config.yaml --event-filter value Specify the event filter on fabric chaincode --username value Specify the username to invoke fabric chaincode --ccid value Specify chaincode id to invoke --channel-id value Specify channel id --org value Specify the organization 参数解释 --crypto-config ：必选参数，指定fabric的文件目录，一般与repo目录一致。 --config ：可选参数，指定fabric的config.yaml文件目录，默认在$repo/fabric目录下。 --event-filter ：可选参数。根据eventname过滤所需要的event","text_tokens":["command","信息","[","id","]","plugin","to","usage","directory","$","specify","options","...","必选","event","：","ccid","一致","并","一般",":","在","指定","描述","arguments","相关","on","/","yaml","。","的","与","value","the","可","filter","解释","默认","参数","pier","name","所","organization","过滤","invoke","initialize","fabric","eventname","文件目录","repo","如下","选",".","文件","根据","命令","config","插件","configuration","下","--","crypto","二进制","目录","client","-","chaincode","配置"," ","and","username","org","进制","需要","path","channel","下载","，"],"title":"pier config fabric","title_tokens":["pier","fabric","config"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-interchain","text":"pier interchain 命令用于查询应用链的跨链交易信息。 用法 NAME: Pier interchain - Query interchain info USAGE: Pier interchain command [ command options ] [ arguments... ] COMMANDS: ibtp Query ibtp by id OPTIONS: --key value Specific key.json path --help, -h show help 具体描述 参数解释 --key ：必选参数指定pier的key.json文件。 子命令 USAGE: Pier interchain command [command options] [arguments...] COMMANDS: ibtp Query ibtp by id 样例： pier --repo $HOME /.pier1 interchain --key $HOME /.pier1/key.json ibtp --id 0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb-0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1-1 # 控制台输出 INFO [ 16 :52:41.917 ] Establish connection with bitxhub localhost:60013 successfully module = rpcx Tx hash: 0x82d3434e0a295B22A8e55884FEdd137d19e8cBDc32d5B593AD6D9AFB5cf59600 tx:<from:<RawAddress: [ 255 129 153 250 228 140 128 139 69 102 125 160 204 170 238 131 155 26 16 203 ] Address: \"\" > to:<RawAddress: [ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 ] Address: \"\" > timestamp:1638435054429909000 transaction_hash:<RawHash: [ 130 211 67 78 10 41 91 34 168 229 88 132 254 221 19 125 25 232 203 220 50 213 181 147 173 109 154 251 92 245 150 0 ] Hash: \"\" > IBTP:<from: \"0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb\" to: \"0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1\" index:1 timestamp:1638435054428680000 proof: \"k\\206\\262s\\3774\\374\\341\\235k\\200N\\377Z?WG\\255\\244\\352\\242/\\035I\\300\\036R\\335\\267\\207[K\" payload: \"\\022\\221\\001\\n*0x5bFe03Dbd09817d4957693f672cc31A133Bb6084\\022*0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f\\032\\020interchainCharge\\\"\\001A\\\"\\001B\\\"\\002102\\000:\\022interchainRollbackB\\001AB\\00210\" > nonce:4 signature: \"T)\\313\\333~\\316f\\372.\\010\\235\\234\\222J\\314@<\\202\\260\\243\\367b\\035\\016\\366\\326y\\3515\\020\\222\\256 $ \\010\\314\\035/\\271H\\217|~\\302\\233\\353b\\275\\267ir\\t\\242\\376\\224\\307q\\217l\\232\\037DP\\n\\317\\000\" extra: \"1\" > tx_meta:<block_hash: \"\\326{90^\\355a\\236\\342\\235i\\302\\374+\\352VI\\030\\242\\211\\335x\\371w\\221>(\\254%o\\212\\222\" block_height:14 >","text_tokens":["^","index","130","326","173","command","129","181","342","o","14","155","0xff8199fae48c808b45667da0ccaaee839b1a10cb","235","信息","3774","267ir","243","[","372","id","]","commands","160","t","to","229","usage","67","具体","$","307q","037dp","{","222j","224","establish","032","(","specific","json","with","25","16","132","options","275","输出","_","...","必选","001a","timestamp","signature","244","：","254","341","address","n","207","220","147",":","50","316f","022","376","313","234","020","367b","interchain","102","指定","255","238","002102","0","000","00210","描述","arguments","控制","from","rawhash","228","377z","=","/","控制台","localhost","242","217l","tx","352vi","233","payload","。","show","connection","#","的","131","154","value","交易","@","<","374","解释","rawaddress","参数","109","203","module","k","pier","query","name","0x82d3434e0a295b22a8e55884fedd137d19e8cbdc32d5b593ad6d9afb5cf59600","60013","250","78",",","200n",">","001","335","016","info","链","\"","1638435054428680000","153","10","256","pier1","41","34","rpcx","317","0x5bfe03dbd09817d4957693f672cc31a133bb6084","333","nonce","+","41.917",")","300","repo","height","128",".","文件","meta","267","92","查询","235i","212","hash","140","1638435054429909000","home","命令","wg","样例","91","子","0xa5dd12e27ee5e79ce0b50adb376414351c8eea5f","170","*","222","26","88","transaction","block","\\","211","3515","022interchainrollbackb","--","139","260","254%","52","206","010","030","020interchaincharge","help","-","251","036r","ibtp","h","bitxhub","19"," ","4","236","by","335x","213","314","366","235k","90","245","跨链","|","202","326y","217","302","用于","221","用法","0x23fb0e7ef676467563d37d820f1b1fddb0f9a2e1","path","key","125","proof","352","?","001ab","271h","extra","168","035","001b","262s","035i","~","371w","successfully","150","204","232","应用","355a","69","353b","1"],"title":"pier interchain","title_tokens":["pier","interchain"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-p2p","text":"pier p2p 命令用于直连模式下pier网络通信的pid。 用法 NAME: Pier p2p - Command about p2p USAGE: Pier p2p command [command options] [arguments...] COMMANDS: id get pier unique id in p2p network 具体描述 样例： # 初始化pier1相关配置，配置文件目录为$HOME/.pier1 $ pier --repo $HOME /.pier1 p2p id #控制台输出 QmNpQvh8Lm7gwt3sDqwJ1pgNn6taJLqdgtRVyZWhsD5bND","text_tokens":["pid","--",":","command","目录","-","配置","为","["," ","pier1","id","get","]","commands","qmnpqvh8lm7gwt3sdqwj1pgnn6tajlqdgtrvyzwhsd5bnd","in","usage","描述","arguments","通信","文件目录","repo","相关","具体","网络","$","控制",".","文件","直连","/","控制台","用于","网络通信","unique","初始","about","。","用法","network","#","options","的","输出","p2p","home","命令","样例","...","模式","，","：","下","初始化","pier","name"],"title":"pier p2p","title_tokens":["p2p","pier"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-rule","text":"pier rule 命令用于中继模式下pier向中继链部署应用链验证规则。 用法 NAME: Pier rule - Command about rule USAGE: Pier rule command [command options] [arguments...] COMMANDS: deploy Deploy validation rule update update master rule logout logout validation rule OPTIONS: --help, -h show help 具体描述 pier rule 具体描述与使用示例参考 直连模式管理 的部署验证规则模块。","text_tokens":["--",":","command",",","模块","规则","help","-","logout","示例","链","h","部署","["," ","deploy","]","commands","usage","描述","arguments","具体","update","直连","用于","about","。","用法","show","options","与","的","validation","中继","命令","...","模式","验证","master","使用","向","参考","下","应用","rule","管理","pier","name"],"title":"pier rule","title_tokens":["pier","rule"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-start","text":"pier start 命令用于启动pier。 用法 NAME: pier start - Start a long-running daemon process USAGE: pier start [arguments...] 具体描述 样例 ： $ pier --repo $HOME /.pier1 start # 控制台输出 Pier version: dev-release-1.6-1b5b79f App build date: 2021 -12-01T17:50:14 System version: darwin/amd64 Golang version: go1.15.13 INFO [ 17 :07:29.150 ] Establish connection with bitxhub localhost:60013 successfully module = app 2021 -12-02T17:07:29.171+0800 [ DEBUG ] plugin: starting plugin: path = /bin/sh args = \"[sh -c /Users/liruoxin/testRelay/release1.6/eth1/plugins/eth-client]\" 2021 -12-02T17:07:29.178+0800 [ DEBUG ] plugin: plugin started: path = /bin/sh pid = 74023 2021 -12-02T17:07:29.178+0800 [ DEBUG ] plugin: waiting for RPC address: path = /bin/sh 2021 -12-02T17:07:29.283+0800 [ DEBUG ] plugin.sh: 2021 -12-02T17:07:29.283+0800 [ DEBUG ] client: plugin address: network = unix address = /var/folders/xr/pnhf9j6n2k5_fysm6s0xkgt00000gn/T/plugin718241634 2021 -12-02T17:07:29.283+0800 [ DEBUG ] plugin: using plugin: version = 4 2021 -12-02T17:07:29.284+0800 [ TRACE ] plugin.stdio: waiting for stdio data 2021 -12-02T17:07:29.287+0800 [ DEBUG ] plugin.sh: 2021 -12-02T17:07:29.287+0800 [ INFO ] client: Basic appchain info: broker address = 0xFb23Af09e3E8D83fd5575De9558920Bf351F05E8 ethereum node ip = ws://127.0.0.1:8546 2021 -12-02T17:07:29.416+0800 [ DEBUG ] plugin.sh: 2021 -12-02T17:07:29.416+0800 [ INFO ] client: ContractABI: addr = 0x5bfe03dbd09817d4957693f672cc31a133bb6084 name = transfer.abi Client Type: ethereum Pprof on localhost:44555 …………","text_tokens":["using","broker","eth","abi","14","started","[","01t17","]","13","t","plugin","bin","usage","unix","1.6","07","29.283","具体","$","29.287","starting","amd64","stdio","data","debug","establish","plugin718241634","trace","with","xr","plugins","输出","version","_","...","type","：","address","2021",":","50","rpc","0.1","users","8546","sh","transfer","dev","描述","ws","arguments","控制","release1.6","=","on","/","控制台","localhost","29.284","0xfb23af09e3e8d83fd5575de9558920bf351f05e8","。","connection","ethereum","#","启动","contractabi","fysm6s0xkgt00000gn","system","74023","liruoxin","module","pier","ip","name","pid","c","60013","29.150","appchain","darwin","for","golang","info","\"","process","pier1","1b5b79f","02t17","0800","eth1","var","0x5bfe03dbd09817d4957693f672cc31a133bb6084","pprof","+","repo",".","build","29.171","waiting","testrelay","network","addr","node","app","home","命令","daemon","样例","basic","29.416","17","start","--","12","client","-","args","4","bitxhub"," ","用于","go1.15","release","29.178","running","用法","date","path","127.0","pnhf9j6n2k5","long","a","folders","successfully","…","44555"],"title":"pier start","title_tokens":["pier","start"," "]},{"location":"bitxhub/dev/cmd/pier_cmd/#pier-version","text":"pier version 命令用于查询版本号。 用法 NAME: pier version - Show version about ap USAGE: pier version [arguments...] 具体描述 样例 ： $ pier --repo $HOME /.pier1 version Pier version: dev-release-1.11-e1e7c14 App build date: 2021 -12-01T17:50:14 System version: darwin/amd64 Golang version: go1.15.13","text_tokens":["--",":","12","14","50","-","darwin","golang","["," ","pier1","dev","01t17","]","13","usage","描述","arguments","repo","具体","$","版本号",".","amd64","/","build","用于","查询","go1.15","about","。","ap","用法","show","release","date","e1e7c14","app","home","命令","version","样例","版本","...","：","1.11","system","pier","name","2021"],"title":"pier version","title_tokens":["pier","version"," "]},{"location":"bitxhub/dev/cmd/pier/pier_appchain/","text":"","text_tokens":[],"title":"Pier appchain","title_tokens":["pier","appchain"," "]},{"location":"bitxhub/dev/cmd/pier/pier_client/","text":"pier client 命令用于直连模式的应用链管理。 用法 $ pier client -h NAME: Pier client - Command about appchain in pier USAGE: Pier client command [ command options ] [ arguments... ] COMMANDS: register Register appchain in pier update Update appchain in pier audit Audit appchain in pier get Get appchain info rule register appchain validation rule OPTIONS: --help, -h show help 具体描述 pier client register $ pier client register -h NAME: Pier client register - Register appchain in pier USAGE: Pier client register [ command options ] [ arguments... ] OPTIONS: --pier_id value Specify target pier id --name value Specify appchain name --type value Specify appchain type --desc value Specify appchain description --version value Specify appchain version --validators value Specify appchain validators path --consensusType value Specify appchain consensus type idA=$(pier --repo ~/pier1 id) idB=$(pier --repo ~/pier2 id) pier --repo ~/pier1 client register --pier_id ${idB} --name fab --type fabric --desc simple --version 1 --validators ~/pier1/fabric/fabric.validators --consensusType raft pier --repo ~/pier2 client register --pier_id ${idA} --name eth --type ethereum --desc simple --version 1 --validators ~/pier2/ethereum/ether.validators --consensusType raft pier --repo ~/pier1 client rule --pier_id ${idB} --path ~/pier1/fabric/rule.wasm pier --repo ~/pier2 client rule --pier_id ${idA} --path ~/pier2/ethereum/rule.wasm","text_tokens":["command","eth","ether","[","register","get","id","]","commands","consensustype","}","usage","raft","具体","$","{","desc","直连","(","specify","options","validation","version","_","...","模式","type","rule",":","描述","arguments","update","=","/","simple","。","show","ethereum","的","description","value","wasm","idb","pier","name","appchain",",","audit","fab","info","链","pier1","in","fabric",")","repo",".","about","命令","--","validators","help","client","-","ida","h"," ","pier2","用于","用法","path","~","target","应用","管理","consensus","1"],"title":"Pier client","title_tokens":["pier","client"," "]},{"location":"bitxhub/dev/cmd/pier/pier_client/#_1","text":"$ pier client -h NAME: Pier client - Command about appchain in pier USAGE: Pier client command [ command options ] [ arguments... ] COMMANDS: register Register appchain in pier update Update appchain in pier audit Audit appchain in pier get Get appchain info rule register appchain validation rule OPTIONS: --help, -h show help","text_tokens":["--","appchain",":","command",",","audit","help","client","-","info","h","["," ","register","get","]","commands","in","usage","arguments","$","update","about","show","options","validation","...","rule","pier","name"],"title":"用法","title_tokens":["用法"]},{"location":"bitxhub/dev/cmd/pier/pier_client/#_2","text":"","text_tokens":[],"title":"具体描述","title_tokens":["具体","描述"]},{"location":"bitxhub/dev/cmd/pier/pier_client/#pier-client-register","text":"$ pier client register -h NAME: Pier client register - Register appchain in pier USAGE: Pier client register [ command options ] [ arguments... ] OPTIONS: --pier_id value Specify target pier id --name value Specify appchain name --type value Specify appchain type --desc value Specify appchain description --version value Specify appchain version --validators value Specify appchain validators path --consensusType value Specify appchain consensus type idA=$(pier --repo ~/pier1 id) idB=$(pier --repo ~/pier2 id) pier --repo ~/pier1 client register --pier_id ${idB} --name fab --type fabric --desc simple --version 1 --validators ~/pier1/fabric/fabric.validators --consensusType raft pier --repo ~/pier2 client register --pier_id ${idA} --name eth --type ethereum --desc simple --version 1 --validators ~/pier2/ethereum/ether.validators --consensusType raft pier --repo ~/pier1 client rule --pier_id ${idB} --path ~/pier1/fabric/rule.wasm pier --repo ~/pier2 client rule --pier_id ${idA} --path ~/pier2/ethereum/rule.wasm","text_tokens":["--","appchain",":","command","eth","validators","client","-","fab","ida","1","ether","h","["," ","pier1","register","id","]","in","consensustype","}","usage","fabric","raft",")","arguments","repo","pier2","$",".","=","desc","/","simple","(","specify","path","ethereum","options","description","value","version","_","...","wasm","type","~","idb","target","rule","pier","consensus","name","{"],"title":"pier client register","title_tokens":["register","pier","client"," "]},{"location":"bitxhub/function/cert_manage/","text":"证书管理 中继链节点具有完备的证书管理体系用于保证信息和数据的完整性和安全性。 证书配置 证书结构 中继链节点主要分三个层级的证书结构，分别是ca、agency和node，具体结构如下 . ├── agency.cert ├── ca.cert ├── node.cert ├── node.priv 0 directories, 7 files 证书生成方式 ca证书生成 # 生成ca相关的证书和私钥 bitxhub cert ca agency证书生成 # 根据ca颁布agency的证书 bitxhub cert priv gen --name = agency --target = ./ bitxhub cert csr --key = agency.priv --org = agency --target = ./ bitxhub cert issue --csr = agency.csr --is_ca = true --key = ca.priv --cert = ca.cert --target = ./ node证书生成 bitxhub cert priv gen --name = node --target = ./ bitxhub cert csr --key = node.priv --org = node --target = ./ bitxhub cert issue --csr = node.csr --is_ca = false --key = agency.priv --cert = agency.cert --target = ./ 节点私钥配置 节点私钥生成 bitxhub key gen --name = key --target = ./ 节点私钥格式转换 bitxhub key gen --passwd = bitxhub --target = ./ 说明：节点私钥会进行加密，如果密码不正确，中继链无法启动，目前默认的密码是bitxhub，如果采用其他密码，在启动中继链节点的过程中需要指定密码。以密码为hub为例，bitxhub启动命令为：bitxhub --repo ~/node1 start --passwd hub","text_tokens":["说明","信息","为","issue","其他","node1","true","不","cert","csr","如果","具体","层级","is","保证","目前","中继","完整","_","以","hub","：","是","priv","会","结构","生成","证书","在","├","加密","指定","0","节点","相关","=","/","。","#","directories","的","启动","体系","分别","passwd","默认","正确","name",",","gen","完备","链","files","方式","无法","进行","repo","如下","过程",".","根据","分","7","三个","node","颁布","命令","私钥","采用","中","管理体系","为例","--","start","安全","配置","─","bitxhub"," ","安全性","具有","格式","密码","和","org","主要","、","用于","需要","agency","key","转换","完整性","，","false","~","ca","target","管理","数据"],"title":"证书管理","title_tokens":["证书","管理"]},{"location":"bitxhub/function/cert_manage/#_1","text":"中继链节点具有完备的证书管理体系用于保证信息和数据的完整性和安全性。","text_tokens":["完备","证书","信息","安全","链","安全性","具有","节点","和","用于","。","保证","的","中继","完整性","完整","体系","管理","管理体系","数据"],"title":"证书管理","title_tokens":["证书","管理"]},{"location":"bitxhub/function/cert_manage/#_2","text":"","text_tokens":[],"title":"证书配置","title_tokens":["证书","配置"]},{"location":"bitxhub/function/cert_manage/#_3","text":"中继链节点主要分三个层级的证书结构，分别是ca、agency和node，具体结构如下 . ├── agency.cert ├── ca.cert ├── node.cert ├── node.priv 0 directories, 7 files","text_tokens":["结构",",","证书","链","├","─"," ","files","0","cert","节点","和","具体","层级","如下","主要","、",".","分","agency","7","三个","的","node","directories","中继","，","分别","是","ca","priv"],"title":"证书结构","title_tokens":["证书","结构"]},{"location":"bitxhub/function/cert_manage/#_4","text":"ca证书生成 # 生成ca相关的证书和私钥 bitxhub cert ca agency证书生成 # 根据ca颁布agency的证书 bitxhub cert priv gen --name = agency --target = ./ bitxhub cert csr --key = agency.priv --org = agency --target = ./ bitxhub cert issue --csr = agency.csr --is_ca = true --key = ca.priv --cert = ca.cert --target = ./ node证书生成 bitxhub cert priv gen --name = node --target = ./ bitxhub cert csr --key = node.priv --org = node --target = ./ bitxhub cert issue --csr = node.csr --is_ca = false --key = agency.priv --cert = agency.cert --target = ./","text_tokens":["priv","--","gen","生成","证书","bitxhub","issue"," ","true","cert","csr","和","相关","org",".","=","根据","is","/","agency","key","#","node","的","颁布","私钥","_","false","ca","target","name"],"title":"证书生成方式","title_tokens":["证书","生成","方式"]},{"location":"bitxhub/function/cert_manage/#_5","text":"","text_tokens":[],"title":"节点私钥配置","title_tokens":["节点","配置","私钥"]},{"location":"bitxhub/function/cert_manage/#_6","text":"bitxhub key gen --name = key --target = ./","text_tokens":["--","gen","key","target",".","=","name","bitxhub","/"," "],"title":"节点私钥生成","title_tokens":["节点","生成","私钥"]},{"location":"bitxhub/function/cert_manage/#_7","text":"bitxhub key gen --passwd = bitxhub --target = ./ 说明：节点私钥会进行加密，如果密码不正确，中继链无法启动，目前默认的密码是bitxhub，如果采用其他密码，在启动中继链节点的过程中需要指定密码。以密码为hub为例，bitxhub启动命令为：bitxhub --repo ~/node1 start --passwd hub","text_tokens":["会","--","为例","start","gen","说明","链","在","为","bitxhub","加密"," ","其他","指定","密码","node1","不","无法","节点","进行","如果","repo","过程",".","=","/","需要","。","key","目前","的","启动","中继","命令","私钥","以","hub","，","采用","passwd","~","默认","：","中","是","target","正确"],"title":"节点私钥格式转换","title_tokens":["节点","私钥","格式","转换"]},{"location":"bitxhub/function/cross_invoke/","text":"跨链合约调用 BitXHub跨链系统中，跨链合约有两个概念： 应用链上部署的跨链管理合约broker 中继链上用于处理跨链交易的内置合约 应用链上的跨链管理合约的调用可以参见 跨链合约 。本文主要讲解如何调用BitXHub内置的跨链合约。 合约接口 中继链的跨链合约提供了以下接口可以客户端调用： // HandleIBTP check the received IBTP and post event for router to handle func HandleIBTP ( ibtp * pb . IBTP ) * boltvm . Response // Interchain returns information of the interchain count, Receipt count and SourceReceipt count func Interchain () * boltvm . Response // GetInterchain returns information of the interchain count, Receipt count and SourceReceipt count by id func GetInterchain ( id string ) * boltvm . Response // GetIBTPByID get the transaction hash which contains the IBTP by IBTP id func GetIBTPByID ( id string ) * boltvm . Response 接口说明 HandleIBTP 当跨链网关捕获应用链抛出当跨链事件，并将其封装成IBTP以后，就需要向中继链发送交易调用该接口。 该接口主要作用是验证IBTP的来源链、目的链状态和IBTP index，更新来源链和目的链在中继链上的interchain数据，记录当前IBTP ID和当前交易HASH的对应关系，并抛出事件。 该接口接收的参数为IBTP。 Interchain 该接口用于获取发起交易的应用链的interchain数据，其中包含该应用链向其他各条应用链发起跨链的数量和收到的回执的数量，以及其他应用链向该应用链发起跨链的数量。 该接口不需要参数。 GetInterchain 该接口用于获取指定应用链的interchain数据，其中包含该应用链向其他各条应用链发起跨链的数量和收到的回执的数量，以及其他应用链向该应用链发起跨链的数量。 该接口接收的参数为应用链ID。 GetIBTPByID 该接口用于获取包含指定IBTP的交易的HASH。（该IBTP ID和交易HASH的对应关系在HandleIBTP时记录） 该接口接收的参数为IBTP ID。","text_tokens":["目的","broker","index","说明","包含","为","部署","其他","id","get","客户端","不","to","合约","处理","事件","(","receipt","中继","event","验证","contains","：","是","）","并","获取","将","post","getibtpbyid","在","interchain","指定","其","讲解","该","参见","回执","系统","链上","有","pb","捕获","/","成","状态","。","的","the","交易","information","对应","参数","func","of",",","接口","response","check","for","链","概念","调用","returns","内置","各条","received",")",".","getinterchain","以后","sourcereceipt","count","接收","当前","hash","提供","如何","封装","boltvm","数量","两个","*","发起","关系","中","transaction","链向","其中","更新","以及","handle","收到","ibtp","handleibtp","发送","string","bitxhub"," ","抛出","作用","by","and","router","客户","可以","which","和","跨链","记录","主要","、","用于","时","需要","当","本文","，","网关","（","向","来源","应用","管理","了","就","以下","数据"],"title":"跨链合约调用","title_tokens":["合约","调用","跨链"]},{"location":"bitxhub/function/cross_invoke/#_1","text":"BitXHub跨链系统中，跨链合约有两个概念： 应用链上部署的跨链管理合约broker 中继链上用于处理跨链交易的内置合约 应用链上的跨链管理合约的调用可以参见 跨链合约 。本文主要讲解如何调用BitXHub内置的跨链合约。","text_tokens":["broker","部署","bitxhub"," ","概念","调用","讲解","内置","合约","处理","可以","参见","跨链","系统","链上","有","主要","用于","。","的","本文","中继","如何","交易","两个","，","中","：","应用","管理"],"title":"跨链合约调用","title_tokens":["合约","调用","跨链"]},{"location":"bitxhub/function/cross_invoke/#_2","text":"中继链的跨链合约提供了以下接口可以客户端调用： // HandleIBTP check the received IBTP and post event for router to handle func HandleIBTP ( ibtp * pb . IBTP ) * boltvm . Response // Interchain returns information of the interchain count, Receipt count and SourceReceipt count func Interchain () * boltvm . Response // GetInterchain returns information of the interchain count, Receipt count and SourceReceipt count by id func GetInterchain ( id string ) * boltvm . Response // GetIBTPByID get the transaction hash which contains the IBTP by IBTP id func GetIBTPByID ( id string ) * boltvm . Response","text_tokens":["func","of",",","接口","response","post","check","handle","for","getibtpbyid","链","ibtp","handleibtp","interchain","string"," ","id","get","调用","客户端","and","by","returns","to","合约","router","客户","received",")","可以","which","跨链",".","pb","getinterchain","/","sourcereceipt","(","count","receipt","的","hash","中继","the","提供","boltvm","event","*","information","contains","：","transaction","了","以下"],"title":"合约接口","title_tokens":["接口","合约"]},{"location":"bitxhub/function/cross_invoke/#_3","text":"HandleIBTP 当跨链网关捕获应用链抛出当跨链事件，并将其封装成IBTP以后，就需要向中继链发送交易调用该接口。 该接口主要作用是验证IBTP的来源链、目的链状态和IBTP index，更新来源链和目的链在中继链上的interchain数据，记录当前IBTP ID和当前交易HASH的对应关系，并抛出事件。 该接口接收的参数为IBTP。 Interchain 该接口用于获取发起交易的应用链的interchain数据，其中包含该应用链向其他各条应用链发起跨链的数量和收到的回执的数量，以及其他应用链向该应用链发起跨链的数量。 该接口不需要参数。 GetInterchain 该接口用于获取指定应用链的interchain数据，其中包含该应用链向其他各条应用链发起跨链的数量和收到的回执的数量，以及其他应用链向该应用链发起跨链的数量。 该接口接收的参数为应用链ID。 GetIBTPByID 该接口用于获取包含指定IBTP的交易的HASH。（该IBTP ID和交易HASH的对应关系在HandleIBTP时记录） 该接口接收的参数为IBTP ID。","text_tokens":["目的","将","index","链向","其中","接口","更新","以及","收到","包含","getibtpbyid","链","在","ibtp","handleibtp","发送","为","抛出","interchain"," ","作用","id","其他","其","调用","不","指定","该","各条","并","记录","和","跨链","事件","链上","回执","主要","、","捕获","getinterchain","以后","成","用于","时","需要","状态","接收","当","。","当前","获取","的","hash","中继","交易","封装","数量","验证","，","发起","对应","网关","（","关系","向","是","参数","来源","应用","）","就","数据"],"title":"接口说明","title_tokens":["接口","说明"]},{"location":"bitxhub/function/direct_manager/","text":"直连模式下，网关pier支持对应用链的管理，包括注册、更新、审计应用链等功能。 注意：在进行应用链管理之前，请确保直连模式下跨链网关正常启动！！直连模式网关启动教程请参考 跨链网关直连模式部署 1. 应用链注册 pier client register 对于直连模式下需要加入跨链网络应用链，需要首先由应用链管理员向需要跨链的目的链网关pier注册应用链，命令如下： NAME: Pier client register - Register appchain in pier USAGE: Pier client register [ command options ] [ arguments... ] OPTIONS: --pier_id value Specify target pier id --name value Specify appchain name --type value Specify appchain type --desc value Specify appchain description --version value Specify appchain version --validators value Specify appchain validators path --consensusType value Specify appchain consensus type 参数解释： --repo ：可选参数，指定pier配置文件所在目录，如果不指定，默认使用$HOME/.pier目录。 --pier_id ：必选参数，指定要连接的目的网关地址，网关地址可通过 pier [--repo <coonect pier's repository>] id 获得。 --name ：必选参数，指定应用链名称。 --type ：必选参数，指定应用链类型，如hyperchain、fabric等。 --validators ：必选参数，指定应用链的验证人信息所在的文件路径。 --desc ：必选参数，对应用链的描述信息。 --consensusType ：必选参数，指定p应用链的共识类型，如pbft、raft等。 --version ：必选参数，指定应用链版本信息。 示例说明 比如pier1与pier2进行ethereum应用链的注册，命令执行如下： # 参数说明 pier [ --repo <repository> ] client register --pier_id <connect Appchain addr> --name <srcAppchain name> --type <appchain type> --validators <path of appchain validators file> --desc <description> --consensusType <appchain consensus type> --version <appchain version> # 具体样例 $ idA = $( pier --repo $HOME /.pier1 id ) $ idB = $( pier --repo $HOME /.pier2 id ) # pier1在pier2上注册 $ pier --repo $HOME /.pier2 client register --pier_id ${ idA } --name eth1 --type ethereum --validators $HOME /.pier1/ethereum/ether.validators --desc \"test register direct eth1\" --consensusType Pos --version 1 .0.0 # 控制台输出 appchain register successfully, appchain is 0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb # pier2在pier1上注册 $ pier --repo $HOME /.pier2 client register --pier_id ${ idA } --name eth2 --type ethereum --validators $HOME /.pier2/ethereum/ether.validators --desc \"test register direct eth2\" --consensusType Pos --version 1 .0.0 # 控制台输出 appchain register successfully, appchain is 0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1 可以看到应用链在双方网关注册成功。 2. 获取应用链信息 pier client get 获取指定的应用链在本地pier的注册信息，命令如下： $ pier [ --repo <repository> ] client get --pier_id <connect Appchain addr> --pier_id ：必选参数，注册在本地的应用链地址。 示例说明 比如在pier1往pier2成功注册后，在pier1执行如下命令： $ pier --repo $HOME /.pier2 client get --pier_id 0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb # 控制台输出 { \"id\" : \"0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb\" , \"name\" : \"eth1\" , \"validators\" : \"0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd,0xe93b92f1da08f925bdee44e91e7768380ae83307,0xb18c8575e3284e79b92100025a31378feb8100d6,0x856E2B9A5FA82FD1B031D1FF6863864DBAC7995D\" , \"consensus_type\" : \"Pos\" , \"status\" : \"available\" , \"chain_type\" : \"ethereum\" , \"desc\" : \"test register direct eth1\" , \"version\" : \"1.0.1\" , \"public_key\" : \"…………\" , \"fsm\" :null } 说明pier1所绑定的eth1在pier2注册成功。 3. 部署验证规则 pier client rule deploy 在注册完应用链后，还需要在网关部署验证规则，命令如下： NAME: Pier rule deploy - Deploy validation rule USAGE: Pier rule deploy [ command options ] [ arguments... ] OPTIONS: --path value Specific rule path --method value Specific did sub method name ( like appchain ) --admin-key value Specific admin key path --rule-url value Specific appchain rule url 参数解释： --repo ：可选参数，指定pier配置文件所在目录，如果不指定，默认使用$HOME/.pier目录。 --path ：必选参数，指定应用链的验证规则所在文件，一般为应用链插件配置文件下的 xxx.wasm 等。 --method ：必选参数，指定did名称。 --admin-key ：必选参数，指定admin的私钥地址。 --pier_id ：必选参数，指定验证规则的url。 示例说明 比如pier1与pier2进行ethereum应用链的注册，命令执行如下： # pier1往pier2部署验证规则 $ pier --repo $HOME /.pier1 client rule --pier_id ${ idB } --path $HOME /.pier1/ethereum/validating.wasm # pier2往pier1部署验证规则 $ pier --repo $HOME /.pier2 client rule --pier_id ${ idA } --path $HOME /.pier2/ethereum/validating.wasm 4. 更新应用链 pier client update 如果应用链发生了更改，比如验证人信息发生了变化，需要更新其在对面应用链的网关信息。参数说明如下： NAME: Pier client update - Update appchain in pier USAGE: Pier client update [ command options ] [ arguments... ] OPTIONS: --pier_id value Specify target pier id --name value Specify appchain name --type value Specify appchain type --desc value Specify appchain description --version value Specify appchain version --validators value Specify appchain validators path --consensusType value Specify appchain consensus type 该命令参数含义与应用链注册命令的参数一致，不再赘述。 示例说明 比如进行ethereum应用链的共识算法类型发生变化，需要更新应用链，命令执行如下： # 参数说明 $ pier [ --repo <repository> ] client update --pier_id <connect Appchain addr> --name <srcAppchain name> --type <appchain type> --validators <path of appchain validators file> --desc <description> --consensusType <appchain consensus type> --version <appchain version> # 具体样例 $ pier --repo $HOME /.pier2 client update --pier_id ${ idA } --name eth2 --type ethereum --validators eth2/ethereum/ether.validators --desc \"test register direct eth2\" --consensusType Pow --version 1 .0.2 # 控制台输出 appchain update successfully, appchain is <nil> 对面pier收到后进行更新应用链信息。 5. 审计应用链 pier client audit 注意 ：1.6.x版本此项非必须项，可不对其设置。 跨链网关对注册应用链信息进行审计，修改事务状态，参数说明如下： USAGE: Pier client audit [ command options ] [ arguments... ] OPTIONS: --id value Specific appchain id --isApproved value Specific approved signal --desc value Specific audit description 参数解释： --id ：必选参数，指定要连接的目的网关地址，网关地址可通过 pier [--repo <coonect pier's repository>] id 获得。 isApproved ：必选参数，是否通过注册。1为通过，0为不通过。 --desc ：必选参数，对应用链的描述信息。 示例说明 命令执行如下： # 参数说明 $ pier [ --repo <repository> ] client audit --id <connect Appchain addr> ----isApproved < 0 or 1 > --desc <description> # 具体样例 $ pier --repo $HOME /.pier1 client audit --id ${ idB } --isApproved 1 --desc \"test register direct eth2\" # 控制台输出 audit appchain 0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1 successfully pier1对pier2绑定的应用链注册提案审计通过。","text_tokens":["目的","command","说明","eth2","0xb18c8575e3284e79b92100025a31378feb8100d6","0xff8199fae48c808b45667da0ccaaee839b1a10cb","url","1.0","信息","示例","上","ether","为","sub","部署","[","deploy","请","register","id","get","不","]","比如","发生变化","如","consensustype","}","usage","raft","此项","1.6","如果","通过","具体","$","{","is","desc","直连","(","specific","validating","specify","coonect","0x856e2b9a5fa82fd1b031d1ff6863864dbac7995d","是否","options","名称","validation","输出","赘述","version","_","5","...","模式","必选","类型","type","验证","：","共识","rule","pos","所在","成功","获取","0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd","一致","isapproved","一般","可不","public",":","规则","发生","在","对于","pow","之前","指定","本地","其","0","配置文件","审计","描述","arguments","控制","加入","or","教程","=","注意","确保","s","/","repository","connect","控制台","update","did","对面","状态","项","网络应用","。","ethereum","#","后","的","description","启动","'","value","可","与","approved","！","wasm","<","双方","idb","事务","解释","默认","管理员","使用","参数","不再","pier","name","所","nil","of","available","appchain",",","audit",">","支持","链","\"","eth1","pier1","----","看到","in","fsm","fabric","signal",")","进行","repo","test","如下","status","选","生变",".","文件","null","0.2","pbft","包括","由","addr","0.0","连接","获得","变化","direct","home","命令","往","样例","首先","版本信息","like","私钥","提案","更改","路径","插件","0xe93b92f1da08f925bdee44e91e7768380ae83307","等","2","链后","下","admin","非","功能","设置","注册","--","srcappchain","更新","validators","要","算法","目录","client","-","收到","ida","对","配置","4","绑定"," ","hyperchain","3","chain","xxx","正常","可以","跨链","pier2","网络","还","、","完","执行","人","需要","必须","p","0x23fb0e7ef676467563d37d820f1b1fddb0f9a2e1","path","key","method","file","x","版本","，","修改","网关","successfully","向","地址","参考","target","含义","应用","管理","…","了","consensus","该","1"],"title":"直连模式管理","title_tokens":["模式","管理","直连"]},{"location":"bitxhub/function/direct_manager/#1","text":"","text_tokens":[],"title":"1. 应用链注册","title_tokens":["注册","应用","链",".","1"," "]},{"location":"bitxhub/function/direct_manager/#pier-client-register","text":"对于直连模式下需要加入跨链网络应用链，需要首先由应用链管理员向需要跨链的目的链网关pier注册应用链，命令如下： NAME: Pier client register - Register appchain in pier USAGE: Pier client register [ command options ] [ arguments... ] OPTIONS: --pier_id value Specify target pier id --name value Specify appchain name --type value Specify appchain type --desc value Specify appchain description --version value Specify appchain version --validators value Specify appchain validators path --consensusType value Specify appchain consensus type 参数解释： --repo ：可选参数，指定pier配置文件所在目录，如果不指定，默认使用$HOME/.pier目录。 --pier_id ：必选参数，指定要连接的目的网关地址，网关地址可通过 pier [--repo <coonect pier's repository>] id 获得。 --name ：必选参数，指定应用链名称。 --type ：必选参数，指定应用链类型，如hyperchain、fabric等。 --validators ：必选参数，指定应用链的验证人信息所在的文件路径。 --desc ：必选参数，对应用链的描述信息。 --consensusType ：必选参数，指定p应用链的共识类型，如pbft、raft等。 --version ：必选参数，指定应用链版本信息。","text_tokens":["目的","command","信息","[","register","id","不","]","如","consensustype","usage","raft","如果","通过","$","desc","直连","specify","coonect","options","名称","version","_","...","模式","必选","类型","type","验证","：","共识","所在",":","对于","指定","配置文件","描述","arguments","加入","s","/","repository","网络应用","。","的","description","'","value","可","<","解释","默认","管理员","使用","参数","pier","name","appchain",">","链","in","fabric","repo","如下","选",".","文件","pbft","由","连接","获得","home","命令","首先","版本信息","路径","等","下","注册","--","validators","要","目录","client","-","对","配置"," ","hyperchain","跨链","网络","、","人","需要","p","path","版本","，","网关","向","地址","target","应用","管理","consensus"],"title":"pier client register","title_tokens":["register","pier","client"," "]},{"location":"bitxhub/function/direct_manager/#_1","text":"比如pier1与pier2进行ethereum应用链的注册，命令执行如下： # 参数说明 pier [ --repo <repository> ] client register --pier_id <connect Appchain addr> --name <srcAppchain name> --type <appchain type> --validators <path of appchain validators file> --desc <description> --consensusType <appchain consensus type> --version <appchain version> # 具体样例 $ idA = $( pier --repo $HOME /.pier1 id ) $ idB = $( pier --repo $HOME /.pier2 id ) # pier1在pier2上注册 $ pier --repo $HOME /.pier2 client register --pier_id ${ idA } --name eth1 --type ethereum --validators $HOME /.pier1/ethereum/ether.validators --desc \"test register direct eth1\" --consensusType Pos --version 1 .0.0 # 控制台输出 appchain register successfully, appchain is 0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb # pier2在pier1上注册 $ pier --repo $HOME /.pier2 client register --pier_id ${ idA } --name eth2 --type ethereum --validators $HOME /.pier2/ethereum/ether.validators --desc \"test register direct eth2\" --consensusType Pos --version 1 .0.0 # 控制台输出 appchain register successfully, appchain is 0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1 可以看到应用链在双方网关注册成功。","text_tokens":["说明","eth2","0xff8199fae48c808b45667da0ccaaee839b1a10cb","上","ether","[","register","id","]","比如","consensustype","}","具体","$","{","is","desc","(","输出","version","_","type","：","pos","成功","在","控制","=","/","repository","connect","控制台","。","ethereum","#","与","的","description","<","双方","idb","参数","pier","name","of","appchain",",",">","链","\"","eth1","pier1","看到",")","进行","repo","test","如下",".","addr","0.0","direct","home","命令","样例","注册","--","srcappchain","validators","client","ida"," ","可以","pier2","执行","0x23fb0e7ef676467563d37d820f1b1fddb0f9a2e1","path","file","，","网关","successfully","应用","consensus","1"],"title":"示例说明","title_tokens":["说明","示例"]},{"location":"bitxhub/function/direct_manager/#2","text":"","text_tokens":[],"title":"2. 获取应用链信息","title_tokens":["2","信息","应用","链",".","获取"," "]},{"location":"bitxhub/function/direct_manager/#pier-client-get","text":"获取指定的应用链在本地pier的注册信息，命令如下： $ pier [ --repo <repository> ] client get --pier_id <connect Appchain addr> --pier_id ：必选参数，注册在本地的应用链地址。","text_tokens":["注册","--","appchain",">","client","信息","链","在","["," ","指定","本地","get","id","]","repo","如下","$","repository","connect","。","addr","的","命令","_","必选","<","，","：","地址","参数","应用","pier","获取"],"title":"pier client get","title_tokens":["pier","client","get"," "]},{"location":"bitxhub/function/direct_manager/#_2","text":"比如在pier1往pier2成功注册后，在pier1执行如下命令： $ pier --repo $HOME /.pier2 client get --pier_id 0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb # 控制台输出 { \"id\" : \"0xfF8199Fae48C808b45667DA0CcaAEe839B1a10Cb\" , \"name\" : \"eth1\" , \"validators\" : \"0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd,0xe93b92f1da08f925bdee44e91e7768380ae83307,0xb18c8575e3284e79b92100025a31378feb8100d6,0x856E2B9A5FA82FD1B031D1FF6863864DBAC7995D\" , \"consensus_type\" : \"Pos\" , \"status\" : \"available\" , \"chain_type\" : \"ethereum\" , \"desc\" : \"test register direct eth1\" , \"version\" : \"1.0.1\" , \"public_key\" : \"…………\" , \"fsm\" :null } 说明pier1所绑定的eth1在pier2注册成功。","text_tokens":["注册","--","available",":","public",",","所","说明","validators","0xb18c8575e3284e79b92100025a31378feb8100d6","0xff8199fae48c808b45667da0ccaaee839b1a10cb","client","pos","1.0","在","1","\"","绑定"," ","pier1","get","id","eth1","register","chain","比如","fsm","}","成功","控制","repo","status","pier2","如下","$","test",".","null","desc","/","控制台","执行","。","0x856e2b9a5fa82fd1b031d1ff6863864dbac7995d","ethereum","key","后","#","的","direct","输出","home","命令","往","_","version","type","，","：","0xe93b92f1da08f925bdee44e91e7768380ae83307","…","pier","consensus","name","0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd","{"],"title":"示例说明","title_tokens":["说明","示例"]},{"location":"bitxhub/function/direct_manager/#3","text":"","text_tokens":[],"title":"3. 部署验证规则","title_tokens":["3","验证","规则",".","部署"," "]},{"location":"bitxhub/function/direct_manager/#pier-client-rule-deploy","text":"在注册完应用链后，还需要在网关部署验证规则，命令如下： NAME: Pier rule deploy - Deploy validation rule USAGE: Pier rule deploy [ command options ] [ arguments... ] OPTIONS: --path value Specific rule path --method value Specific did sub method name ( like appchain ) --admin-key value Specific admin key path --rule-url value Specific appchain rule url 参数解释： --repo ：可选参数，指定pier配置文件所在目录，如果不指定，默认使用$HOME/.pier目录。 --path ：必选参数，指定应用链的验证规则所在文件，一般为应用链插件配置文件下的 xxx.wasm 等。 --method ：必选参数，指定did名称。 --admin-key ：必选参数，指定admin的私钥地址。 --pier_id ：必选参数，指定验证规则的url。","text_tokens":["command","url","为","sub","部署","deploy","[","id","不","]","usage","如果","$","(","specific","options","名称","validation","_","...","必选","验证","：","rule","所在","一般",":","规则","在","指定","配置文件","arguments","/","did","。","的","value","可","wasm","解释","默认","使用","参数","pier","name","appchain","链",")","repo","如下","选",".","文件","home","命令","like","私钥","插件","等","admin","链后","下","注册","--","目录","-","配置"," ","xxx","还","完","需要","path","key","method","，","网关","地址","应用"],"title":"pier client rule deploy","title_tokens":["client","rule","pier","deploy"," "]},{"location":"bitxhub/function/direct_manager/#_3","text":"比如pier1与pier2进行ethereum应用链的注册，命令执行如下： # pier1往pier2部署验证规则 $ pier --repo $HOME /.pier1 client rule --pier_id ${ idB } --path $HOME /.pier1/ethereum/validating.wasm # pier2往pier1部署验证规则 $ pier --repo $HOME /.pier2 client rule --pier_id ${ idA } --path $HOME /.pier2/ethereum/validating.wasm","text_tokens":["注册","--","规则","client","ida","链","部署"," ","pier1","id","比如","}","进行","repo","pier2","如下","$",".","/","执行","validating","ethereum","path","#","与","的","home","往","命令","_","wasm","验证","，","idb","：","应用","rule","pier","{"],"title":"示例说明","title_tokens":["说明","示例"]},{"location":"bitxhub/function/direct_manager/#4","text":"","text_tokens":[],"title":"4. 更新应用链","title_tokens":["更新","应用","链",".","4"," "]},{"location":"bitxhub/function/direct_manager/#pier-client-update","text":"如果应用链发生了更改，比如验证人信息发生了变化，需要更新其在对面应用链的网关信息。参数说明如下： NAME: Pier client update - Update appchain in pier USAGE: Pier client update [ command options ] [ arguments... ] OPTIONS: --pier_id value Specify target pier id --name value Specify appchain name --type value Specify appchain type --desc value Specify appchain description --version value Specify appchain version --validators value Specify appchain validators path --consensusType value Specify appchain consensus type 该命令参数含义与应用链注册命令的参数一致，不再赘述。","text_tokens":["--","注册","appchain",":","command","说明","更新","validators","发生","client","-","信息","链","在","["," ","id","其","]","比如","in","consensustype","usage","该","arguments","如果","如下","update","desc","对面","人","需要","。","specify","path","options","变化","的","description","与","value","命令","version","_","赘述","...","验证","，","更改","type","网关","：","含义","参数","target","一致","应用","了","不再","pier","consensus","name"],"title":"pier client update","title_tokens":["update","pier","client"," "]},{"location":"bitxhub/function/direct_manager/#_4","text":"比如进行ethereum应用链的共识算法类型发生变化，需要更新应用链，命令执行如下： # 参数说明 $ pier [ --repo <repository> ] client update --pier_id <connect Appchain addr> --name <srcAppchain name> --type <appchain type> --validators <path of appchain validators file> --desc <description> --consensusType <appchain consensus type> --version <appchain version> # 具体样例 $ pier --repo $HOME /.pier2 client update --pier_id ${ idA } --name eth2 --type ethereum --validators eth2/ethereum/ether.validators --desc \"test register direct eth2\" --consensusType Pow --version 1 .0.2 # 控制台输出 appchain update successfully, appchain is <nil> 对面pier收到后进行更新应用链信息。","text_tokens":["说明","eth2","信息","ether","[","id","register","]","比如","发生变化","consensustype","}","具体","$","{","is","desc","输出","version","_","类型","type","：","共识","发生","pow","控制","update","/","repository","connect","控制台","对面","。","ethereum","#","后","的","description","<","参数","pier","name","nil","of","appchain",",",">","链","\"","进行","repo","test","生变","如下","0.2",".","addr","变化","direct","home","命令","样例","--","srcappchain","更新","算法","validators","收到","client","ida"," ","pier2","执行","需要","path","file","，","successfully","应用","consensus","1"],"title":"示例说明","title_tokens":["说明","示例"]},{"location":"bitxhub/function/direct_manager/#5","text":"","text_tokens":[],"title":"5. 审计应用链","title_tokens":["审计","应用","链",".","5"," "]},{"location":"bitxhub/function/direct_manager/#pier-client-audit","text":"注意 ：1.6.x版本此项非必须项，可不对其设置。 跨链网关对注册应用链信息进行审计，修改事务状态，参数说明如下： USAGE: Pier client audit [ command options ] [ arguments... ] OPTIONS: --id value Specific appchain id --isApproved value Specific approved signal --desc value Specific audit description 参数解释： --id ：必选参数，指定要连接的目的网关地址，网关地址可通过 pier [--repo <coonect pier's repository>] id 获得。 isApproved ：必选参数，是否通过注册。1为通过，0为不通过。 --desc ：必选参数，对应用链的描述信息。","text_tokens":["可不","注册","--","appchain",":","command","目的","audit","说明",">","要","client","信息","对","链","为","["," ","指定","x","id","其","0","]","不","usage","审计","此项","arguments","1.6","进行","跨链","signal","如下","通过","repo",".","注意","desc","s","repository","specific","必须","状态","项","。","描述","是否","coonect","连接","获得","options","description","的","'","value","可","approved","版本","...","必选","<","，","修改","网关","事务","解释","：","地址","参数","应用","pier","非","isapproved","1","设置"],"title":"pier client audit","title_tokens":["pier","client","audit"," "]},{"location":"bitxhub/function/direct_manager/#_5","text":"命令执行如下： # 参数说明 $ pier [ --repo <repository> ] client audit --id <connect Appchain addr> ----isApproved < 0 or 1 > --desc <description> # 具体样例 $ pier --repo $HOME /.pier1 client audit --id ${ idB } --isApproved 1 --desc \"test register direct eth2\" # 控制台输出 audit appchain 0x23Fb0E7eF676467563d37D820F1b1Fddb0f9a2E1 successfully pier1对pier2绑定的应用链注册提案审计通过。","text_tokens":["--","注册","appchain","audit","说明",">","eth2","client","对","链","\"","["," ","----","id","pier1","register","0","]","绑定","}","审计","控制","test","repo","通过","如下","$","or","具体",".","{","desc","pier2","/","repository","connect","控制台","执行","。","addr","0x23fb0e7ef676467563d37d820f1b1fddb0f9a2e1","#","description","的","direct","输出","home","命令","样例","<","提案","idb","：","successfully","参数","应用","pier","isapproved","1"],"title":"示例说明","title_tokens":["说明","示例"]},{"location":"bitxhub/function/relay_manager/","text":"中继模式管理 中继链支持对应用链的管理，包括注册、更新、冻结、注销应用链等功能。 1. 应用链注册 pier appchain method register 对于需要加入跨链网络使用中继链进行跨链的应用链，需要首先由应用链管理员向中继链注册应用链，参数说明如下： NAME: Pier appchain method register - Register appchain did method and info to bitxhub USAGE: Pier appchain method register [ command options ] [ arguments... ] OPTIONS: --admin-key value Specific admin key path --method value Specific did sub method name ( like appchain ) --doc-addr value Specify the addr of did document --doc-hash value Specify the hash of did document --name value Specific appchain name --type value Specific appchain type --desc value Specific appchain description --version value Specific appchain version --validators value Specific appchain validators path --consensus value Specific appchain consensus type --rule value Specific appchain rule --rule-url value Specific appchain rule url --reason value Specify governance reason 参数解释： --repo ：可选参数，指定pier配置文件所在目录，如果不指定，默认使用$HOME/.pier目录。 --admin-key ：必选参数，管理员私钥地址，一般为admin.json。 --method ：必选参数，did方法名。 --doc-addr ：必选参数，指定did文件地址。 --doc-hash ：必选参数，指定did文件的哈希值。 --name ：必选参数，指定的应用了名称。 --type ：指定的应用链类型。如fabric、flato。 --desc ：必选参数，对应用链的描述信息。 --version ：必选参数，指定应用链版本信息。 --validators ：必选参数，指定应用链的验证人信息所在的文件路径。 --consensus ：必选参数，指定p应用链的共识类型，如rbft、raft等。 --rule ：必选参数，指定验证规则地址。 --rule_url ：指定验证规则url。 --addr ：可选参数，指定要连接的中继链节点地址，如果不指定，默认使用$repo目录下pier.toml中指定的BitXHub节点地址。 该命令向中继链发送一笔应用链注册的交易，中继链以交易的from（即当前pier公钥的地址）作为应用链的ID，生成一个应用链注册的提案。 中继链管理员需要对提案进行投票，命令如下： bitxhub [ --repo <repository> ] client governance vote --id <proposal id> --info <voting information> --reason <reason to vote> 参数解释： --repo ：可选参数，指定bitxhub节点配置文件所在目录，如果不指定，默认使用$HOME/.bitxhub目录。 --id ：必选参数，指定提案id。 --info ：必选参数，指定投票信息，approve或者reject。 --reason ：必选参数，指定投票的原因。 示例说明 比如进行fabric应用链的注册,现在 --doc-addr 和 --doc-hash 、--rule-url没有真正用到，使用下面示例的即可，验证规则需要提前注册（也可使用示例中内置验证规则地址）。验证者信息需要提前拷贝到repo目录下。注意在注册应用链时，确保已经正常启动中继链： # 具体样例 $ cd <bitxhub_project> && make install # 启动bitxhub $ make cluster # bitxhub管理员向pier管理员转账。注意更改为bitxhub项目地址 $ bitxhub client tx send --key ~/goproject/meshplus/bitxhub/scripts/build/node1/key.json --to 0xf2201f28368706EF75e3199b4f4DE2a24bA85CAe --amount 100000000000000000000000000 $ pier --repo $( pwd ) init relay # 可以使用对应插件项目下的验证者信息，注意更改项目路径 $ cp ~/goproject/meshplus/pier-client-fabric/config/fabric.validators ./fabric/ $ bitxhub client tx send --key ~/code/bitxhub/scripts/build/node1/key.json --to 0xf2201f28368706EF75e3199b4f4DE2a24bA85CAe --amount 100000000000000000000000000 $ pier --repo $( pwd ) appchain method register --admin-key ./key.json --method fabricappchain --doc-addr ./ipfs/QmQVxzUqN2Yv2UHUQXYwH8dSNkM8ReJ9qPqwJsf8zzoNUi --doc-hash QmQVxzUqN2Yv2UHUQXYwH8dSNkM8ReJ9qPqwJsf8zzoNUi --name fabricTest --type fabric --desc = \"test for fabric\" --version v1.0.3 --validators ./fabric/fabric.validators --consensus raft --rule 0x00000000000000000000000000000000000000a2 --rule-url http://localHost Register appchain method info for did:bitxhub:fabricappchain:. successfully, wait for proposal 0xCc9b389cEA6b1E2845a895829126B0a15a1cdA6F-0 to finish. 如上例所示，应用链管理员提交应用链注册请求，应用链DID为did:bitxhub:fabricappchain:.，提案号为0xCc9b389cEA6b1E2845a895829126B0a15a1cdA6F-0。中继链管理员需要对该提案进行审核并进行投票，命令如下： 如管理员对该提案审核后，认为该应用链提交对信息无误，投票通过，命令执行如下： $ PROPOSAL_ID = 上面得到的ID # 注意切换到bitxhub项目目录下 $ bitxhub --repo ./scripts/build/node1 client governance vote --id $PROPOSAL_ID --info approve --reason \"fabric appchain register\" vote successfully! $ bitxhub --repo ./scripts/build/node2 client governance vote --id $PROPOSAL_ID --info approve --reason \"fabric appchain register\" vote successfully! $ bitxhub --repo ./scripts/build/node3 client governance vote --id $PROPOSAL_ID --info approve --reason \"fabric appchain register\" vote successfully! $ bitxhub --repo ./scripts/build/node1 client governance proposal query --id $PROPOSAL_ID ======================================================================================== Id ManagedObjectId Type EventType Status A/R IE/AE/TE Special/Super CreateTime Description EndReason -- --------------- ---- --------- ------ --- -------- ------------- ---------- ----------- --------- 0xCc9b389cEA6b1E2845a895829126B0a15a1cdA6F-0 did:bitxhub:fabricappchain:. AppchainMgr register approve 3 /0 4 /4/3 false/true 1641348118114187000 end of normal voting ======================================================================================== * A/R：approve num / reject num * IE/AE/TE：the total number of electorate at the time of the initial proposal / the number of available electorate currently /the minimum threshold for votes to take effect * Special/Super：is special proposal / is super admin voted 可以看到该提案已经投票通过，应用链注册成功。 2. 更新应用链 pier appchain update 如果应用链发生了更改，比如验证人信息发生了变化，需要更新其在中继链上的应用链信息。参数说明如下： NAME: Pier appchain update - update appchain in bitxhub USAGE: Pier appchain update [ command options ] [ arguments... ] OPTIONS: --admin-key value Specific admin key path --id value Specify appchain id ( did ) --doc-addr value Specify appchain did doc addr --doc-hash value Specify appchain did doc hash --name value Specify appchain name --type value Specify appchain type --desc value Specify appchain description --version value Specify appchain version --validators value Specify appchain validators path --consensus-type value Specify appchain consensus type --reason value Specify governance reason 参数解释： --repo ：可选参数，指定pier配置文件所在目录，如果不指定，默认使用$HOME/.pier目录。 --admin-key ：必选参数，管理员私钥地址，一般为admin.json。 --id ：必选参数，应用链的did。 --doc-addr ：必选参数，指定did文件地址。 --doc-hash ：必选参数，指定did文件的哈希值。 --name ：必选参数，指定的应用了名称。 --type ：指定的应用链类型。如fabric、flato。 --desc ：必选参数，对应用链的描述信息。 --version ：必选参数，指定应用链版本信息。 --validators ：必选参数，指定应用链的验证人信息所在的文件路径。 --consensus-type ：必选参数，指定p应用链的共识类型，如rbft、raft等。 --reason ：可选参数，描述信息。 --addr ：可选参数，指定要连接的中继链节点地址，如果不指定，默认使用$repo目录下pier.toml中指定的BitXHub节点地址。 示例说明 比如进行fabric应用链的验证人信息发生变化，需要更新应用链，命令执行如下： # 具体样例 $ pier --repo $( pwd ) appchain update --admin-key ./key.json --id did:bitxhub:fabricappchain:. --doc-addr ./ipfs/QmQVxzUqN2Yv2UHUQXYwH8dSNkM8ReJ9qPqwJsf8zzoNUi --doc-hash QmQVxzUqN2Yv2UHUQXYwH8dSNkM8ReJ9qPqwJsf8zzoNUi --name fabricTest --type fabric --desc = \"test for fabric\" --version v1.1.0 --validators./fabric/fabric.validators --consensus-type raft the update request was submitted successfully，, proposal id is 0xCc9b389cEA6b1E2845a895829126B0a15a1cdA6F-1 管理员进行审核并投票，与注册应用链部分一致，不再赘述。 3. 激活应用链 pier appchain activate 如果冻结的应用链恢复正常，应用链管理员可以申请激活应用链。命令如下： $ pier --repo <repository> appchain activate --admin-key <admin_key_json> --id <appchian_did> 示例说明 比如对之前已经冻结的应用链进行激活，命令执行如下： $ pier --repo $( pwd ) appchain activate --admin-key ./key.json --id did:bitxhub:fabricappchain:. INFO [ 11 :01:25.884 ] Establish connection with bitxhub localhost:60011 successfully module = rpcx the activate request was submitted successfully, proposal id is 0xCc9b389cEA6b1E2845a895829126B0a15a1cdA6F-2 管理员进行审核并投票，与注册应用链部分一致，不再赘述。 5. 注销应用链 pier appchain logout 如果应用链退出跨链系统，不再进行跨链，应用链管理员可以向中继链提交注销应用链的提案。命令如下： pier --repo <repository> appchain logout --admin-key <admin_key_json> --id <appchian_did> 示例说明 比如对之前激活的应用链进行注销，命令执行如下： $ pier appchain logout --admin-key ./key.json --id did:bitxhub:fabricappchain:. the logout request was submitted successfully, proposal id is 0xCc9b389cEA6b1E2845a895829126B0a15a1cdA6F-3 管理员进行审核并投票，与注册应用链部分一致，不再赘述。 Pier appchain get 获取应用链注册后的相关信息。命令如下： pier --repo <repository> appchain get --admin-key <admin_key_json> --id <appchian_did> 示例说明 获取当前应用链相关信息，命令执行如下： # 具体样例 $ pier --repo $( pwd ) appchain get --admin-key ./key.json --id did:bitxhub:fabricappchain:. { \"id\" : \"did:bitxhub:fabricappchain:.\" , \"name\" : \"fabricTest1\" , \"validators\" : \"-----BEGIN CERTIFICATE-----\\nMIICKTCCAc+gAwIBAgIRAIBO31aZaSZoEYSy2AJuhJcwCgYIKoZIzj0EAwIwczEL\\nMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG\\ncmFuY2lzY28xGTAXBgNVBAoTEG9yZzIuZXhhbXBsZS5jb20xHDAaBgNVBAMTE2Nh\\nLm9yZzIuZXhhbXBsZS5jb20wHhcNMjAwMjA1MDgyMjAwWhcNMzAwMjAyMDgyMjAw\\nWjBqMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMN\\nU2FuIEZyYW5jaXNjbzENMAsGA1UECxMEcGVlcjEfMB0GA1UEAxMWcGVlcjEub3Jn\\nMi5leGFtcGxlLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABG3jszFPTbGm\\ndAYg2BxmHMTDKfQReNw3p9ttMK130qF5lQo5zLBG8Sa3viOCLnvjjg6A/P+yKnwv\\nisI/jEVE8T2jTTBLMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMCsGA1Ud\\nIwQkMCKAIMVL+daK7nMGr2/AQIXTSPFkdd3UiPVDkWtkh5ujnalEMAoGCCqGSM49\\nBAMCA0gAMEUCIQDMYOQiYeMiQZTxlRkj/3/jjYvwwdCcX5AWuFmraiHkugIgFkX/\\n6uiTSD0lz8P+wwlLf24cIABq2aZyi8q4gj0YfwA=\\n-----END CERTIFICATE-----\\n\" , \"consensus_type\" : \"raft\" , \"status\" : \"updating\" , \"chain_type\" : \"fabric\" , \"desc\" : \"test for fabric\" , \"version\" : \"v1.1.0\" , \"public_key\" : \"0x42444f30475a697746533934706e344169712b77365442417757663635787637724f616b4e786d536344465766394970546f694f7239712b6f6259386c514546617a434b316c714e32533446306b426e633542313034413d\" , \"owner_did\" : \"\" , \"did_doc_addr\" : \"./ipfs/QmQVxzUqN2Yv2UHUQXYwH8dSNkM8ReJ9qPqwJsf8zzoNUi\" , \"did_doc_hash\" : \"QmQVxzUqN2Yv2UHUQXYwH8dSNkM8ReJ9qPqwJsf8zzo111\" , \"fsm\" : {}}","text_tokens":["者","说明","url","信息","为","fabrictest1","get","node1","不","比如","如果","$","原因","如上例","中继","25.884","_","rule","并","一般","0xf2201f28368706ef75e3199b4f4de2a24ba85cae","wqeawihgdambgnvhrmbaf8eajaamcsga1ud","=","tx","现在","。","connection","启动","可","total","information","voted","解释","默认","rbft","或者","dak7nmgr2",",","finish","nwjbqmqswcqydvqqgewjvuzetmbega1uecbmkq2fsawzvcm5pytewmbqga1uebxmn","in","即可","test","拷贝到","number","like","插件","中","更","validators","client","-","qmqvxzuqn2yv2uhuqxywh8dsnkm8rej9qpqwjsf8zzonui","对","bitxhub"," ","投票","链时","3","01","和","100000000000000000000000000","执行","p","key","scripts","r","node2","注销","（","管理","&&","governance","拷贝","command","到","nmiicktccac","jeve8t2jttblma4ga1uddweb","[","register","raft","specific","请求","11","：","作为","成功","一致","一笔",":","冻结","规则","request","在","certificate","指定","votes","其","0","from","加入","系统","注意","后","的","与","没有","交易","对应","使用","管理员","---------","yknwv","end","query","name","available","initial","一个",">","for","info","flato","----","rpcx","document","内置","fsm","+","repo","哈希","认为","包括","由","num","连接","当前","命令","私钥","首先","config","提案","更改","路径","eventtype","nmi5legftcgxllmnvbtbzmbmgbyqgsm49agegccqgsm49aweha0iabg3jszfptbgm","owner","更新","0x42444f30475a697746533934706e344169712b77365442417757663635787637724f616b4e786d536344465766394970546f694f7239712b6f6259386c514546617a434b316c714e32533446306b426e633542313034413d","code","niwqkmckaimvl","配置","cd","updating","也","人","v1.0","method","方法","真正","项目","a","voting","v1.1","上面","ncmfuy2lzy28xgtaxbgnvbaoteg9yzziuzxhhbxbszs5jb20xhdaabgnvbamte2nh","向","地址","退出","consensus","----------","1","threshold","time","send","id","!","发生变化","如","cp","to","usage","具体","cluster","relay","is","desc","json","with","specify","转账","名称","赘述","version","必选","类型","验证","0xcc9b389cea6b1e2845a895829126b0a15a1cda6f","共识","所在","）","获取","public","即","appchainmgr","发生","logout","对于","之前","minimum","描述","arguments","init","链上","reason","如上","/","repository","#","value","the","下面","上例","激活","module","vote","pier","用到","nbamca0gameuciqdmyoqiyemiqztxlrkj","of","appchain","已经","支持","链","\"","nlm9yzziuzxhhbxbszs5jb20whhcnmjawmja1mdgymjawwhcnmzawmjaymdgymjaw","看到","aqixtspfkdd3uipvdkwtkh5ujnalemaogccqgsm49","-----","managedobjectid",")","status","生变","文件","---","doc","ae","ipfs","goproject","恢复","wwllf24ciabq2azyi8q4gj0yfwa","hash","n6uitsd0lz8p","home","版本信息","无误","toml","normal","等","admin","功能","注册","--","-----------","appchian","要","部分","值","1641348118114187000","发送","链以","4","公钥","and","chain","ndayg2bxmhmtdkfqrenw3p9ttmk130qf5lqo5zlbg8sa3vioclnvjjg6a","可以","special","0x00000000000000000000000000000000000000a2","切换","需要","createtime","~","得到","false","successfully","应用","currently","示例","号","sub","true","]","begin","}","申请","通过","establish","(","node3","ie","options","jjyvwwdccx5awufmraihkugigfkx","endreason","qmqvxzuqn2yv2uhuqxywh8dsnkm8rej9qpqwjsf8zzo111","activate","5","...","模式","所示","type","at","proposal","n","nisi","生成","reject","nu2fuiezyyw5jaxnjbzenmasga1uecxmecgvlcjefmb0ga1ueaxmwcgvlcjeub3jn","配置文件","节点","相关","update","确保","localhost","did","description","was","提交","<","--------","恢复正常","参数","不再","make","wait","名","---------------","审核","electorate","------","super","fabric","提前","进行","如下","选",".","pwd","build","nmakga1uebhmcvvmxezarbgnvbagtcknhbglmb3juawexfjaubgnvbactdvnhbibg","addr","变化","amount","样例","project","*","-------------","2","\\","下","改为","submitted","目录","fabricappchain","meshplus","te","approve","正常","跨链","网络","、","install","gawibagiraibo31azaszoeysy2ajuhjcwcgyikozizj0eawiwczel","path","60011","http","版本","，","effect","take","了","该","{","fabrictest"],"title":"中继模式管理","title_tokens":["模式","管理","中继"]},{"location":"bitxhub/function/relay_manager/#_1","text":"中继链支持对应用链的管理，包括注册、更新、冻结、注销应用链等功能。","text_tokens":["注册","，","包括","注销","。","更新","冻结","支持","等","的","应用","管理","对","链","中继","、","功能"],"title":"中继模式管理","title_tokens":["模式","管理","中继"]},{"location":"bitxhub/function/relay_manager/#1","text":"","text_tokens":[],"title":"1. 应用链注册","title_tokens":["注册","应用","链",".","1"," "]},{"location":"bitxhub/function/relay_manager/#pier-appchain-method-register","text":"对于需要加入跨链网络使用中继链进行跨链的应用链，需要首先由应用链管理员向中继链注册应用链，参数说明如下： NAME: Pier appchain method register - Register appchain did method and info to bitxhub USAGE: Pier appchain method register [ command options ] [ arguments... ] OPTIONS: --admin-key value Specific admin key path --method value Specific did sub method name ( like appchain ) --doc-addr value Specify the addr of did document --doc-hash value Specify the hash of did document --name value Specific appchain name --type value Specific appchain type --desc value Specific appchain description --version value Specific appchain version --validators value Specific appchain validators path --consensus value Specific appchain consensus type --rule value Specific appchain rule --rule-url value Specific appchain rule url --reason value Specify governance reason 参数解释： --repo ：可选参数，指定pier配置文件所在目录，如果不指定，默认使用$HOME/.pier目录。 --admin-key ：必选参数，管理员私钥地址，一般为admin.json。 --method ：必选参数，did方法名。 --doc-addr ：必选参数，指定did文件地址。 --doc-hash ：必选参数，指定did文件的哈希值。 --name ：必选参数，指定的应用了名称。 --type ：指定的应用链类型。如fabric、flato。 --desc ：必选参数，对应用链的描述信息。 --version ：必选参数，指定应用链版本信息。 --validators ：必选参数，指定应用链的验证人信息所在的文件路径。 --consensus ：必选参数，指定p应用链的共识类型，如rbft、raft等。 --rule ：必选参数，指定验证规则地址。 --rule_url ：指定验证规则url。 --addr ：可选参数，指定要连接的中继链节点地址，如果不指定，默认使用$repo目录下pier.toml中指定的BitXHub节点地址。 该命令向中继链发送一笔应用链注册的交易，中继链以交易的from（即当前pier公钥的地址）作为应用链的ID，生成一个应用链注册的提案。 中继链管理员需要对提案进行投票，命令如下： bitxhub [ --repo <repository> ] client governance vote --id <proposal id> --info <voting information> --reason <reason to vote> 参数解释： --repo ：可选参数，指定bitxhub节点配置文件所在目录，如果不指定，默认使用$HOME/.bitxhub目录。 --id ：必选参数，指定提案id。 --info ：必选参数，指定投票信息，approve或者reject。 --reason ：必选参数，指定投票的原因。","text_tokens":["governance","command","说明","url","信息","为","sub","[","register","id","不","]","如","to","usage","raft","如果","$","desc","(","specific","json","原因","specify","options","名称","中继","version","_","...","必选","类型","type","验证","：","作为","proposal","rule","共识","所在","）","一笔","一般",":","即","生成","规则","reject","对于","指定","配置文件","描述","arguments","节点","from","加入","reason","/","repository","did","。","的","description","value","the","可","交易","<","information","解释","使用","管理员","默认","rbft","参数","或者","vote","pier","name","of","appchain","一个",">","名","info","链","flato","document","fabric",")","进行","repo","哈希","如下","选",".","文件","doc","由","addr","连接","当前","hash","home","like","命令","私钥","首先","版本信息","提案","toml","路径","中","等","admin","下","注册","--","validators","要","目录","client","-","值","对","发送","配置","链以","bitxhub"," ","投票","公钥","and","approve","跨链","网络","、","人","需要","p","path","key","method","方法","voting","版本","，","（","向","地址","应用","管理","了","consensus","该"],"title":"pier appchain method register","title_tokens":["register","appchain","method","pier"," "]},{"location":"bitxhub/function/relay_manager/#_2","text":"比如进行fabric应用链的注册,现在 --doc-addr 和 --doc-hash 、--rule-url没有真正用到，使用下面示例的即可，验证规则需要提前注册（也可使用示例中内置验证规则地址）。验证者信息需要提前拷贝到repo目录下。注意在注册应用链时，确保已经正常启动中继链： # 具体样例 $ cd <bitxhub_project> && make install # 启动bitxhub $ make cluster # bitxhub管理员向pier管理员转账。注意更改为bitxhub项目地址 $ bitxhub client tx send --key ~/goproject/meshplus/bitxhub/scripts/build/node1/key.json --to 0xf2201f28368706EF75e3199b4f4DE2a24bA85CAe --amount 100000000000000000000000000 $ pier --repo $( pwd ) init relay # 可以使用对应插件项目下的验证者信息，注意更改项目路径 $ cp ~/goproject/meshplus/pier-client-fabric/config/fabric.validators ./fabric/ $ bitxhub client tx send --key ~/code/bitxhub/scripts/build/node1/key.json --to 0xf2201f28368706EF75e3199b4f4DE2a24bA85CAe --amount 100000000000000000000000000 $ pier --repo $( pwd ) appchain method register --admin-key ./key.json --method fabricappchain --doc-addr ./ipfs/QmQVxzUqN2Yv2UHUQXYwH8dSNkM8ReJ9qPqwJsf8zzoNUi --doc-hash QmQVxzUqN2Yv2UHUQXYwH8dSNkM8ReJ9qPqwJsf8zzoNUi --name fabricTest --type fabric --desc = \"test for fabric\" --version v1.0.3 --validators ./fabric/fabric.validators --consensus raft --rule 0x00000000000000000000000000000000000000a2 --rule-url http://localHost Register appchain method info for did:bitxhub:fabricappchain:. successfully, wait for proposal 0xCc9b389cEA6b1E2845a895829126B0a15a1cdA6F-0 to finish. 如上例所示，应用链管理员提交应用链注册请求，应用链DID为did:bitxhub:fabricappchain:.，提案号为0xCc9b389cEA6b1E2845a895829126B0a15a1cdA6F-0。中继链管理员需要对该提案进行审核并进行投票，命令如下： 如管理员对该提案审核后，认为该应用链提交对信息无误，投票通过，命令执行如下： $ PROPOSAL_ID = 上面得到的ID # 注意切换到bitxhub项目目录下 $ bitxhub --repo ./scripts/build/node1 client governance vote --id $PROPOSAL_ID --info approve --reason \"fabric appchain register\" vote successfully! $ bitxhub --repo ./scripts/build/node2 client governance vote --id $PROPOSAL_ID --info approve --reason \"fabric appchain register\" vote successfully! $ bitxhub --repo ./scripts/build/node3 client governance vote --id $PROPOSAL_ID --info approve --reason \"fabric appchain register\" vote successfully! $ bitxhub --repo ./scripts/build/node1 client governance proposal query --id $PROPOSAL_ID ======================================================================================== Id ManagedObjectId Type EventType Status A/R IE/AE/TE Special/Super CreateTime Description EndReason -- --------------- ---- --------- ------ --- -------- ------------- ---------- ----------- --------- 0xCc9b389cEA6b1E2845a895829126B0a15a1cdA6F-0 did:bitxhub:fabricappchain:. AppchainMgr register approve 3 /0 4 /4/3 false/true 1641348118114187000 end of normal voting ======================================================================================== * A/R：approve num / reject num * IE/AE/TE：the total number of electorate at the time of the initial proposal / the number of available electorate currently /the minimum threshold for votes to take effect * Special/Super：is special proposal / is super admin voted 可以看到该提案已经投票通过，应用链注册成功。","text_tokens":["governance","者","拷贝","threshold","time","url","示例","信息","send","到","号","为","register","node1","id","true","!","比如","cp","如","to","raft","通过","具体","$","cluster","relay","is","desc","(","json","如上例","请求","node3","----------","转账","ie","endreason","中继","version","_","所示","验证","type","at","0xcc9b389cea6b1e2845a895829126b0a15a1cda6f","：","proposal","rule","成功","）","并",":","规则","appchainmgr","reject","在","0xf2201f28368706ef75e3199b4f4de2a24ba85cae","votes","0","minimum","init","reason","=","注意","确保","如上","/","localhost","tx","did","现在","。","#","后","的","description","没有","启动","可","the","total","提交","下面","<","上例","对应","--------","voted","使用","管理员","---------","end","vote","pier","用到","query","name","make","of","appchain","available","wait",",","已经","initial",">","for","---------------","info","链","审核","\"","electorate","----","finish","------","super","看到","内置","managedobjectid","fabric","提前",")","即可","进行","repo","test","如下","status",".","pwd","build","---","doc","认为","ae","ipfs","num","addr","goproject","拷贝到","hash","number","amount","命令","样例","project","config","提案","无误","*","更改","插件","路径","normal","-------------","中","admin","下","eventtype","注册","--","改为","-----------","更","validators","目录","client","-","qmqvxzuqn2yv2uhuqxywh8dsnkm8rej9qpqwjsf8zzonui","code","对","1641348118114187000","fabricappchain","4","bitxhub","meshplus"," ","投票","链时","3","te","approve","cd","正常","可以","和","、","100000000000000000000000000","special","执行","也","0x00000000000000000000000000000000000000a2","install","需要","切换","key","scripts","method","v1.0","真正","createtime","项目","a","http","r","voting","上面","，","node2","effect","（","~","得到","false","currently","successfully","向","地址","take","应用","管理","&&","consensus","该","fabrictest"],"title":"示例说明","title_tokens":["说明","示例"]},{"location":"bitxhub/function/relay_manager/#2","text":"","text_tokens":[],"title":"2. 更新应用链","title_tokens":["更新","2","应用","链","."," "]},{"location":"bitxhub/function/relay_manager/#pier-appchain-update","text":"如果应用链发生了更改，比如验证人信息发生了变化，需要更新其在中继链上的应用链信息。参数说明如下： NAME: Pier appchain update - update appchain in bitxhub USAGE: Pier appchain update [ command options ] [ arguments... ] OPTIONS: --admin-key value Specific admin key path --id value Specify appchain id ( did ) --doc-addr value Specify appchain did doc addr --doc-hash value Specify appchain did doc hash --name value Specify appchain name --type value Specify appchain type --desc value Specify appchain description --version value Specify appchain version --validators value Specify appchain validators path --consensus-type value Specify appchain consensus type --reason value Specify governance reason 参数解释： --repo ：可选参数，指定pier配置文件所在目录，如果不指定，默认使用$HOME/.pier目录。 --admin-key ：必选参数，管理员私钥地址，一般为admin.json。 --id ：必选参数，应用链的did。 --doc-addr ：必选参数，指定did文件地址。 --doc-hash ：必选参数，指定did文件的哈希值。 --name ：必选参数，指定的应用了名称。 --type ：指定的应用链类型。如fabric、flato。 --desc ：必选参数，对应用链的描述信息。 --version ：必选参数，指定应用链版本信息。 --validators ：必选参数，指定应用链的验证人信息所在的文件路径。 --consensus-type ：必选参数，指定p应用链的共识类型，如rbft、raft等。 --reason ：可选参数，描述信息。 --addr ：可选参数，指定要连接的中继链节点地址，如果不指定，默认使用$repo目录下pier.toml中指定的BitXHub节点地址。","text_tokens":["governance","command","说明","信息","为","[","id","不","]","比如","如","usage","raft","如果","$","desc","(","specific","json","specify","options","名称","中继","version","...","必选","类型","验证","type","：","共识","所在","一般",":","发生","在","指定","其","配置文件","描述","arguments","节点","链上","reason","update","/","did","。","的","description","value","可","解释","默认","使用","管理员","rbft","参数","pier","name","appchain","链","flato","in","fabric",")","repo","哈希","如下","选",".","文件","doc","addr","连接","变化","hash","home","私钥","版本信息","更改","toml","路径","中","等","admin","下","--","更新","validators","要","目录","-","值","对","配置","bitxhub"," ","、","人","需要","p","path","key","版本","，","地址","应用","了","管理","consensus"],"title":"pier appchain update","title_tokens":["pier","update","appchain"," "]},{"location":"bitxhub/function/relay_manager/#_3","text":"比如进行fabric应用链的验证人信息发生变化，需要更新应用链，命令执行如下： # 具体样例 $ pier --repo $( pwd ) appchain update --admin-key ./key.json --id did:bitxhub:fabricappchain:. --doc-addr ./ipfs/QmQVxzUqN2Yv2UHUQXYwH8dSNkM8ReJ9qPqwJsf8zzoNUi --doc-hash QmQVxzUqN2Yv2UHUQXYwH8dSNkM8ReJ9qPqwJsf8zzoNUi --name fabricTest --type fabric --desc = \"test for fabric\" --version v1.1.0 --validators./fabric/fabric.validators --consensus-type raft the update request was submitted successfully，, proposal id is 0xCc9b389cEA6b1E2845a895829126B0a15a1cdA6F-1 管理员进行审核并投票，与注册应用链部分一致，不再赘述。","text_tokens":["信息","id","比如","发生变化","raft","具体","$","is","desc","(","json","赘述","version","验证","type","0xcc9b389cea6b1e2845a895829126b0a15a1cda6f","：","proposal","一致","并",":","发生","request","0","update","=","/","did","。","#","的","与","the","was","管理员","不再","pier","name","appchain",",","for","链","审核","\"","fabric",")","进行","repo","test","生变","如下",".","pwd","doc","ipfs","addr","变化","hash","命令","样例","admin","--","注册","更新","validators","submitted","部分","qmqvxzuqn2yv2uhuqxywh8dsnkm8rej9qpqwjsf8zzonui","-","fabricappchain","bitxhub"," ","投票","执行","人","需要","key","v1.1","，","successfully","应用","管理","consensus","1","fabrictest"],"title":"示例说明","title_tokens":["说明","示例"]},{"location":"bitxhub/function/relay_manager/#3","text":"","text_tokens":[],"title":"3. 激活应用链","title_tokens":["3","激活","应用","链","."," "]},{"location":"bitxhub/function/relay_manager/#pier-appchain-activate","text":"如果冻结的应用链恢复正常，应用链管理员可以申请激活应用链。命令如下： $ pier --repo <repository> appchain activate --admin-key <admin_key_json> --id <appchian_did>","text_tokens":["--","appchain","appchian",">","冻结","-","链"," ","id","正常","可以","申请","如果","repo","如下","$","repository","did","json","。","恢复","key","的","命令","activate","_","<","，","恢复正常","激活","：","管理员","admin","应用","管理","pier"],"title":"pier appchain activate","title_tokens":["pier","appchain","activate"," "]},{"location":"bitxhub/function/relay_manager/#_4","text":"比如对之前已经冻结的应用链进行激活，命令执行如下： $ pier --repo $( pwd ) appchain activate --admin-key ./key.json --id did:bitxhub:fabricappchain:. INFO [ 11 :01:25.884 ] Establish connection with bitxhub localhost:60011 successfully module = rpcx the activate request was submitted successfully, proposal id is 0xCc9b389cEA6b1E2845a895829126B0a15a1cdA6F-2 管理员进行审核并投票，与注册应用链部分一致，不再赘述。","text_tokens":["--","注册","appchain",":",",","已经","不再","冻结","submitted","部分","-","request","info","对","链","审核","fabricappchain","之前","bitxhub","["," ","id","投票","rpcx","]","比如","01",")","进行","repo","如下","$",".","=","is","pwd","/","establish","localhost","执行","(","json","did","with","。","connection","key","的","与","the","was","25.884","命令","60011","activate","11","赘述","，","0xcc9b389cea6b1e2845a895829126b0a15a1cda6f","激活","：","successfully","管理员","一致","admin","proposal","应用","2","module","管理","pier","并"],"title":"示例说明","title_tokens":["说明","示例"]},{"location":"bitxhub/function/relay_manager/#5","text":"","text_tokens":[],"title":"5. 注销应用链","title_tokens":["注销","应用","链",".","5"," "]},{"location":"bitxhub/function/relay_manager/#pier-appchain-logout","text":"如果应用链退出跨链系统，不再进行跨链，应用链管理员可以向中继链提交注销应用链的提案。命令如下： pier --repo <repository> appchain logout --admin-key <admin_key_json> --id <appchian_did>","text_tokens":["--","appchain","appchian",">","logout","-","链"," ","id","可以","如果","跨链","进行","系统","如下","repo","repository","did","json","。","key","的","中继","提交","命令","_","提案","<","，","注销","：","管理员","向","退出","admin","应用","管理","不再","pier"],"title":"pier appchain logout","title_tokens":["pier","logout","appchain"," "]},{"location":"bitxhub/function/relay_manager/#_5","text":"比如对之前激活的应用链进行注销，命令执行如下： $ pier appchain logout --admin-key ./key.json --id did:bitxhub:fabricappchain:. the logout request was submitted successfully, proposal id is 0xCc9b389cEA6b1E2845a895829126B0a15a1cdA6F-3 管理员进行审核并投票，与注册应用链部分一致，不再赘述。","text_tokens":["--","注册","appchain",":",",","submitted","部分","logout","-","request","对","链","审核","fabricappchain","之前","bitxhub"," ","id","投票","3","比如","进行","如下","$",".","is","/","执行","did","json","。","key","的","与","the","was","命令","赘述","，","注销","0xcc9b389cea6b1e2845a895829126b0a15a1cda6f","激活","：","successfully","管理员","一致","admin","proposal","应用","管理","不再","pier","并"],"title":"示例说明","title_tokens":["说明","示例"]},{"location":"bitxhub/function/relay_manager/#pier-appchain-get","text":"获取应用链注册后的相关信息。命令如下： pier --repo <repository> appchain get --admin-key <admin_key_json> --id <appchian_did>","text_tokens":["注册","--","appchain","appchian",">","-","信息","链"," ","get","id","repo","相关","如下","repository","did","json","。","key","后","的","命令","_","<","：","admin","应用","pier","获取"],"title":"Pier appchain get","title_tokens":["pier","get","appchain"," "]},{"location":"bitxhub/function/relay_manager/#_6","text":"获取当前应用链相关信息，命令执行如下： # 具体样例 $ pier --repo $( pwd ) appchain get --admin-key ./key.json --id did:bitxhub:fabricappchain:. { \"id\" : \"did:bitxhub:fabricappchain:.\" , \"name\" : \"fabricTest1\" , \"validators\" : \"-----BEGIN CERTIFICATE-----\\nMIICKTCCAc+gAwIBAgIRAIBO31aZaSZoEYSy2AJuhJcwCgYIKoZIzj0EAwIwczEL\\nMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG\\ncmFuY2lzY28xGTAXBgNVBAoTEG9yZzIuZXhhbXBsZS5jb20xHDAaBgNVBAMTE2Nh\\nLm9yZzIuZXhhbXBsZS5jb20wHhcNMjAwMjA1MDgyMjAwWhcNMzAwMjAyMDgyMjAw\\nWjBqMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMN\\nU2FuIEZyYW5jaXNjbzENMAsGA1UECxMEcGVlcjEfMB0GA1UEAxMWcGVlcjEub3Jn\\nMi5leGFtcGxlLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABG3jszFPTbGm\\ndAYg2BxmHMTDKfQReNw3p9ttMK130qF5lQo5zLBG8Sa3viOCLnvjjg6A/P+yKnwv\\nisI/jEVE8T2jTTBLMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMCsGA1Ud\\nIwQkMCKAIMVL+daK7nMGr2/AQIXTSPFkdd3UiPVDkWtkh5ujnalEMAoGCCqGSM49\\nBAMCA0gAMEUCIQDMYOQiYeMiQZTxlRkj/3/jjYvwwdCcX5AWuFmraiHkugIgFkX/\\n6uiTSD0lz8P+wwlLf24cIABq2aZyi8q4gj0YfwA=\\n-----END CERTIFICATE-----\\n\" , \"consensus_type\" : \"raft\" , \"status\" : \"updating\" , \"chain_type\" : \"fabric\" , \"desc\" : \"test for fabric\" , \"version\" : \"v1.1.0\" , \"public_key\" : \"0x42444f30475a697746533934706e344169712b77365442417757663635787637724f616b4e786d536344465766394970546f694f7239712b6f6259386c514546617a434b316c714e32533446306b426e633542313034413d\" , \"owner_did\" : \"\" , \"did_doc_addr\" : \"./ipfs/QmQVxzUqN2Yv2UHUQXYwH8dSNkM8ReJ9qPqwJsf8zzoNUi\" , \"did_doc_hash\" : \"QmQVxzUqN2Yv2UHUQXYwH8dSNkM8ReJ9qPqwJsf8zzo111\" , \"fsm\" : {}}","text_tokens":["信息","nmiicktccac","jeve8t2jttblma4ga1uddweb","fabrictest1","get","id","begin","}","raft","具体","$","desc","(","json","jjyvwwdccx5awufmraihkugigfkx","qmqvxzuqn2yv2uhuqxywh8dsnkm8rej9qpqwjsf8zzo111","version","_","type","：","n","nisi","获取","public",":","certificate","nu2fuiezyyw5jaxnjbzenmasga1uecxmecgvlcjefmb0ga1ueaxmwcgvlcjeub3jn","wqeawihgdambgnvhrmbaf8eajaamcsga1ud","0","相关","=","/","did","#","yknwv","end","dak7nmgr2","pier","name","nbamca0gameuciqdmyoqiyemiqztxlrkj","appchain",",","for","链","\"","nlm9yzziuzxhhbxbszs5jb20whhcnmjawmja1mdgymjawwhcnmzawmjaymdgymjaw","nwjbqmqswcqydvqqgewjvuzetmbega1uecbmkq2fsawzvcm5pytewmbqga1uebxmn","aqixtspfkdd3uipvdkwtkh5ujnalemaogccqgsm49","fsm","-----","+","fabric",")","status","repo","test","如下",".","pwd","doc","ipfs","nmakga1uebhmcvvmxezarbgnvbagtcknhbglmb3juawexfjaubgnvbactdvnhbibg","addr","wwllf24ciabq2azyi8q4gj0yfwa","当前","n6uitsd0lz8p","hash","命令","样例","admin","\\","nmi5legftcgxllmnvbtbzmbmgbyqgsm49agegccqgsm49aweha0iabg3jszfptbgm","owner","--","validators","qmqvxzuqn2yv2uhuqxywh8dsnkm8rej9qpqwjsf8zzonui","-","0x42444f30475a697746533934706e344169712b77365442417757663635787637724f616b4e786d536344465766394970546f694f7239712b6f6259386c514546617a434b316c714e32533446306b426e633542313034413d","niwqkmckaimvl","fabricappchain","bitxhub"," ","3","chain","ndayg2bxmhmtdkfqrenw3p9ttmk130qf5lqo5zlbg8sa3vioclnvjjg6a","updating","执行","p","gawibagiraibo31azaszoeysy2ajuhjcwcgyikozizj0eawiwczel","key","v1.1","，","ncmfuy2lzy28xgtaxbgnvbaoteg9yzziuzxhhbxbszs5jb20xhdaabgnvbamte2nh","应用","consensus","{"],"title":"示例说明","title_tokens":["说明","示例"]},{"location":"bitxhub/introduction/advantage/","text":"产品优势 可扩展 应用链可扩展：应用链可动态注册到中继链，随时加入跨链中继联盟 跨链层级可扩展：多个中继联盟可通过跨链网关组成多层级的跨链路由网络，实现跨层级高效路由 高可用 跨链交易严格按照递增序号进行验证和执行 任意组件宕机时均可以通过交易日志进行失效恢复 中继链使用高可用的RBFT共识机制 易接入 跨链网关以插件形式适配各类应用链，避免侵入性影响 在跨链网关不停机的情况下动态进行应用链与插件更新 多中心 以分布式的区块链集群作为跨链可信中继 多方共同监管维护跨链平台，跨链交易对参与方公开透明 跨链交易以链式结构存储，难以篡改且便于审计","text_tokens":["随时","到","时均","适配","篡改","不","通过","层级","日志","区块","动态","分布","组件","可信","中继","以","验证","中心","监管","：","可用","性","作为","共识","结构","影响","各类","在","失效恢复","严格","参与方","审计","加入","链式","多方","存储","递增","的","与","可","交易","分布式","优势","布式","rbft","使用","透明","共同","侵入","且","机制","易","链","任意","实现","集群","进行","高","失效","序号","联盟","接入","跨","由","恢复","平台","插件","公开","下","多个","链路","高效","注册","更新","参与","对"," ","扩展","路由","可以","情况","跨链","和","难以","网络","组成","执行","形式","多","产品","，","网关","停机","按照","维护","便于","应用","宕机","避免"],"title":"产品优势","title_tokens":["优势","产品"]},{"location":"bitxhub/introduction/advantage/#_1","text":"","text_tokens":[],"title":"产品优势","title_tokens":["优势","产品"]},{"location":"bitxhub/introduction/advantage/#_2","text":"应用链可扩展：应用链可动态注册到中继链，随时加入跨链中继联盟 跨链层级可扩展：多个中继联盟可通过跨链网关组成多层级的跨链路由网络，实现跨层级高效路由","text_tokens":["注册","随时","到","链"," ","实现","扩展","路由","通过","跨链","加入","层级","网络","组成","动态","联盟","跨","由","的","中继","可","多","，","网关","：","应用","多个","链路","高效"],"title":"可扩展","title_tokens":["可","扩展"]},{"location":"bitxhub/introduction/advantage/#_3","text":"跨链交易严格按照递增序号进行验证和执行 任意组件宕机时均可以通过交易日志进行失效恢复 中继链使用高可用的RBFT共识机制","text_tokens":["机制","时均","任意","链"," ","失效恢复","严格","可以","进行","跨链","和","通过","高","日志","序号","失效","执行","组件","递增","恢复","的","中继","交易","验证","按照","rbft","使用","可用","共识","宕机"],"title":"高可用","title_tokens":["高","可用"]},{"location":"bitxhub/introduction/advantage/#_4","text":"跨链网关以插件形式适配各类应用链，避免侵入性影响 在跨链网关不停机的情况下动态进行应用链与插件更新","text_tokens":["影响","各类","更新","链","在","适配"," ","不","情况","跨链","进行","动态","形式","的","与","以","，","网关","插件","停机","性","应用","下","侵入","避免"],"title":"易接入","title_tokens":["易","接入"]},{"location":"bitxhub/introduction/advantage/#_5","text":"以分布式的区块链集群作为跨链可信中继 多方共同监管维护跨链平台，跨链交易对参与方公开透明 跨链交易以链式结构存储，难以篡改且便于审计","text_tokens":["结构","且","参与","链","对"," ","篡改","参与方","审计","集群","难以","跨链","链式","区块","多方","分布","存储","的","中继","交易","以","分布式","，","平台","便于","布式","监管","维护","透明","共同","作为","公开","可信"],"title":"多中心","title_tokens":["中心","多"]},{"location":"bitxhub/introduction/conception/","text":"基本概念 中继链 中继链是具有验证跨链消息和转发跨链消息的能力的去中心化可信中介。 跨链网关 在同构或异构区块链间进行交易收集、转换、传输的服务程序。 应用链 负责承载不同应用场景下的具体应用的业务合约逻辑。 跨链传输协议 通用的跨链传输协议IBTP（InterBlockchain Transfer Protocol）,允许异构资产、数据及服务进行跨链调用 验证引擎 对于不同的跨链交易所采用不同的验证规则策略，验证引擎会根据规则地址来判断采用不同的验证器进行验证 哈希时间锁定 一种基于时间差和隐藏哈希值完成跨链资产原子性交换的技术。","text_tokens":["协议","技术","锁定","合约","具体","能力","区块","场景","中心化","来","异构","中继","验证","中心","性","）","判断","会","规则","隐藏","收集","程序","在","对于","transfer","资产","。","及","中介","的","protocol","交换","交易","传输","一种","不同",",","允许","基于","完成","链","概念","逻辑","调用","原子","消息","进行","哈希","根据","去","基本概念","通用","或","采用","服务程序","下","时间","链是","转发","interblockchain","负责","值","引擎","ibtp"," ","具有","同构","策略","器","和","跨链","、","承载","转换","时间差","，","基本","网关","服务","（","地址","链间","应用","交易所","业务","可信","数据"],"title":"基本概念","title_tokens":["基本","概念","基本概念"]},{"location":"bitxhub/introduction/conception/#_1","text":"","text_tokens":[],"title":"基本概念","title_tokens":["基本","概念","基本概念"]},{"location":"bitxhub/introduction/conception/#_2","text":"中继链是具有验证跨链消息和转发跨链消息的能力的去中心化可信中介。","text_tokens":["具有","验证","能力","中心化","中心","。","消息","中介","可信","和","跨链","的","中继","链是","转发","去"],"title":"中继链","title_tokens":["链","中继"]},{"location":"bitxhub/introduction/conception/#_3","text":"在同构或异构区块链间进行交易收集、转换、传输的服务程序。","text_tokens":["或","同构","服务","服务程序","。","异构","转换","链间","进行","收集","的","在","程序","、","区块","交易","传输"],"title":"跨链网关","title_tokens":["网关","跨链"]},{"location":"bitxhub/introduction/conception/#_4","text":"负责承载不同应用场景下的具体应用的业务合约逻辑。","text_tokens":["逻辑","不同","。","合约","负责","的","应用","下","具体","业务","承载","场景"],"title":"应用链","title_tokens":["应用","链"]},{"location":"bitxhub/introduction/conception/#_5","text":"通用的跨链传输协议IBTP（InterBlockchain Transfer Protocol）,允许异构资产、数据及服务进行跨链调用","text_tokens":["interblockchain",",","允许","协议","ibtp","transfer"," ","调用","进行","跨链","资产","、","及","异构","的","protocol","传输","通用","（","服务","）","数据"],"title":"跨链传输协议","title_tokens":["协议","跨链","传输"]},{"location":"bitxhub/introduction/conception/#_6","text":"对于不同的跨链交易所采用不同的验证规则策略，验证引擎会根据规则地址来判断采用不同的验证器进行验证","text_tokens":["会","规则","引擎","对于","策略","器","进行","跨链","根据","来","的","交易","验证","，","不同","采用","地址","交易所","判断"],"title":"验证引擎","title_tokens":["验证","引擎"]},{"location":"bitxhub/introduction/conception/#_7","text":"一种基于时间差和隐藏哈希值完成跨链资产原子性交换的技术。","text_tokens":["技术","原子","。","性","隐藏","和","值","基于","哈希","完成","时间","跨链","交换","的","时间差","资产","一种"],"title":"哈希时间锁定","title_tokens":["锁定","哈希","时间"]},{"location":"bitxhub/introduction/scenaries/","text":"应用场景 在区块链实际应用的过程中，BitXHub支持以下场景的跨链应用。 1 资产互换 目前由于区块链一定程度的隔离性，链上的数字资产难以进行等价交换或转移。相比中心化的交换方式，BitXHub支持区块链账户资产的可信互换，能够制定安全透明的兑换规则，同时保证资产转移的原子性和一致性。 如将银行积分转换为航空公司里程，某银行打造了基于区块链的会员积分系统，会员可通过积分兑换多项非金融增值服务，如航空里程等。而接洽的航空公司已有正在运行的基于区块链的里程兑换系统，由于底层区块链技术的不同，此时就需要通过跨链技术对两条链上不同价值的资产进行转移。 2 数据互通 数据互通即多条独立的链之间进行数据更新和同步，这为跨行业监管提供了技术支撑。传统的监管手段无法保障上报数据的真实性，且系统间的对接成本高、可扩展性差，通过BitXHub打破异构区块链间的信息壁垒，有效地进行链上数据的安全共享。 如某疫苗云平台需要对各省份的区块链进行统一监管，获取各地疫苗接种情况的关键信息。由于各省使用的底层区块链技术不同，因此需要从底层打通各地数据中心，方便监管机构同步参与方间交易、达成共识的全过程。 3 业务互补 随着区块链应用的加速落地，业务联盟间常常具有互不相同的流程众多、业务复杂的区块链服务，为了不推倒已有的区块链基础设施，需要采用跨链技术实现这些异构区块链间的横向打通，扩大业务规模，实现互利共赢。 业务互补由于涉及链与链之间相应的合约跨链调用，实现更为复杂。比如在跨国贸易中，涉及的快递物流、企业资金流、海关信息流等均有很强的互补性，为了降低投入通过跨链手段从底层横向打通，融合贸易相关的业务，实现更大规模的业务协作。","text_tokens":["复杂","各","信息","为","金融","实际","流程","不","技术","比如","如","合约","海关","一定","相比","共赢","通过","区块","场景","省份","达成","对接","中心化","数字","展性","常常","扩大","异构","保证","目前","机构","信息流","兑换","独立","中心","监管","某","更为","统一","众多","性","共识","一致","获取","多项","打通","真实","将","即","接种","因此","积分","物流","横向","规则","壁垒","制定","如某","企业","等价交换","在","打破","互不","参与方","随着","设施","传统","相关","链上","系统","两条","资产","互利","航空公司","快递","有","正在","关键","支撑","。","的","与","强","可","交换","成本","交易","差","投入","非金融","一致性","此时","不同","增值","价值","跨行业","为了","使用","有效","透明","转移","相同","跨国","全过程","而","打造","从","同时","能够","公司","上报","且","疫苗","共享","支持","真实性","相应","基于","链","降低","接洽","数据中心","协作","规模","实现","涉及","调用","方式","无法","资金流","原子","进行","落地","基础设施","资金","高","过程","已有","方便","大规","加速","里程","手段","联盟","各地","这些","金流","互补","这为","提供","基础","间","程度","或","扩展性","可扩展性","平台","采用","中","跨行","等","等价","2","融合","运行","隔离","各省","大规模","更新","参与","更","保障","安全","均","对","之间","bitxhub"," ","航空","云","多条","3","具有","扩展","会员","地","以下","难以","跨链","和","情况","互补性","由于","、","互通","贸易","底层","需要","转换","行业","互换","同步","，","推倒","服务","很","银行","链间","应用","了","业务","数据","就","可信","1","账户"],"title":"应用场景","title_tokens":["应用","场景"]},{"location":"bitxhub/introduction/scenaries/#_1","text":"在区块链实际应用的过程中，BitXHub支持以下场景的跨链应用。","text_tokens":["，","。","过程","中","支持","以下","的","应用","跨链","在","链","区块","实际","bitxhub","场景"],"title":"应用场景","title_tokens":["应用","场景"]},{"location":"bitxhub/introduction/scenaries/#1","text":"目前由于区块链一定程度的隔离性，链上的数字资产难以进行等价交换或转移。相比中心化的交换方式，BitXHub支持区块链账户资产的可信互换，能够制定安全透明的兑换规则，同时保证资产转移的原子性和一致性。 如将银行积分转换为航空公司里程，某银行打造了基于区块链的会员积分系统，会员可通过积分兑换多项非金融增值服务，如航空里程等。而接洽的航空公司已有正在运行的基于区块链的里程兑换系统，由于底层区块链技术的不同，此时就需要通过跨链技术对两条链上不同价值的资产进行转移。","text_tokens":["为","金融","技术","如","一定","相比","通过","区块","中心化","数字","保证","目前","兑换","中心","某","性","一致","多项","将","积分","规则","制定","等价交换","链上","系统","两条","资产","航空公司","正在","。","的","可","交换","非金融","一致性","此时","不同","增值","价值","透明","转移","而","打造","同时","能够","公司","支持","基于","链","接洽","方式","原子","进行","已有","里程","程度","或","等","等价","运行","隔离","安全","对","bitxhub"," ","航空","会员","难以","和","跨链","由于","底层","需要","转换","互换","，","服务","银行","了","就","可信","账户"],"title":"1 资产互换","title_tokens":["资产","互换","1"," "]},{"location":"bitxhub/introduction/scenaries/#2","text":"数据互通即多条独立的链之间进行数据更新和同步，这为跨行业监管提供了技术支撑。传统的监管手段无法保障上报数据的真实性，且系统间的对接成本高、可扩展性差，通过BitXHub打破异构区块链间的信息壁垒，有效地进行链上数据的安全共享。 如某疫苗云平台需要对各省份的区块链进行统一监管，获取各地疫苗接种情况的关键信息。由于各省使用的底层区块链技术不同，因此需要从底层打通各地数据中心，方便监管机构同步参与方间交易、达成共识的全过程。","text_tokens":["各","信息","技术","通过","区块","省份","达成","对接","展性","异构","机构","独立","中心","监管","统一","共识","获取","打通","真实","即","接种","因此","壁垒","如某","打破","参与方","传统","系统","链上","关键","支撑","。","的","成本","交易","差","不同","跨行业","使用","有效","全过程","从","上报","且","疫苗","共享","真实性","链","数据中心","无法","进行","高","过程","方便","手段","各地","这为","提供","间","扩展性","平台","可扩展性","跨行","各省","更新","参与","保障","安全","对","之间","bitxhub"," ","云","多条","扩展","地","和","情况","由于","、","互通","底层","需要","行业","同步","，","链间","了","数据"],"title":"2 数据互通","title_tokens":["2","数据","互通"," "]},{"location":"bitxhub/introduction/scenaries/#3","text":"随着区块链应用的加速落地，业务联盟间常常具有互不相同的流程众多、业务复杂的区块链服务，为了不推倒已有的区块链基础设施，需要采用跨链技术实现这些异构区块链间的横向打通，扩大业务规模，实现互利共赢。 业务互补由于涉及链与链之间相应的合约跨链调用，实现更为复杂。比如在跨国贸易中，涉及的快递物流、企业资金流、海关信息流等均有很强的互补性，为了降低投入通过跨链手段从底层横向打通，融合贸易相关的业务，实现更大规模的业务协作。","text_tokens":["复杂","信息","流程","不","技术","比如","合约","海关","共赢","通过","区块","常常","扩大","异构","信息流","更为","众多","打通","物流","横向","企业","在","互不","随着","设施","相关","快递","互利","有","。","的","与","强","投入","为了","跨国","相同","从","相应","链","降低","协作","规模","实现","涉及","调用","资金流","落地","基础设施","资金","已有","大规","加速","手段","联盟","这些","金流","互补","基础","间","采用","中","等","融合","大规模","更","均","之间"," ","具有","跨链","互补性","由于","、","贸易","底层","需要","，","推倒","服务","链间","应用","业务","很"],"title":"3 业务互补","title_tokens":["业务","3","互补"," "]},{"location":"bitxhub/introduction/summary/","text":"跨链服务平台介绍 产品简介 BitXHub 是趣链科技自主研发的跨链技术平台，提供基于异构联盟链间的账本互操作解决方案。BitXHub 攻克了异构跨链过程中的交易捕获、信息传输以及身份验证等核心难题，同时兼容同构及异构区块链链间的跨链交易，允许异构区块链间的资产互换、数据互通及业务互补，致力于打造高可扩展、强鲁棒性、易运维升级的联盟链跨链通用协议及示范平台，为区块链生态中的网络互联与链上数据互通提供可靠、高效、安全的底层技术支撑。 BitXHub 于 2020 年 3 月正式开源，希望在开源社区共建下，针对更加丰富的业务场景，形成更加广泛的共识，让跨链协议更加通用化、标准化、规范化。期待更多的区块链开发者与相关行业从业者参与到趣链跨链技术标准化和革新演进的进程中，一起继续丰富完善跨链标准，桥接更多类型的区块链平台。 产品架构 趣链科技跨链技术平台 BitXHub 由三部分组成：中继链、跨链网关、应用链。 中继链（Relay-chain） ：用于应用链管理以及跨链交易的可信验证与可靠路由，是一种实现 IBTP 协议的开放许可链，确保跨链交易的事务一致性； 跨链网关（Pier） ：由相应的应用链维护的服务程序，担任着区块链间收集和传播交易的角色，既可以支持应用链和中继链之间，也可以支持中继链与中继链之间的交互； 应用链（App-chain） ：负责承载不同应用场景下的具体应用的业务合约逻辑的区块链； 为了适应不同的应用场景，BitXHub 的设计采用 灵活可组合架构 ，主要有三种架构：适配应用规模较大的中继链架构，处理效率更高效便捷的链对链架构以及区分层级关系的主侧链架构。 跨链协议 不同区块链由于其底层平台的加密算法、区块结构等不同，不同区块链之间的消息不能直接通信。为了能够支持异构区块链之间的跨链交易路由和可信验证，BitXHub 设计了通用的跨链传输协议 IBTP （InterBlockchain Transfer Protocol）,允许异构资产、数据及服务进行跨链调用。 该协议内容指定了相关跨链事件的来源链、目的链、跨链交易方法以及验证策略、签名等诸多信息，支持应用链与中继链、应用链与应用链间的交互操作，其结构如表 1-4 所示。应用链的跨链消息通过跨链网关转换成 IBTP 结构提交至中继链，中继链通过 IBTP 内容进行跨链交易的合法性验证及可靠路由。基于 IBTP 协议跨链网关可将不同应用链抛出的事件数据格式转换为统一结构。 参数 说明 From 来源链ID To 目的链ID Version 协议版本号 Index 跨链交易索引 Payload 跨链调用内容编码 Timestamp 跨链事件发生时间戳 Proof 跨链交易证明 Extra 自定义字段 IBTP 消息采用 P2P 的方式进行传输，消息的主体内容均采用对方的公钥进行加密确保消息内容传播的不被第三方窃取。同时调用内容经跨链网关间协商的对称密钥加密后再发送至中继链，保障传输调用的安全性与可靠性。 中继链 共识算法 中继链接入了强鲁棒拜占庭容错算法 RBFT，其失效数据恢复、动态节点增删等机制保证了中继链天然的高可用性。BitXHub 中的跨链交易在以事件形式抛出时通过序号递增的方式存储，在共识阶段对来自同一应用链的交易需要严格按照序号顺序进行排序，若接收到的交易序号异常时暂时将其放入缓存中等待，直到正确序号的交易到达后再继续进行排序、打包。 为了满足更多应用场景的需求，BitXHub 的中继链可以对节点进行动态增删，链上的节点对中继链共同维护并参与共识，为了避免部分节点因为某些故障导致节点状态大幅落后区块链网络，平台提供一种 Sync Protocol 的方式来更新异常节点状态，保障整个中继链系统的稳定运行。 验证引擎 中继链中验证引擎的设计采用了验证器的插拔式设计，即对于不同的跨链交易所采用不同的验证规则策略，验证引擎会根据规则地址来判断采用不同的验证器进行验证。现阶段的验证引擎支持 Go 内置验证器和 WASM 虚拟机验证器。 事务管理 中继链内置了事务管理合约，提供基于本地消息表的事务支持，实现了跨链事务的最终一致性。事务管理合约在处理跨链交易时，根据目的链数量的不同（一个或多个），采用不同的逻辑生成跨链事务 ID，并将事务 ID 对应的初始状态记录在事务管理合约。当目的链执行完跨链交易后，事务管理合约根据目的链交易的执行结果（成功或失败）更新对应事务的状态。事务管理合约提供了接口，可供各应用链查询某个事务 ID 对应的事务状态。若应用链发现事务执行失败，则需要负责业务上的回滚操作。 跨链网关 跨链网关（Pier）是由应用链维护、可与应用链和中继链直接交互的核心组件，作为发送方时需保证跨链交易接收有序性，作为接收方时需验证跨链交易可靠性。每个区块链网络的管理员需要指定并维护自己可信任的跨链网关节点，允许跨链网关节点授信访问和解析本区块链上的区块链跨链信息和相关状态信息。 在复杂的跨链场景下，应用链如何便捷地接入跨链系统以达到良好的扩展性，对于激发跨链系统生态的活力至关重要。跨链网关是一种连接不同区块链系统的交互组件，在 BitXHub 中充当着两个不同的角色： 连接应用链和中继链。在单中继链的层级中，Pier 作为一个中间部件来 简化区块链接入跨链系统的过程，增强接入跨链系统的便捷性。 连接不同的中继链。在多中继链形成的区块链网络中，Pier 通过 P2P 组 网的方式在多个层级中起到“路由器”的作用。 为了实现上述的便捷性和可扩展性，跨链网关在应用链的适配和核心功能的实现上作了灵活设计。 插件机制 BitXHub 提供跨链网关插件机制，其一大特点是将跨链网关中与应用链的交互模块和核心模块进行解耦，从而方便更多的应用链加入跨链系统。如下图 1-5 所示，在跨链网关运行时，通过动态加载插件的方式完成应用链的接入。 网关高可用 为了更好的保障跨链网络之间互通的稳定性，BitXHub 提供主备跨链网关功能，如图 1-6 所示，基于中继链，主备跨链网关和中继链上的节点建立连接，通过竞争机制，按照连接节点的先后决定主备网关次序，保障中继链上网关主节点的唯一性。并支持主备网关进行灵活切换，当主节点网关出现异常宕机时，系统可进行自动无缝切换，为中继链提供高可靠的跨链服务，实现更加稳定的数据互通互联。 区块链互联网络 在最新的 BitXHub 跨链平台中，中继链在原有功能的基础上增加了大规模跨链网络的功能，如图 1-7 所示，通过跨链网关形成一个 P2P 网络，对不同中继链的跨链消息进行消息路由，达到平行扩展中继链的效果。在中继链之间的跨链网络中，增加大规模网络中的消息路由机制，并通过多签认证的方式，实现不同中继链上的应用链间的身份验证。目前平台可支持超过 1000+的应用链的并发接入性能。 跨链技术作为连接各区块链的桥梁，实现了不同区块链之间的资产原子性交易、信息数据互通、业务服务互补等功能，打破不同区块链间的数据孤岛。跨链技术是构建区块链互联互通网络生态，实现区块链“价值互联网”的关键枢纽。","text_tokens":["性交易","增删","主备","说明","式","上作","协议","落后","各","信息","上","为","合法","研发","不","技术","合约","处理","通信","本区","便捷性","区块","场景","对称","满足","中继","以","示范","正式","编码","被","解决方案","需","并","方时","打包","操作","主侧","“","趣链","本地","严格","链接","链中","可用性","互联网络","解决","捕获","回滚","存储","。","高可用性","protocol","可","适应","wasm","架构","一致性","角色","不同","rbft","顺序","进程","送至","打造",",","能够","再","接口","次序","基于","完成","信任","原子","关节","发现","组","第三方","革新","路由器","开发","两个","或","插件","采用","服务程序","关系","中","互联网","开放","换成","运行","高效","枢纽","interblockchain","先后","账本","既","大规模","更","以及","参与","-","安全","对","之间","演进","bitxhub"," ","范化","3","更加","路由","转换成","数据恢复","和","组成","执行","用于","灵活","数据格式","形式","当","互操作","导致","行业","较大","密钥","强鲁棒","部件","自己","（","主体","继续","链间","可供","管理","宕机","业务","若","高可","index","从而","排序","加密算法","三方","到","网","来自","鲁棒性","简介","活力","组合","业者","天然","规范","完跨","简化","异构","保证","目前","达到","因为","原有","失败","图","缓存","自主","timestamp","：","可用","是","作为","一致","成功","关节点","现阶段","规则","第三","效果","在","transfer","增强","指定","其","2020","签名","from","加入","系统","稳定","定义","支撑","社区","6","后","的","强","与","交易","传输","致力于","则","对应","为了","管理员","共同","如表","解","窃取","同时","一个","上述","机制","规模","实现","主","调用","内置","自动","+","决定","过程","接入","跨","由","连接","发送至","拜占庭","互补","app","最新","生态","表","特点","内容","期待","更新","负责","到达","go","均","引擎","解析","难题","抛出","作用","策略","记录","出现异常","互通","也","定性","出现","攻克","方法","proof","p2p","易运维","稳定性","戳","多","索引","地址","虚拟","竞争","可信","1","避免","重要","单","唯一","性能","致力","id","容错","互联","to","事件","具体","层级","relay","直到","设计","大幅","组件","来","展性","年","性交","至","version","访问","类型","验证","良好","入","统一","共识","科技","段","）","判断","针对","会","至关重要","即","”","插拔","发生","三种","收集","程序","对于","联网","加密","需求","方案","建立","链上","到趣","资产","孤岛","关键","状态","及","递增","事务","一大","正确","pier","介绍","无缝","服务平台","支持","相应","异常","链","故障","逻辑","不能","经跨","某个","开源","高","失效","序号","桥梁","放入","联盟","查询","恢复","提供","基础","如何","数量","间","通用","并发","自定义","扩展性","可扩展性","增加","等","1000","协商","诸多","功能","部分","保障","起到","ibtp","发送","4","对方","格式","公钥","同构","chain","于","可以","主要","从业者","底层","切换","链链","时","需要","通用化","可靠","广泛","最终","产品","核心","标准","桥接","按照","自定","每个","来源","应用","目的","规范化","超过","有序","复杂","模块","许可","事务管理","适配","身份","身份验证","；","传播","通过","三","等待","动态","当主","激发","5","所示","希望","可靠性","整个","合法性","充当","将","认证","结构","如图","一起","生成","有序性","打破","丰富","平行","构建","同一","节点","相关","形成","初始状态","加载","产品简介","兼容","有","确保","结果","各区","互联互通","payload","着","提交","一种","价值","参数","允许","从业","便捷","效率","方式","完善","消息","sync","进行","月","如下","根据","方便","大规","接收","7","区分","块","平台","暂时","下","时间","多个","证明","耦","让","字","联网络","算法","交互","直接","安全性","扩展","器","地","跨链","升级","网络","共建","由于","、","版本号","某些","虚拟机","授信","承载","更好","竞争机制","多签","阶段","中间","初始","唯一性","转换","标准化","extra","互换","版本","，","网关","服务","维护","至关","担任","链网","了","交易所","开发者","该","数据"],"title":"平台介绍","title_tokens":["介绍","平台"]},{"location":"bitxhub/introduction/summary/#_1","text":"","text_tokens":[],"title":"跨链服务平台介绍","title_tokens":["介绍","平台","服务","服务平台","跨链"]},{"location":"bitxhub/introduction/summary/#_2","text":"BitXHub 是趣链科技自主研发的跨链技术平台，提供基于异构联盟链间的账本互操作解决方案。BitXHub 攻克了异构跨链过程中的交易捕获、信息传输以及身份验证等核心难题，同时兼容同构及异构区块链链间的跨链交易，允许异构区块链间的资产互换、数据互通及业务互补，致力于打造高可扩展、强鲁棒性、易运维升级的联盟链跨链通用协议及示范平台，为区块链生态中的网络互联与链上数据互通提供可靠、高效、安全的底层技术支撑。 BitXHub 于 2020 年 3 月正式开源，希望在开源社区共建下，针对更加丰富的业务场景，形成更加广泛的共识，让跨链协议更加通用化、标准化、规范化。期待更多的区块链开发者与相关行业从业者参与到趣链跨链技术标准化和革新演进的进程中，一起继续丰富完善跨链标准，桥接更多类型的区块链平台。","text_tokens":["高可","规范化","协议","信息","上","致力","为","研发","鲁棒性","身份","技术","身份验证","互联","业者","区块","场景","规范","年","异构","示范","类型","验证","自主","正式","希望","是","解决方案","共识","科技","针对","操作","一起","在","趣链","开发者","方案","2020","丰富","相关","形成","到趣","兼容","解决","资产","捕获","支撑","。","及","社区","的","强","与","交易","传输","致力于","进程","打造","同时","允许","从业","基于","链","完善","开源","月","过程","革新","联盟","互补","提供","开发","间","通用","平台","生态","中","等","下","让","高效","期待","账本","更","以及","参与","安全","演进","难题","bitxhub"," ","范化","3","同构","扩展","更加","于","和","跨链","升级","网络","共建","、","互通","从业者","底层","链链","通用化","互操作","可靠","攻克","行业","易运维","广泛","标准化","互换","多","，","核心","标准","桥接","继续","链间","了","业务","数据"],"title":"产品简介","title_tokens":["产品简介","产品","简介"]},{"location":"bitxhub/introduction/summary/#_3","text":"趣链科技跨链技术平台 BitXHub 由三部分组成：中继链、跨链网关、应用链。 中继链（Relay-chain） ：用于应用链管理以及跨链交易的可信验证与可靠路由，是一种实现 IBTP 协议的开放许可链，确保跨链交易的事务一致性； 跨链网关（Pier） ：由相应的应用链维护的服务程序，担任着区块链间收集和传播交易的角色，既可以支持应用链和中继链之间，也可以支持中继链与中继链之间的交互； 应用链（App-chain） ：负责承载不同应用场景下的具体应用的业务合约逻辑的区块链； 为了适应不同的应用场景，BitXHub 的设计采用 灵活可组合架构 ，主要有三种架构：适配应用规模较大的中继链架构，处理效率更高效便捷的链对链架构以及区分层级关系的主侧链架构。","text_tokens":["协议","许可","适配","技术","组合","；","合约","处理","传播","具体","层级","relay","三","区块","场景","设计","中继","验证","：","是","科技","一致","）","主侧","三种","收集","程序","趣链","有","确保","。","着","的","与","可","交易","适应","一种","一致性","架构","角色","不同","事务","为了","pier","便捷","支持","相应","效率","链","规模","实现","逻辑","由","区分","app","平台","采用","服务程序","关系","开放","下","高效","既","更","以及","部分","负责","交互","-","对","ibtp","之间","bitxhub"," ","chain","路由","可以","和","跨链","、","主要","承载","组成","也","用于","灵活","可靠","较大","，","网关","（","维护","服务","担任","链间","应用","管理","业务","可信"],"title":"产品架构","title_tokens":["产品","架构"]},{"location":"bitxhub/introduction/summary/#_4","text":"不同区块链由于其底层平台的加密算法、区块结构等不同，不同区块链之间的消息不能直接通信。为了能够支持异构区块链之间的跨链交易路由和可信验证，BitXHub 设计了通用的跨链传输协议 IBTP （InterBlockchain Transfer Protocol）,允许异构资产、数据及服务进行跨链调用。 该协议内容指定了相关跨链事件的来源链、目的链、跨链交易方法以及验证策略、签名等诸多信息，支持应用链与中继链、应用链与应用链间的交互操作，其结构如表 1-4 所示。应用链的跨链消息通过跨链网关转换成 IBTP 结构提交至中继链，中继链通过 IBTP 内容进行跨链交易的合法性验证及可靠路由。基于 IBTP 协议跨链网关可将不同应用链抛出的事件数据格式转换为统一结构。 参数 说明 From 来源链ID To 目的链ID Version 协议版本号 Index 跨链交易索引 Payload 跨链调用内容编码 Timestamp 跨链事件发生时间戳 Proof 跨链交易证明 Extra 自定义字段 IBTP 消息采用 P2P 的方式进行传输，消息的主体内容均采用对方的公钥进行加密确保消息内容传播的不被第三方窃取。同时调用内容经跨链网关间协商的对称密钥加密后再发送至中继链，保障传输调用的安全性与可靠性。","text_tokens":["目的","index","说明","加密算法","协议","三方","信息","为","合法","id","不","to","传播","通信","通过","事件","区块","设计","对称","异构","中继","至","version","所示","验证","timestamp","编码","统一","被","可靠性","段","）","合法性","将","结构","操作","发生","第三","加密","transfer","指定","其","签名","from","相关","资产","定义","确保","payload","。","及","后","的","与","protocol","可","提交","交易","传输","不同","为了","参数","送至","如表","窃取","同时",",","能够","允许","再","支持","基于","链","不能","调用","经跨","方式","消息","进行","第三方","发送至","通用","间","自定义","平台","采用","内容","等","时间","证明","换成","协商","诸多","字","interblockchain","算法","以及","保障","交互","直接","-","均","安全","之间","ibtp","发送","4","bitxhub","抛出"," ","格式","对方","安全性","公钥","策略","路由","转换成","和","跨链","由于","、","版本号","底层","数据格式","转换","可靠","方法","proof","p2p","extra","戳","版本","索引","密钥","，","网关","（","服务","自定","主体","链间","来源","了","应用","该","可信","1","数据"],"title":"跨链协议","title_tokens":["跨链","协议"]},{"location":"bitxhub/introduction/summary/#_5","text":"","text_tokens":[],"title":"中继链","title_tokens":["链","中继"]},{"location":"bitxhub/introduction/summary/#_6","text":"中继链接入了强鲁棒拜占庭容错算法 RBFT，其失效数据恢复、动态节点增删等机制保证了中继链天然的高可用性。BitXHub 中的跨链交易在以事件形式抛出时通过序号递增的方式存储，在共识阶段对来自同一应用链的交易需要严格按照序号顺序进行排序，若接收到的交易序号异常时暂时将其放入缓存中等待，直到正确序号的交易到达后再继续进行排序、打包。 为了满足更多应用场景的需求，BitXHub 的中继链可以对节点进行动态增删，链上的节点对中继链共同维护并参与共识，为了避免部分节点因为某些故障导致节点状态大幅落后区块链网络，平台提供一种 Sync Protocol 的方式来更新异常节点状态，保障整个中继链系统的稳定运行。","text_tokens":["增删","排序","落后","到","来自","容错","通过","事件","直到","区块","天然","等待","场景","动态","大幅","来","保证","避免","满足","中继","因为","以","缓存","入","可用","共识","整个","并","打包","将","在","需求","其","严格","链接","同一","节点","可用性","链上","系统","稳定","存储","状态","。","递增","后","高可用性","的","protocol","交易","一种","rbft","顺序","为了","共同","正确","再","机制","异常","链","故障","方式","sync","进行","失效","序号","放入","接收","恢复","拜占庭","提供","暂时","平台","中","等","运行","更新","更","算法","到达","参与","部分","保障","对","bitxhub","抛出"," ","可以","数据恢复","跨链","某些","网络","、","阶段","时","需要","形式","导致","多","强鲁棒","，","按照","维护","继续","了","应用","若","数据"],"title":"共识算法","title_tokens":["算法","共识"]},{"location":"bitxhub/introduction/summary/#_7","text":"中继链中验证引擎的设计采用了验证器的插拔式设计，即对于不同的跨链交易所采用不同的验证规则策略，验证引擎会根据规则地址来判断采用不同的验证器进行验证。现阶段的验证引擎支持 Go 内置验证器和 WASM 虚拟机验证器。","text_tokens":["会","现阶段","即","插拔","式","规则","go","支持","引擎","对于"," ","策略","链中","内置","器","进行","跨链","和","虚拟机","根据","设计","阶段","来","。","的","中继","交易","wasm","验证","，","不同","采用","地址","了","虚拟","交易所","判断"],"title":"验证引擎","title_tokens":["验证","引擎"]},{"location":"bitxhub/introduction/summary/#_8","text":"中继链内置了事务管理合约，提供基于本地消息表的事务支持，实现了跨链事务的最终一致性。事务管理合约在处理跨链交易时，根据目的链数量的不同（一个或多个），采用不同的逻辑生成跨链事务 ID，并将事务 ID 对应的初始状态记录在事务管理合约。当目的链执行完跨链交易后，事务管理合约根据目的链交易的执行结果（成功或失败）更新对应事务的状态。事务管理合约提供了接口，可供各应用链查询某个事务 ID 对应的事务状态。若应用链发现事务执行失败，则需要负责业务上的回滚操作。","text_tokens":["目的","将","操作","一个","接口","更新","生成","负责","支持","各","基于","上","链","在","事务管理"," ","本地","实现","逻辑","id","内置","合约","消息","处理","某个","记录","成功","发现","跨链","初始状态","结果","根据","回滚","执行","初始","时","状态","查询","完跨","需要","。","当","后","的","中继","提供","最终","交易","数量","失败","一致性","，","或","则","不同","对应","（","表","事务","采用","可供","了","管理","应用","多个","一致","业务","）","并","若"],"title":"事务管理","title_tokens":["事务管理","事务","管理"]},{"location":"bitxhub/introduction/summary/#_9","text":"跨链网关（Pier）是由应用链维护、可与应用链和中继链直接交互的核心组件，作为发送方时需保证跨链交易接收有序性，作为接收方时需验证跨链交易可靠性。每个区块链网络的管理员需要指定并维护自己可信任的跨链网关节点，允许跨链网关节点授信访问和解析本区块链上的区块链跨链信息和相关状态信息。 在复杂的跨链场景下，应用链如何便捷地接入跨链系统以达到良好的扩展性，对于激发跨链系统生态的活力至关重要。跨链网关是一种连接不同区块链系统的交互组件，在 BitXHub 中充当着两个不同的角色： 连接应用链和中继链。在单中继链的层级中，Pier 作为一个中间部件来 简化区块链接入跨链系统的过程，增强接入跨链系统的便捷性。 连接不同的中继链。在多中继链形成的区块链网络中，Pier 通过 P2P 组 网的方式在多个层级中起到“路由器”的作用。 为了实现上述的便捷性和可扩展性，跨链网关在应用链的适配和核心功能的实现上作了灵活设计。","text_tokens":["有序","重要","单","上作","复杂","信息","上","网","适配","活力","通过","本区","层级","便捷性","区块","场景","设计","组件","来","展性","简化","保证","中继","达到","激发","以","访问","验证","良好","入","：","是","需","作为","可靠性","关节点","）","并","充当","方时","至关重要","”","“","在","对于","增强","指定","有序性","链接","节点","相关","系统","形成","状态","。","着","与","的","可","交易","一种","角色","不同","为了","管理员","pier","允许","一个","便捷","上述","链","实现","信任","方式","关节","组","过程","接入","接收","跨","由","路由器","连接","如何","块","两个","扩展性","生态","可扩展性","中","下","多个","功能","交互","直接","起到","解析","发送","bitxhub"," ","作用","扩展","路由","地","和","跨链","网络","、","授信","中间","需要","灵活","可靠","p2p","多","，","核心","部件","网关","（","维护","自己","每个","至关","链网","应用","管理","了"],"title":"跨链网关","title_tokens":["网关","跨链"]},{"location":"bitxhub/introduction/summary/#_10","text":"BitXHub 提供跨链网关插件机制，其一大特点是将跨链网关中与应用链的交互模块和核心模块进行解耦，从而方便更多的应用链加入跨链系统。如下图 1-5 所示，在跨链网关运行时，通过动态加载插件的方式完成应用链的接入。","text_tokens":["运行","将","从而","模块","更","机制","交互","-","完成","链","在","bitxhub"," ","其","方式","和","跨链","进行","加入","系统","如下","通过","加载","方便","动态","时","接入","。","与","的","提供","多","5","图","所示","，","核心","网关","插件","特点","中","一大","是","应用","解","耦","1"],"title":"插件机制","title_tokens":["插件","机制"]},{"location":"bitxhub/introduction/summary/#_11","text":"为了更好的保障跨链网络之间互通的稳定性，BitXHub 提供主备跨链网关功能，如图 1-6 所示，基于中继链，主备跨链网关和中继链上的节点建立连接，通过竞争机制，按照连接节点的先后决定主备网关次序，保障中继链上网关主节点的唯一性。并支持主备网关进行灵活切换，当主节点网关出现异常宕机时，系统可进行自动无缝切换，为中继链提供高可靠的跨链服务，实现更加稳定的数据互通互联。","text_tokens":["主备","无缝","先后","如图","唯一","保障","机制","-","支持","基于","异常","链","之间","为","bitxhub"," ","主","实现","更加","建立","互联","自动","节点","并","和","跨链","通过","链上","网络","决定","次序","稳定","更好","互通","竞争机制","进行","系统","高","切换","当主","时","灵活","。","定性","6","连接","唯一性","出现","的","出现异常","可靠","提供","中继","稳定性","可","所示","，","网关","按照","服务","为了","宕机","竞争","功能","1","数据"],"title":"网关高可用","title_tokens":["网关","高","可用"]},{"location":"bitxhub/introduction/summary/#_12","text":"在最新的 BitXHub 跨链平台中，中继链在原有功能的基础上增加了大规模跨链网络的功能，如图 1-7 所示，通过跨链网关形成一个 P2P 网络，对不同中继链的跨链消息进行消息路由，达到平行扩展中继链的效果。在中继链之间的跨链网络中，增加大规模网络中的消息路由机制，并通过多签认证的方式，实现不同中继链上的应用链间的身份验证。目前平台可支持超过 1000+的应用链的并发接入性能。 跨链技术作为连接各区块链的桥梁，实现了不同区块链之间的资产原子性交易、信息数据互通、业务服务互补等功能，打破不同区块链间的数据孤岛。跨链技术是构建区块链互联互通网络生态，实现区块链“价值互联网”的关键枢纽。","text_tokens":["性交易","超过","信息","上","性能","身份","技术","身份验证","互联","通过","区块","目前","性交","中继","达到","原有","所示","验证","是","作为","并","认证","如图","”","效果","“","在","联网","打破","平行","构建","形成","链上","资产","孤岛","各区","关键","互联互通","。","的","可","交易","不同","价值","一个","支持","机制","链","规模","实现","方式","原子","消息","+","进行","桥梁","大规","接入","连接","7","互补","最新","基础","并发","块","平台","生态","增加","中","等","互联网","1000","功能","枢纽","大规模","-","对","之间","bitxhub"," ","扩展","路由","跨链","网络","、","互通","多签","p2p","，","网关","服务","链间","了","应用","业务","1","数据"],"title":"区块链互联网络","title_tokens":["互联","联网络","联网","互联网","互联网络","网络","链","区块"]},{"location":"bitxhub/operation/exception_problem_handling/","text":"异常问题处理 这里主要介绍跨链系统出现异常的情况下如何定位问题和快速操作，让跨链系统恢复可用状态 场景一：Pier与BitXHub之间连接异常 现象 Pier跨链网关日志显示连接不到BitXHub节点（可参考查看pier节点日志的操作说明）。 问题定位 看到此现象首先检查该Pier连接的BitXHub节点状态是否正常，如果BitXHub状态正常，那再检查Pier到BitXHub之间的网络是否连通，应具体到对应端口连接。 应急恢复方法 如果BitXHub节点状态不正常，应该先恢复该BitXHub节点或切换到连接其它正常的BitXHub节点后，再启动运行Pier； 如果BitXHub节点状态正常，问题是网络不通导致，则应先检查并解决网络连通问题，再启动运行Pier。 验证方法 重新启动的Pier跨链网关工作正常，可以连接BitXHub节点 场景二：Pier与应用链之间连接异常 现象 Pier跨链网关启动时日志显示连接不到指定的应用链，或Pier处理跨链交易时日志显示一直重试连接应用链（可参考查看pier节点日志的操作说明）。 问题定位 看看到此现象首先检查该Pier连接的应用链节点状态是否正常，如果应用链状态正常，那再检查Pier到应用链之间的网络是否连通，应具体到对应端口连接。 应急恢复方法 如果应用链节点状态不正常，应该先恢复该应用链节点后，再启动运行Pier； 如果应用链节点状态正常，问题是网络不通导致，则应先检查并解决网络连通问题，再启动运行Pier。 验证方法 重新启动的Pier跨链网关工作正常，可以连接应用链节点。 场景三：Pier日志提示“system is temporarily unavailable” 现象 Pier跨链网关日志显示“system is temporarily unavailable”（可参考查看pier节点日志的操作说明）。 问题定位 看到此现象首先检查该Pier连接的BitXHub节点状态是否正常，再查看BitXHub集群中各节点的日志信息。 应急恢复方法 如果BitXHub集群正处于选举或恢复阶段，可以等其共识完成后再发起跨链交易请求； 如果BitXHub集群已有超过可容忍的节点处于失去连接状态，应先按照场景一的方法解决问题，使集群状态恢复正常后再发起跨链交易请求。 验证方法 BitXHub集群工作正常，跨链交易执行成功，可以正确返回交易回执。","text_tokens":["工作","超过","不到","说明","各","信息","到","unavailable","端口","一直","不","；","连通","处理","检查","如果","具体","日志","查看","定位","三","is","场景","重试","定位问题","其它","请求","是否","正","应该","验证","：","可用","是","这里","共识","成功","快速","）","并","失去","操作","”","“","二","指定","其","节点","回执","系统","解决","状态","。","后","重新启动","的","与","启动","那","可","交易","则","对应","恢复正常","先","system","正确","pier","提示","介绍","再","异常","应","链","完成","返回","看到","集群","已有","一","选举","恢复","连接","如何","首先","或","发起","现象","使","中","等","下","应先","让","处于","运行","容忍","重新","应急","之间","再启动","bitxhub"," ","temporarily","正常","可以","出现异常","情况","跨链","和","可容","网络","解决问题","此","主要","阶段","切换","执行","时","不通","出现","方法","导致","显示","可容忍","问题","，","网关","（","按照","参考","应用","看看","该"],"title":"异常问题处理","title_tokens":["问题","异常","处理"]},{"location":"bitxhub/operation/exception_problem_handling/#_1","text":"这里主要介绍跨链系统出现异常的情况下如何定位问题和快速操作，让跨链系统恢复可用状态","text_tokens":["介绍","操作","异常","出现异常","情况","跨链","和","系统","主要","定位","定位问题","状态","出现","恢复","的","如何","问题","，","可用","下","这里","快速","让"],"title":"异常问题处理","title_tokens":["问题","异常","处理"]},{"location":"bitxhub/operation/exception_problem_handling/#pierbitxhub","text":"","text_tokens":[],"title":"场景一：Pier与BitXHub之间连接异常","title_tokens":["一","：","连接","异常","与","之间","pier","bitxhub","场景"]},{"location":"bitxhub/operation/exception_problem_handling/#_2","text":"Pier跨链网关日志显示连接不到BitXHub节点（可参考查看pier节点日志的操作说明）。","text_tokens":["操作","网关","（","不到","说明","）","。","连接","节点","参考","跨链","的","日志","可","pier","查看","显示","bitxhub"],"title":"现象","title_tokens":["现象"]},{"location":"bitxhub/operation/exception_problem_handling/#_3","text":"看到此现象首先检查该Pier连接的BitXHub节点状态是否正常，如果BitXHub状态正常，那再检查Pier到BitXHub之间的网络是否连通，应具体到对应端口连接。","text_tokens":["再","到","应","之间","端口","bitxhub","看到","连通","检查","正常","节点","如果","具体","网络","此","状态","。","是否","连接","的","那","首先","，","对应","现象","pier","该"],"title":"问题定位","title_tokens":["问题","定位"]},{"location":"bitxhub/operation/exception_problem_handling/#_4","text":"如果BitXHub节点状态不正常，应该先恢复该BitXHub节点或切换到连接其它正常的BitXHub节点后，再启动运行Pier； 如果BitXHub节点状态正常，问题是网络不通导致，则应先检查并解决网络连通问题，再启动运行Pier。","text_tokens":["到","再启动","bitxhub"," ","不","；","连通","检查","正常","节点","并","如果","网络","解决","切换","状态","其它","。","不通","恢复","连接","后","导致","的","应该","启动","问题","，","或","则","先","是","pier","应先","该","运行"],"title":"应急恢复方法","title_tokens":["方法","应急","恢复"]},{"location":"bitxhub/operation/exception_problem_handling/#_5","text":"重新启动的Pier跨链网关工作正常，可以连接BitXHub节点","text_tokens":["工作","，","网关","正常","重新","重新启动","可以","的","跨链","启动","连接","节点","pier","bitxhub"],"title":"验证方法","title_tokens":["方法","验证"]},{"location":"bitxhub/operation/exception_problem_handling/#pier","text":"","text_tokens":[],"title":"场景二：Pier与应用链之间连接异常","title_tokens":["：","连接","异常","与","应用","链","之间","pier","二","场景"]},{"location":"bitxhub/operation/exception_problem_handling/#_6","text":"Pier跨链网关启动时日志显示连接不到指定的应用链，或Pier处理跨链交易时日志显示一直重试连接应用链（可参考查看pier节点日志的操作说明）。","text_tokens":["操作","不到","说明","链","一直","指定","处理","节点","跨链","日志","查看","重试","时","。","连接","的","启动","可","显示","交易","，","或","网关","（","参考","应用","pier","）"],"title":"现象","title_tokens":["现象"]},{"location":"bitxhub/operation/exception_problem_handling/#_7","text":"看看到此现象首先检查该Pier连接的应用链节点状态是否正常，如果应用链状态正常，那再检查Pier到应用链之间的网络是否连通，应具体到对应端口连接。","text_tokens":["再","到","应","链","之间","端口","连通","检查","正常","节点","如果","具体","网络","此","状态","。","是否","连接","的","那","首先","，","对应","现象","应用","看看","pier","该"],"title":"问题定位","title_tokens":["问题","定位"]},{"location":"bitxhub/operation/exception_problem_handling/#_8","text":"如果应用链节点状态不正常，应该先恢复该应用链节点后，再启动运行Pier； 如果应用链节点状态正常，问题是网络不通导致，则应先检查并解决网络连通问题，再启动运行Pier。","text_tokens":["链","再启动"," ","不","；","连通","检查","正常","节点","并","如果","网络","解决","状态","。","不通","恢复","后","导致","应该","启动","问题","，","则","先","是","应用","pier","应先","该","运行"],"title":"应急恢复方法","title_tokens":["方法","应急","恢复"]},{"location":"bitxhub/operation/exception_problem_handling/#_9","text":"重新启动的Pier跨链网关工作正常，可以连接应用链节点。","text_tokens":["工作","，","节点","网关","。","正常","重新","重新启动","可以","的","跨链","启动","连接","应用","链","pier"],"title":"验证方法","title_tokens":["方法","验证"]},{"location":"bitxhub/operation/exception_problem_handling/#piersystem-is-temporarily-unavailable","text":"","text_tokens":[],"title":"场景三：Pier日志提示“system is temporarily unavailable”","title_tokens":["is"," ","temporarily","提示","”","：","unavailable","system","“","日志","pier","三","场景"]},{"location":"bitxhub/operation/exception_problem_handling/#_10","text":"Pier跨链网关日志显示“system is temporarily unavailable”（可参考查看pier节点日志的操作说明）。","text_tokens":["操作","”","说明","“","unavailable"," ","temporarily","节点","跨链","日志","查看","is","。","的","可","显示","网关","（","system","参考","pier","）"],"title":"现象","title_tokens":["现象"]},{"location":"bitxhub/operation/exception_problem_handling/#_11","text":"看到此现象首先检查该Pier连接的BitXHub节点状态是否正常，再查看BitXHub集群中各节点的日志信息。","text_tokens":["再","各","信息","bitxhub","看到","检查","正常","节点","集群","日志","此","查看","状态","。","是否","连接","的","首先","，","现象","中","pier","该"],"title":"问题定位","title_tokens":["问题","定位"]},{"location":"bitxhub/operation/exception_problem_handling/#_12","text":"如果BitXHub集群正处于选举或恢复阶段，可以等其共识完成后再发起跨链交易请求； 如果BitXHub集群已有超过可容忍的节点处于失去连接状态，应先按照场景一的方法解决问题，使集群状态恢复正常后再发起跨链交易请求。","text_tokens":["容忍","失去","超过","再","完成","bitxhub"," ","其","；","集群","可以","可容","如果","跨链","节点","解决问题","正常","解决","已有","场景","阶段","选举","一","状态","请求","。","正","恢复","后","连接","的","方法","交易","可容忍","问题","或","，","发起","恢复正常","按照","使","等","共识","应先","处于"],"title":"应急恢复方法","title_tokens":["方法","应急","恢复"]},{"location":"bitxhub/operation/exception_problem_handling/#_13","text":"BitXHub集群工作正常，跨链交易执行成功，可以正确返回交易回执。","text_tokens":["工作","执行","，","。","正常","集群","可以","跨链","正确","回执","成功","返回","交易","bitxhub"],"title":"验证方法","title_tokens":["方法","验证"]},{"location":"bitxhub/operation/node_log_view/","text":"节点日志查看 这里主要介绍如何查看跨链系统中bitxhub和pier节点的日志信息。 BitXHub 如果是在终端前台启动的节点，那么日志会实时打印在终端上，观察其无报错即可； 如果是通过nohup等后台启动的节点，在节点主配置目录的logs文件夹中就是节点的日志文件，打开即可检查日志，一般情况下除了出块，bitxhub节点之间会定时相互 ping 其它节点并返回延时信息，可以简单看到节点集群之间的网络状态。 Pier 如果是在终端前台启动的节点，那么日志会实时打印在终端上，观察其无报错即可； 如果是通过nohup等后台启动的节点，在节点主配置目录的logs文件夹中就是节点的日志文件，打开即可检查日志，","text_tokens":["会","文件夹","介绍","一般","nohup","目录","信息","上","在","无","情况","除了","配置","之间","相互","bitxhub","返回"," ","主","其","看到","；","那么","logs","ping","检查","集群","节点","即可","和","跨链","如果","系统","实时","日志","通过","主要","查看","文件","件夹","打开","网络","就是","其它","状态","。","延时","打印","观察","的","启动","终端","如何","可以","后台","报错","，","简单","出块","中","是","等","下","这里","定时","前台","pier","并"],"title":"查看日志","title_tokens":["查看","日志"]},{"location":"bitxhub/operation/node_log_view/#_1","text":"这里主要介绍如何查看跨链系统中bitxhub和pier节点的日志信息。","text_tokens":["介绍","pier","。","中","节点","和","跨链","的","系统","这里","日志","信息","主要","查看","如何","bitxhub"],"title":"节点日志查看","title_tokens":["节点","查看","日志"]},{"location":"bitxhub/operation/node_log_view/#bitxhub","text":"如果是在终端前台启动的节点，那么日志会实时打印在终端上，观察其无报错即可； 如果是通过nohup等后台启动的节点，在节点主配置目录的logs文件夹中就是节点的日志文件，打开即可检查日志，一般情况下除了出块，bitxhub节点之间会定时相互 ping 其它节点并返回延时信息，可以简单看到节点集群之间的网络状态。","text_tokens":["会","文件夹","一般","nohup","目录","信息","上","在","无","之间","除了","配置","bitxhub","返回"," ","主","其","看到","；","那么","logs","ping","检查","集群","节点","即可","如果","通过","情况","相互","实时","日志","件夹","打开","文件","网络","就是","其它","状态","。","延时","打印","的","启动","终端","可以","后台","报错","，","简单","出块","中","是","等","下","定时","前台","观察","并"],"title":"BitXHub","title_tokens":["bitxhub"]},{"location":"bitxhub/operation/node_log_view/#pier","text":"如果是在终端前台启动的节点，那么日志会实时打印在终端上，观察其无报错即可； 如果是通过nohup等后台启动的节点，在节点主配置目录的logs文件夹中就是节点的日志文件，打开即可检查日志，","text_tokens":["会","文件夹","nohup","目录","上","在","无","配置"," ","主","其","；","那么","logs","检查","节点","即可","如果","通过","实时","日志","件夹","打开","文件","就是","打印","的","启动","终端","后台","报错","，","中","是","等","前台","观察"],"title":"Pier","title_tokens":["pier"]},{"location":"bitxhub/operation/node_status_check/","text":"节点状态检查 这里主要介绍如何检查跨链系统中bitxhub和pier节点的进程状态。 BitXHub 可以通过ps命令查看节点进程的运行状态，示例如下： ps aux|grep bitxhub 正常情况下可以看到bitxhub节点的进程存活。 Pier 可以通过ps命令查看节点进程的运行状态，示例如下： ps aux|grep pier 正常情况下可以看到pier节点的进程存活。","text_tokens":["介绍","aux","存活","示例","bitxhub"," ","看到","ps","检查","正常","节点","可以","和","跨链","通过","系统","如下","|","grep","主要","查看","情况","状态","。","的","如何","命令","，","中","：","进程","下","这里","pier","运行"],"title":"节点状态检测","title_tokens":["节点","检测","状态"]},{"location":"bitxhub/operation/node_status_check/#_1","text":"这里主要介绍如何检查跨链系统中bitxhub和pier节点的进程状态。","text_tokens":["介绍","pier","状态","。","中","检查","进程","节点","和","跨链","的","系统","这里","主要","如何","bitxhub"],"title":"节点状态检查","title_tokens":["节点","检查","状态"]},{"location":"bitxhub/operation/node_status_check/#bitxhub","text":"可以通过ps命令查看节点进程的运行状态，示例如下： ps aux|grep bitxhub 正常情况下可以看到bitxhub节点的进程存活。","text_tokens":["aux","存活","示例","bitxhub"," ","看到","ps","正常","可以","节点","通过","grep","|","如下","情况","查看","状态","。","的","命令","，","：","进程","下","运行"],"title":"BitXHub","title_tokens":["bitxhub"]},{"location":"bitxhub/operation/node_status_check/#pier","text":"可以通过ps命令查看节点进程的运行状态，示例如下： ps aux|grep pier 正常情况下可以看到pier节点的进程存活。","text_tokens":["aux","存活","示例"," ","看到","ps","正常","可以","节点","通过","grep","|","如下","情况","查看","状态","。","的","命令","，","：","进程","下","pier","运行"],"title":"Pier","title_tokens":["pier"]},{"location":"bitxhub/usage/env/","text":"环境准备 环境准备是部署和使用BitXHub跨链平台的第一步，主要是说明BitXHub及相关组件运行的硬件配置和软件依赖，您需要在部署BitXHub平台之前确认机器满足下述的要求。 硬件 配置 推荐配置 最低配置 CPU 2.4GHz *8核或以上 1.5GHz *4核 内存 16GB或以上 8GB 存储 500G或以上（需要支持扩容） 100G 带宽 10Mb 2Mb 操作系统支持 目前BitXHub支持的操作系统以及对应版本号如下： 操作系统 发行版本 系统架构 RHEL 6或更新 amd64，386 CentOS 6或更新 amd64，386 SUSE 11SP3或更新 amd64，386 Ubuntu 14.04或更新 amd64，386 MacOS 10.8或更新 amd64，386 说明：为了更好的部署安装体验，我们建议您选用CentOS 8.2、Ubuntu 16.04和MacOS 10.15来进行部署安装。 软件依赖 Go环境 BitXHub作为golang项目，需要安装和配置Go环境，您可以在这里下载适用于您的平台的最新版本Go二进制文件： 下载 -（请下载 1.13.x 或更新的稳定版本），也可以下载Go源代码并从源代码进行安装，这里不再赘述。 下载完成后您需要安装Go，可以参考官方文档： 安装Go ，推荐使用默认配置安装即可， 对于Mac OS X 和 Linux操作系统，默认情况下Go会被安装到 /usr/local/go/ ，并且将环境变量GOROOT设置为该路径 /usr/local/go . export GOROOT = /usr/local/go 同时，由于我们可能将在Go中进行一系列编译操作，还需要设置GOPATH等，您可以将以下内容添加到您的 ~/.bashrc 文件中： export GOROOT = /usr/local/go export GOPATH = $HOME /go export PATH = $PATH : $GOPATH /bin: $GOROOT /bin 说明：以上配置均是参考，您可以根据自己的实际情况进行安装配置。 Docker 如果您想使用容器来部署bitxhub平台，则需要提前安装好Docker，推荐安装18.03或更新的稳定版本，具体的安装方法可以参考官方文档： 安装Docker 恭喜您！环境确认和准备完成，接下来可以愉快地开始部署BitXHub平台啦！！！","text_tokens":["8","可能","说明","准备","16gb","386","您","10.15","到","为","部署","10.8","实际","请","x","环境变","bin","1.5","官方","500g","一步","如果","具体","16.04","$","amd64","组件","来","目前","文档","满足","第一步","一系列","赘述","环境","愉快","体验","2mb","：","被","是","作为","这里","并且","环境变量","usr","下来","）","并","会","将",":","操作","下述","啦","一系","在","选用","对于","之前","以下内容","操作系统","硬件","建议","核","bashrc","接下来","相关","系统","稳定","=","/","容器","存储","接下","及","。","local","6","后","的","cpu","centos","！","架构","则","对应","为了","使用","默认","mac","变量","不再","添加","从","发行","同时","11sp3","编译","想","好","支持","100g","golang","完成","linux","建议您","2.4","suse","提前","即可","进行","goroot","如下","软件","文件",".","根据","rhel","安装","机器","第一","ghz","依赖","1.13","os","扩容","适用","要求","18.03","最新","home","gopath","export","*","平台","或","8.2","路径","中","内容","地","等","下","运行","设置","内存","确认","8gb","带宽","恭喜","ubuntu","代码","更新","二进制","以及","go","-","均","以上","配置","4","bitxhub"," ","docker","可以","于","和","跨链","情况","10mb","还","由于","macos","主要","版本号","更好","、","系列","进制","也","需要","我们","path","14.04","方法","项目","最低","版本","下载","，","推荐","自己","（","~","参考","该","以下","开始","源代码"],"title":"环境准备","title_tokens":["准备","环境"]},{"location":"bitxhub/usage/env/#_1","text":"环境准备是部署和使用BitXHub跨链平台的第一步，主要是说明BitXHub及相关组件运行的硬件配置和软件依赖，您需要在部署BitXHub平台之前确认机器满足下述的要求。","text_tokens":["确认","下述","说明","准备","您","在","配置","之前","部署","bitxhub","硬件","一步","和","跨链","相关","主要","软件","机器","第一","组件","依赖","需要","及","。","的","满足","第一步","要求","环境","，","平台","使用","是","运行"],"title":"环境准备","title_tokens":["准备","环境"]},{"location":"bitxhub/usage/env/#_2","text":"配置 推荐配置 最低配置 CPU 2.4GHz *8核或以上 1.5GHz *4核 内存 16GB或以上 8GB 存储 500G或以上（需要支持扩容） 100G 带宽 10Mb 2Mb","text_tokens":["8","内存","带宽","8gb","支持","100g","16gb","以上","配置","4"," ","1.5","2.4","核","500g","10mb","存储","ghz","需要","扩容","cpu","最低","2mb","*","或","推荐","（","）"],"title":"硬件","title_tokens":["硬件"]},{"location":"bitxhub/usage/env/#_3","text":"目前BitXHub支持的操作系统以及对应版本号如下： 操作系统 发行版本 系统架构 RHEL 6或更新 amd64，386 CentOS 6或更新 amd64，386 SUSE 11SP3或更新 amd64，386 Ubuntu 14.04或更新 amd64，386 MacOS 10.8或更新 amd64，386 说明：为了更好的部署安装体验，我们建议您选用CentOS 8.2、Ubuntu 16.04和MacOS 10.15来进行部署安装。","text_tokens":["11sp3","操作","ubuntu","说明","更新","以及","支持","386","选用","10.15","建议您","bitxhub","10.8"," ","部署","操作系统","建议","suse","和","进行","系统","如下","16.04","macos","版本号","amd64","更好","、","rhel","安装","我们","来","。","6","14.04","目前","的","centos","体验","版本","架构","或","，","8.2","对应","为了","：","发行"],"title":"操作系统支持","title_tokens":["支持","操作系统","系统","操作"]},{"location":"bitxhub/usage/env/#_4","text":"","text_tokens":[],"title":"软件依赖","title_tokens":["软件","依赖"]},{"location":"bitxhub/usage/env/#go","text":"BitXHub作为golang项目，需要安装和配置Go环境，您可以在这里下载适用于您的平台的最新版本Go二进制文件： 下载 -（请下载 1.13.x 或更新的稳定版本），也可以下载Go源代码并从源代码进行安装，这里不再赘述。 下载完成后您需要安装Go，可以参考官方文档： 安装Go ，推荐使用默认配置安装即可， 对于Mac OS X 和 Linux操作系统，默认情况下Go会被安装到 /usr/local/go/ ，并且将环境变量GOROOT设置为该路径 /usr/local/go . export GOROOT = /usr/local/go 同时，由于我们可能将在Go中进行一系列编译操作，还需要设置GOPATH等，您可以将以下内容添加到您的 ~/.bashrc 文件中： export GOROOT = /usr/local/go export GOPATH = $HOME /go export PATH = $PATH : $GOPATH /bin: $GOROOT /bin 说明：以上配置均是参考，您可以根据自己的实际情况进行安装配置。","text_tokens":["可能","说明","到","您","为","实际","请","x","环境变","bin","官方","$","文档","一系列","赘述","环境","：","被","是","作为","这里","并且","环境变量","usr","）","并","会","将",":","操作","一系","在","对于","以下内容","操作系统","bashrc","系统","稳定","=","/","。","local","后","的","默认","使用","mac","变量","不再","添加","从","同时","编译","golang","完成","linux","即可","进行","goroot",".","文件","根据","安装","1.13","os","适用","最新","home","gopath","export","或","平台","路径","中","内容","等","下","设置","代码","二进制","更新","go","-","均","以上","配置","bitxhub"," ","可以","于","和","情况","还","由于","系列","进制","也","需要","我们","path","项目","版本","下载","，","推荐","自己","（","~","参考","该","以下","源代码"],"title":"Go环境","title_tokens":["环境","go"]},{"location":"bitxhub/usage/env/#docker","text":"如果您想使用容器来部署bitxhub平台，则需要提前安装好Docker，推荐安装18.03或更新的稳定版本，具体的安装方法可以参考官方文档： 安装Docker 恭喜您！环境确认和准备完成，接下来可以愉快地开始部署BitXHub平台啦！！！","text_tokens":["确认","恭喜","想","好","更新","啦","准备","完成","您","部署","bitxhub"," ","docker","官方","提前","接下来","可以","地","如果","和","具体","稳定","安装","容器","需要","来","接下","方法","的","文档","18.03","环境","愉快","版本","！","或","，","平台","则","推荐","使用","：","参考","下来","开始"],"title":"Docker","title_tokens":["docker"]},{"location":"bitxhub/usage/inter_relay_deploy/","text":"中继跨链 部署文档 中继链用于应用链的跨链管理，以及跨链交易的可信验证与可靠路由，是一种实现IBTP协议的开放许可链。目前BitXHub已经支持中继链之间相互连接，达到跨链交易在中继链之间进行同步，极大地提升了BitXHub的可扩展性。 部署前准备 安装包获取可参照单独部署中继链的文档进行下载和操作，注意中继跨链至少需要部署两套中继链节点环境，其中中继链之间通过特殊配置的pier（我们称之为Upier）相连，由此可知部署中继跨链系统的关键是在于配置好Upier 修改BitXHub配置文件并启动两套节点 这部分内容也可参照单独部署中继链的文档进行部署，待节点集群均打印出bitxhub的LOGO，表示bitxhub集群开始正常工作 Pier配置和部署 部署前准备 安装包获取可参照单独部署跨链网关的文档进行下载和操作，注意每套中继链节点均对应一个UPier，所以也至少需要配置和部署两个Upier节点。 修改配置文件 UPier和常规部署的pier配置大体一致，只是其启动的模式应选择为union，具体配置项如下： #打开pier.toml进行配置修改 [ mode ] type = \"union\" # relay, direct or union ... ... [ mode.union ] connectors = [ \"/ip4/127.0.0.1/tcp/44502/p2p/QmSqkijKLziphdTHpjqx6nRwhogqjhrMv2uGdbga7SqmdN\" , \"/ip4/127.0.0.1/tcp/44501/p2p/QmXdcTWNXBCDyhmoQ2wuf8cwomjccWr2jZpD9jGZcwj8YY\" ] 注意：上面connectors字段需要配置两方的UPier的地址，其中后面那一段是根据pier私钥生成的id，可以使用pier p2p id 命令来获取，这也是union模式区别于中继模式的关键配置。 导入应用链的二进制插件及相关的配置均可参照基础的配置文档进行操作 说明：因为跨链合约和验证规则的部署涉及到不同应用链的细节，且需依赖应用链的安装部署，具体操作请见快速开始手册或使用文档，这里不再赘述 互相注册中继链并启动 编写互相注册中继链的脚本，然后启动Upier（下面以Upier1为例） ##互相注册中继链: ##1 通过UPier1向Relay1注册Relay1: pier --repo=UPier1 appchain register --name Relay1 --type relaychain --desc Relay1 --version 1 --validators UPier1/genesis.json --addr localhost:60011 ##回显： appchain register successfully, id is 0x454e2569dD093D09E5E8B4aB764692780D795C9a ##2 通过UPier1向Relay2注册Relay1: pier --repo=UPier1 appchain register --name Relay1 --type relaychain --desc Relay1 --version 1 --validators UPier1/genesis.json --addr localhost:50011 ##回显： appchain register successfully, id is 0x454e2569dD093D09E5E8B4aB764692780D795C9a ##3 启动UPier: ## 清除下Pier下的store目录 rm -rf UPier1/store ## 启动UPier1 pier --repo=UPier1 start 说明：1. 以上两个注册的步骤，--addr后面的参数分别是两套中继链节点的地址，需要根据实际情况进行更改；2. 另一个Upier2的脚本跟上面的内容基本一致，相互注册的bitxhub地址调换即可，这里不再赘述 运行 pier --repo=UPier start 分别启动两个UPier，其日志显示两个UPier连接成功，两方的bitxhub节点日志上均显示 “appchain register successfully”即正常启动。","text_tokens":["44501","工作","这","基本一致","说明","0x454e2569dd093d09e5e8b4ab764692780d795c9a","协议","提升","许可","准备","到","为","部署","[","实际","请","id","register","]","；","合约","相互","通过","前","具体","genesis","日志","relay","upier","is","见","desc","选择","json","来","展性","清除","这部分","跟","待","相互连接","可信","文档","目前","由此","脚本","中继","达到","常规","因为","环境","称之为","赘述","...","模式","特殊","以","验证","type","version","另","每套","rf","：","至少","是","需","rm","所以","这里","一致","快速","）","获取","并","成功",":","即","操作","”","由此可知","两套","生成","规则","“","在","0.1","mode","具体操作","其","调换","配置文件","节点","互连","上均","相关","系统","or","体操","relaychain","=","注意","/","localhost","关键","互相","项","。","及","导入","#","的","与","启动","那","可","两方","交易","下面","一种","对应","不同","之为","分别","使用","44502","参数","不再","pier","手册","name","appchain","connectors",",","已经","好","一个","且","store","参照","支持","应","链","\"","涉及","实现","后面","细节","50011","ip4","集群","即可","进行","repo","如下","relay1","字段",".","文件","根据","union","安装","区别","依赖","大体一致","qmxdctwnxbcdyhmoq2wuf8cwomjccwr2jzpd9jgzcwj8yy","addr","upier2","连接","出","direct","安装包","基础","命令","可知","私钥","两个","或","扩展性","toml","可扩展性","插件","更改","tcp","内容","开放","2","下","运行","为例","注册","--","在于","start","其中","二进制","以及","部分","validators","目录","-","均","1","以上","ibtp","之间","配置","qmsqkijklziphdthpjqx6nrwhogqjhrmv2ugdbga7sqmdn","bitxhub"," ","3","upier1","扩展","路由","##","正常","地","可以","和","跨链","于","情况","logo","这部","进制","也","用于","需要","我们","大体","只是","编写","步骤","打印","127.0","可靠","p2p","60011","显示","同步","下载","上面","，","修改","单独","（","网关","relay2","基本","然后","successfully","向","地址","回显","应用","管理","了","表示","打开","一段","节点均","极大","相连","开始"],"title":"中继跨链 部署文档","title_tokens":["文档","跨链","中继","部署"," "]},{"location":"bitxhub/usage/inter_relay_deploy/#_1","text":"中继链用于应用链的跨链管理，以及跨链交易的可信验证与可靠路由，是一种实现IBTP协议的开放许可链。目前BitXHub已经支持中继链之间相互连接，达到跨链交易在中继链之间进行同步，极大地提升了BitXHub的可扩展性。","text_tokens":["已经","以及","协议","提升","支持","许可","链","在","ibtp","之间","bitxhub","实现","扩展","路由","地","相互","互连","跨链","进行","用于","展性","。","连接","可靠","相互连接","目前","的","与","中继","达到","交易","同步","一种","验证","，","扩展性","可扩展性","是","开放","应用","管理","了","极大","可信"],"title":"中继跨链 部署文档","title_tokens":["文档","跨链","中继","部署"," "]},{"location":"bitxhub/usage/inter_relay_deploy/#_2","text":"安装包获取可参照单独部署中继链的文档进行下载和操作，注意中继跨链至少需要部署两套中继链节点环境，其中中继链之间通过特殊配置的pier（我们称之为Upier）相连，由此可知部署中继跨链系统的关键是在于配置好Upier","text_tokens":["在于","其中","操作","好","由此可知","两套","参照","链","之间","配置","部署","节点","进行","和","跨链","通过","系统","upier","注意","安装","关键","需要","我们","文档","的","由此","安装包","中继","可","环境","称之为","可知","下载","特殊","，","单独","（","之为","至少","是","pier","）","获取","相连"],"title":"部署前准备","title_tokens":["准备","前","部署"]},{"location":"bitxhub/usage/inter_relay_deploy/#bitxhub","text":"这部分内容也可参照单独部署中继链的文档进行部署，待节点集群均打印出bitxhub的LOGO，表示bitxhub集群开始正常工作","text_tokens":["工作","部分","参照","均","链","部署","bitxhub","集群","节点","正常","进行","logo","这部","也","这部分","待","打印","文档","的","出","中继","可","，","单独","内容","表示","开始"],"title":"修改BitXHub配置文件并启动两套节点","title_tokens":["修改","文件","配置文件","两套","节点","启动","配置","并","bitxhub"]},{"location":"bitxhub/usage/inter_relay_deploy/#pier","text":"","text_tokens":[],"title":"Pier配置和部署","title_tokens":["和","pier","配置","部署"]},{"location":"bitxhub/usage/inter_relay_deploy/#_3","text":"安装包获取可参照单独部署跨链网关的文档进行下载和操作，注意每套中继链节点均对应一个UPier，所以也至少需要配置和部署两个Upier节点。","text_tokens":["操作","一个","参照","链","配置","部署","节点","进行","跨链","和","upier","注意","安装","也","需要","。","文档","的","安装包","中继","可","下载","两个","，","每套","单独","网关","对应","至少","所以","节点均","获取"],"title":"部署前准备","title_tokens":["准备","前","部署"]},{"location":"bitxhub/usage/inter_relay_deploy/#_4","text":"UPier和常规部署的pier配置大体一致，只是其启动的模式应选择为union，具体配置项如下： #打开pier.toml进行配置修改 [ mode ] type = \"union\" # relay, direct or union ... ... [ mode.union ] connectors = [ \"/ip4/127.0.0.1/tcp/44502/p2p/QmSqkijKLziphdTHpjqx6nRwhogqjhrMv2uGdbga7SqmdN\" , \"/ip4/127.0.0.1/tcp/44501/p2p/QmXdcTWNXBCDyhmoQ2wuf8cwomjccWr2jZpD9jGZcwj8YY\" ] 注意：上面connectors字段需要配置两方的UPier的地址，其中后面那一段是根据pier私钥生成的id，可以使用pier p2p id 命令来获取，这也是union模式区别于中继模式的关键配置。 导入应用链的二进制插件及相关的配置均可参照基础的配置文档进行操作 说明：因为跨链合约和验证规则的部署涉及到不同应用链的细节，且需依赖应用链的安装部署，具体操作请见快速开始手册或使用文档，这里不再赘述","text_tokens":["这","说明","到","为","部署","[","请","id","]","合约","具体","relay","upier","见","选择","来","文档","中继","常规","因为","赘述","...","模式","type","验证","：","是","需","这里","一致","快速","获取","操作","生成","规则","0.1","mode","具体操作","其","相关","or","体操","=","注意","/","关键","项","。","及","导入","#","的","启动","那","两方","可","不同","使用","44502","不再","pier","手册","connectors",",","且","参照","应","链","\"","涉及","后面","细节","ip4","进行","如下","字段",".","根据","union","安装","区别","依赖","大体一致","qmxdctwnxbcdyhmoq2wuf8cwomjccwr2jzpd9jgzcwj8yy","direct","基础","命令","私钥","或","toml","插件","tcp","其中","二进制","均","qmsqkijklziphdthpjqx6nrwhogqjhrmv2ugdbga7sqmdn","配置"," ","可以","于","和","跨链","进制","也","需要","大体","只是","127.0","p2p","上面","，","修改","地址","一段","应用","打开","44501","开始"],"title":"修改配置文件","title_tokens":["配置","文件","配置文件","修改"]},{"location":"bitxhub/usage/inter_relay_deploy/#_5","text":"编写互相注册中继链的脚本，然后启动Upier（下面以Upier1为例） ##互相注册中继链: ##1 通过UPier1向Relay1注册Relay1: pier --repo=UPier1 appchain register --name Relay1 --type relaychain --desc Relay1 --version 1 --validators UPier1/genesis.json --addr localhost:60011 ##回显： appchain register successfully, id is 0x454e2569dD093D09E5E8B4aB764692780D795C9a ##2 通过UPier1向Relay2注册Relay1: pier --repo=UPier1 appchain register --name Relay1 --type relaychain --desc Relay1 --version 1 --validators UPier1/genesis.json --addr localhost:50011 ##回显： appchain register successfully, id is 0x454e2569dD093D09E5E8B4aB764692780D795C9a ##3 启动UPier: ## 清除下Pier下的store目录 rm -rf UPier1/store ## 启动UPier1 pier --repo=UPier1 start 说明：1. 以上两个注册的步骤，--addr后面的参数分别是两套中继链节点的地址，需要根据实际情况进行更改；2. 另一个Upier2的脚本跟上面的内容基本一致，相互注册的bitxhub地址调换即可，这里不再赘述 运行 pier --repo=UPier start 分别启动两个UPier，其日志显示两个UPier连接成功，两方的bitxhub节点日志上均显示 “appchain register successfully”即正常启动。","text_tokens":["基本一致","说明","0x454e2569dd093d09e5e8b4ab764692780d795c9a","实际","register","id","；","相互","通过","genesis","日志","upier","is","desc","json","清除","跟","脚本","中继","赘述","version","以","另","type","rf","：","是","rm","这里","一致","成功","）",":","即","”","两套","“","其","调换","节点","上均","relaychain","=","/","localhost","互相","。","的","启动","两方","下面","分别","参数","不再","pier","name","appchain",",","一个","store","链","后面","50011","即可","进行","repo","relay1",".","根据","upier2","addr","连接","两个","更改","内容","2","下","运行","为例","注册","--","start","validators","目录","-","以上","bitxhub"," ","3","upier1","##","正常","情况","需要","编写","步骤","60011","显示","上面","，","基本","（","relay2","然后","successfully","向","地址","回显","1"],"title":"互相注册中继链并启动","title_tokens":["注册","互相","启动","链","中继","并"]},{"location":"bitxhub/usage/overall_description/","text":"整体说明 这篇文档是对BitXHub跨链系统部署的整体说明，主要是介绍BitXHub跨链系统的一般部署流程和部署架构。 1. 环境准备 环境准备是部署和使用BitXHub跨链平台的第一步，主要是说明BitXHub及相关组件运行的硬件配置和软件依赖，您需要在部署BitXHub平台之前确认服务器满足硬件和软是否件的要求，具体信息请查看 环境准备 文档。 2. 单中继链部署架构 一般来说，单中继链架构适用于大多数部署场景，建议您使用此种部署架构来体验BitXHub跨链系统。如下图所示，部署完bitxhub节点集群（也可以是solo模式的单机节点），两条或多条应用链上部署好跨链合约，然后通过各自的跨链网关接入到中继链中，完成跨链系统的搭建。 在明晰了部署架构之后，这里再说明下部署的一般流程： 首先需要部署BitXHub中继链节点，这是搭建跨链系统的基础，可以参考单中继链部署架构目录下的 中继链部署 文档； 然后是部署Pier跨链网关节点，这是接入应用链的必要组件，其中重要的流程有跨链合约部署、网关/插件的配置修改、应用链注册和验证规则部署，可以参考单中继链部署架构目录下的 跨链网关部署 文档。 3. 跨链网关直连部署架构 跨链网关直连部署架构是指不使用中继链，两方的应用链通过跨链网关与对方直接连接，部署结构如下图所示，除了无需部署中继链节点之外，部署的流程与上一章基本一致，具体的部署流程可以参考 跨链网关直连模式部署 文档。","text_tokens":["基本一致","重要","单","说明","准备","信息","到","您","上","网","部署","之外","请","流程","不","无需","；","合约","一步","通过","具体","查看","直连","场景","组件","来","是否","多数","文档","满足","第一步","中继","环境","体验","图","所示","模式","验证","大多","单机","：","是","这里","指","一致","）","关节点","一般","结构","明晰","各自","规则","在","之前","硬件","建议","链中","务器","节点","相关","系统","两条","链上","这是","有","/","。","及","的","与","两方","架构","使用","pier","介绍","再","好","此种","必要","完成","链","solo","建议您","除了","一章","集群","关节","如下",".","软件","第一","接入","依赖","搭建","连接","适用","要求","基础","首先","或","平台","插件","2","下","运行","确认","注册","其中","目录","直接","对","配置","bitxhub","对方"," ","多条","3","于","可以","和","跨链","之后","主要","、","完","软","大多数","也","整体","需要","来说","这篇","一般来说","服务器","件","，","修改","网关","（","服务","基本","然后","参考","应用","了","1"],"title":"整体说明","title_tokens":["说明","整体"]},{"location":"bitxhub/usage/overall_description/#_1","text":"这篇文档是对BitXHub跨链系统部署的整体说明，主要是介绍BitXHub跨链系统的一般部署流程和部署架构。","text_tokens":["一般","介绍","说明","对","部署","bitxhub","流程","和","跨链","系统","主要","整体","。","这篇","文档","的","架构","，","是"],"title":"整体说明","title_tokens":["说明","整体"]},{"location":"bitxhub/usage/overall_description/#1","text":"环境准备是部署和使用BitXHub跨链平台的第一步，主要是说明BitXHub及相关组件运行的硬件配置和软件依赖，您需要在部署BitXHub平台之前确认服务器满足硬件和软是否件的要求，具体信息请查看 环境准备 文档。","text_tokens":["确认","说明","准备","信息","您","在","配置","之前","部署","bitxhub"," ","请","硬件","务器","一步","和","跨链","相关","具体","主要","软件","查看","软","第一","组件","依赖","需要","及","。","是否","文档","的","满足","第一步","要求","环境","服务器","件","，","平台","服务","使用","是","运行"],"title":"1. 环境准备","title_tokens":["准备",".","环境","1"," "]},{"location":"bitxhub/usage/overall_description/#2","text":"一般来说，单中继链架构适用于大多数部署场景，建议您使用此种部署架构来体验BitXHub跨链系统。如下图所示，部署完bitxhub节点集群（也可以是solo模式的单机节点），两条或多条应用链上部署好跨链合约，然后通过各自的跨链网关接入到中继链中，完成跨链系统的搭建。 在明晰了部署架构之后，这里再说明下部署的一般流程： 首先需要部署BitXHub中继链节点，这是搭建跨链系统的基础，可以参考单中继链部署架构目录下的 中继链部署 文档； 然后是部署Pier跨链网关节点，这是接入应用链的必要组件，其中重要的流程有跨链合约部署、网关/插件的配置修改、应用链注册和验证规则部署，可以参考单中继链部署架构目录下的 跨链网关部署 文档。","text_tokens":["重要","单","说明","到","网","部署","流程","；","合约","通过","场景","组件","来","多数","文档","中继","体验","图","所示","模式","验证","大多","单机","：","是","这里","）","关节点","一般","明晰","各自","规则","在","建议","链中","节点","系统","两条","链上","这是","有","/","。","的","架构","使用","pier","再","好","此种","必要","完成","链","solo","建议您","集群","关节","如下","接入","搭建","适用","基础","首先","或","插件","下","注册","其中","目录","配置","bitxhub"," ","多条","于","可以","和","跨链","之后","、","完","大多数","也","需要","来说","一般来说","，","修改","网关","（","然后","参考","应用","了"],"title":"2. 单中继链部署架构","title_tokens":["架构","单","2","链","中继",".","部署"," "]},{"location":"bitxhub/usage/overall_description/#3","text":"跨链网关直连部署架构是指不使用中继链，两方的应用链通过跨链网关与对方直接连接，部署结构如下图所示，除了无需部署中继链节点之外，部署的流程与上一章基本一致，具体的部署流程可以参考 跨链网关直连模式部署 文档。","text_tokens":["结构","基本一致","直接","上","链","除了","部署","对方","之外"," ","不","无需","流程","一章","节点","可以","通过","跨链","如下","具体","直连","。","连接","文档","的","与","中继","两方","图","所示","模式","架构","，","网关","基本","使用","是","参考","应用","指","一致"],"title":"3. 跨链网关直连部署架构","title_tokens":["部署","3","架构","网关","跨链",".","直连"," "]},{"location":"bitxhub/usage/status_verification/","text":"系统验证和检查 在部署完跨链系统之后，通常需要检查或监控系统的运行状态，这里提供一些检查和监控BitXHub系统的方法。 节点进程状态验证 可以通过ps命令查看节点进程的运行状态，示例如下： ps aux|grep bitxhub ps aux|grep pier 详细过程请参考 节点状态检查 。 节点日志检查 如果是在终端前台启动的节点，那么日志会实时打印在终端上，观察其无报错即可； 如果是通过nohup等后台启动的节点，在节点主配置目录的logs文件夹中就是节点的日志文件，打开即可检查日志，一般情况下除了出块，bitxhub节点之间会定时相互 ping 其它节点并返回延时信息，可以简单看到节点集群之间的网络状态。","text_tokens":["aux","示例","上","信息","部署","请","；","那么","logs","检查","相互","通过","grep","如果","日志","查看","就是","其它","完跨","后台","验证","监控","简单","：","详细","是","通常","这里","并","会","一般","在","无","其","节点","系统验证","系统","件夹","一些","状态","。","延时","的","启动","报错","出块","进程","pier","文件夹","链","除了","返回","主","看到","前台","ps","集群","即可","如下","过程","文件","提供","命令","或","中","等","下","终端","运行","检查和","nohup","目录","之间","配置","bitxhub"," ","ping","可以","情况","和","|","实时","之后","网络","需要","打印","方法","，","参考","定时","打开","观察"],"title":"系统验证与交易流程体验","title_tokens":["验证","流程","系统验证","与","系统","交易","体验"]},{"location":"bitxhub/usage/status_verification/#_1","text":"在部署完跨链系统之后，通常需要检查或监控系统的运行状态，这里提供一些检查和监控BitXHub系统的方法。","text_tokens":["检查和","在","链","部署","bitxhub","检查","系统","之后","一些","需要","状态","完跨","。","方法","的","提供","，","或","监控","通常","这里","运行"],"title":"系统验证和检查","title_tokens":["验证","检查","系统验证","和","系统"]},{"location":"bitxhub/usage/status_verification/#_2","text":"可以通过ps命令查看节点进程的运行状态，示例如下： ps aux|grep bitxhub ps aux|grep pier 详细过程请参考 节点状态检查 。","text_tokens":["aux","示例","bitxhub"," ","请","ps","检查","可以","节点","通过","grep","|","如下","过程","查看","状态","。","的","命令","，","：","进程","详细","参考","pier","运行"],"title":"节点进程状态验证","title_tokens":["节点","验证","状态","进程"]},{"location":"bitxhub/usage/status_verification/#_3","text":"如果是在终端前台启动的节点，那么日志会实时打印在终端上，观察其无报错即可； 如果是通过nohup等后台启动的节点，在节点主配置目录的logs文件夹中就是节点的日志文件，打开即可检查日志，一般情况下除了出块，bitxhub节点之间会定时相互 ping 其它节点并返回延时信息，可以简单看到节点集群之间的网络状态。","text_tokens":["会","文件夹","一般","nohup","目录","信息","上","在","无","之间","除了","配置","bitxhub","返回"," ","主","其","看到","；","那么","logs","ping","检查","集群","节点","即可","如果","通过","情况","相互","实时","日志","件夹","打开","文件","网络","就是","其它","状态","。","延时","打印","的","启动","终端","可以","后台","报错","，","简单","出块","中","是","等","下","定时","前台","观察","并"],"title":"节点日志检查","title_tokens":["节点","检查","日志"]},{"location":"bitxhub/usage/direct_mode_pier/pier_direct_mode_deploy/","text":"跨链网关直连模式部署 跨链网关Pier能够支持跨链消息格式转换、跨链消息的路由、跨链操作的调用等核心功能，不仅保证不同格式的跨链消息能够安全可信的到达目标应用链，而且保证了跨链交易异常情况下来源链的安全。跨链网关为区块链互联形成网络提供了便捷的接入方式，旨在降低跨链互联的使用成本。在之前的文档中介绍了中继模式的pier安装步骤，下面介绍直连模式下pier的安装步骤。请注意，pier直连不依赖于中继链节点，所以本文档不赘述bitxhub的部署了。 安装包获取 源码安装 跨链网关启动的话需要应用链插件，所以从源码安装的话，还需要编译相应的应用链插件的二进制。 # 编译跨链网关本身 cd $HOME git clone https://github.com/meshplus/pier.git cd pier make prepare && make install # 编译Fabric cd $HOME git clone https://github.com/meshplus/pier-client-fabric.git cd pier-client-fabric make fabric1.4 # 编译以太坊私链插件 cd $HOME git clone https://github.com/meshplus/pier-client-ethereum.git cd pier-client-ethereum make eth # 插件执行make的编译之后，都会在项目目录的之下的build目录生成相应的二进制文件 编译跨链网关步骤会在 $GOPATH/bin 下生成 pier 二进制，运行下面的命令查看是否安装成功： # $GOPATH/bin需要在PATH目录下 pier version 如果正常安装会打印出类似下面的说明 Pier version: dev-release-1.6-1b5b79f App build date: 2021-12-01T17:50:14 System version: darwin/amd64 Golang version: go1.15.13 二进制安装 没有现有编译环境的用户，也可以在GitHub开源仓库下载编译好的二进制。 Pier二进制安装 ：, 根据需要的版本进行下载即可。 网关插件安装： pier-client-fabric 和 pier-client-ethereum 的应用链插件的二进制。 注意：网关与网关插件对应大版本号一致即可。如pier v1.6.x对应pier-client-ethereum v1.6.x。 修改配置文件 修改pier配置 在进行应用链注册、验证规则部署等步骤之前，需要初始化跨链网关的配置目录 #以用户目录下的pier为例 pier --repo = ~/pier1 init 该命令会生成跨链网关的一些基础配置文件模板，使用 tree 命令可查看目录信息： tree -L 1 ~/.pier1 ├── api ├── certs ├── key.json ├── node.priv └── pier.toml 1 directory, 4 files 导入插件二进制（hyperchain的插件二进制和配置文件示例需要内部授权） mkdir -p ~/.pier1/plugins cp fabric-client-1.4 ~/.pier1/plugins pier.toml 文件描述链跨链网关启动的必要配置，具体的配置项和说明如下： 配置项 说明 [port] http、grpc服务端口 [log] 日志输出相关设置 [bitxhub] 连接的bitxhub的IP地址、验证人地址 [appchain] 对接的应用链的基础配置信息 主要需要修改的部分是端口信息、中继链的信息、应用链的信息 修改端口信息 [port] // 如果不冲突的话，可以不用修改 http = 44544 pprof = 44555 修改pier配置文件下的api文件信息 # 修改为上一步配置的http的端口号 http://localhost:<http port>/v1/ 修改跨链网关信息 [mode] type = \"direct\" # relay or direct ... ... [mode.direct] peers = [\"/ip4/127.0.0.1/tcp/3003/p2p/QmXfAngyiAkb44ofp1633Ak4nKTKWaBhmQbvE1tsPJzQTX\", \"/ip4/127.0.0.1/tcp/3004/p2p/QmWLrVrbJxkZxBZsr2UmNEz7eLgCExW6KTax89wDRMXaWw\"] 注意：上面peers字段需要配置两方的pier的p2p地址，其中后面那一段是根据pier私钥生成的id，可以使用 pier p2p id 命令来获取，这也是直连模式区别于中继模式的关键配置。 修改应用链信息 [appchain] // 所连接的应用链对应的Plugin文件在跨链网关配置文件夹下的相对路径 plugin = \"fabric-client-1.4\" // 所连接的应用链的配置文件夹在跨链网关配置文件夹下的相对路径 config = \"fabric\" 网关pier适配以太坊插件的配置仿照上述步骤即可。 修改fabric插件配置 Fabric插件配置的模板在 pier-client-fabric 项目中，并且已经在GitHub上进行开源，所以直接在GitHub上下载代码即可 # 转到pier-client-fabric项目路径下 git clone https://github.com/meshplus/pier-client-fabric.git && cd pier-client-fabric cp ./config $HOME /.pier1/fabric 配置目录结构 ├── crypto-config/ ├── config.yaml ├── fabric.toml └── fabric.validators 主要修改Fabric网络配置，验证证书，跨链合约设置： Fabric证书配置 启动Fabric网络时，会生成所有节点（包括Order、peer等）的证书信息，并保存在 crypto-config文件夹中，Fabric插件和Fabric交互时需要用到这些证书。 # 复制你所部署的Fabric所产生的crypto-config文件夹 cp -r /path/to/crypto-config $HOME /.pier1/fabric/ # 复制Fabric上验证人证书 cp $HOME /.pier1/fabric/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp/signcerts/peer1.org2.example.com-cert.pem $HOME /.pier1/fabric/fabric.validators 修改Plugin配置文件 config.yaml config.yaml 文件记录的Fabric网络配置（如果你是按照你自己的网络拓扑部署的Fabric，用你的网络拓扑配置文件替换这个样例文件），需要使用绝对路径，把所有的路径都修改为 crypto-config 文件夹所在的绝对路径，$USER指代当前用户名 path : { CONFIG_PATH } /fabric/crypto-config => path : /home/$USER/.pier/fabric/crypto-config 替换为你部署的Fabric网络的拓扑设置文件即可，同时需要修改所有的Fabric 的IP地址，如： url : grpcs://localhost:7050 => url : grpcs://10.1.16.48:7050 修改Plugin配置文件 fabric.toml 配置项和说明： 配置项 说明 addr Fabric 区块链所在的服务器地址和端口 event_filter 跨链合约中抛出的跨链事件的名称 username Fabric用户名称 ccid 所部署的跨链合约名称 channel_id 部署的跨链合约所在的channel org 部署的跨链合约所在的org 示例配置 addr = \"localhost:7053\" // 若Fabric部署在服务器上，该为服务器地址 event_filter = \"interchain-event-name\" username = \"Admin\" ccid = \"broker\" // 若部署跨链broker合约名字不是broker需要修改 channel_id = \"mychannel\" org = \"org2\" 修改Plugin配置文件fabric.validators fabric.validators 是Fabric验证人的证书，配置示例： -----BEGIN CERTIFICATE----- MIICKTCCAc+gAwIBAgIRAIBO31aZaSZoEYSy2AJuhJcwCgYIKoZIzj0EAwIwczEL MAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG cmFuY2lzY28xGTAXBgNVBAoTEG9yZzIuZXhhbXBsZS5jb20xHDAaBgNVBAMTE2Nh Lm9yZzIuZXhhbXBsZS5jb20wHhcNMjAwMjA1MDgyMjAwWhcNMzAwMjAyMDgyMjAw WjBqMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMN U2FuIEZyYW5jaXNjbzENMAsGA1UECxMEcGVlcjEfMB0GA1UEAxMWcGVlcjEub3Jn Mi5leGFtcGxlLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABG3jszFPTbGm dAYg2BxmHMTDKfQReNw3p9ttMK130qF5lQo5zLBG8Sa3viOCLnvjjg6A/P+yKnwv isI/jEVE8T2jTTBLMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMCsGA1Ud IwQkMCKAIMVL+daK7nMGr2/AQIXTSPFkdd3UiPVDkWtkh5ujnalEMAoGCCqGSM49 BAMCA0gAMEUCIQDMYOQiYeMiQZTxlRkj/3/jjYvwwdCcX5AWuFmraiHkugIgFkX/ 6uiTSD0lz8P+wwlLf24cIABq2aZyi8q4gj0YfwA= -----END CERTIFICATE----- 修改ethereum插件配置 ethereum插件配置的模板在 pier-client-ethereum 项目中，并且已经在GitHub上进行开源，所以直接在GitHub上下载代码即可 # 转到pier-client-ethereum项目路径下 git clone https://github.com/meshplus/pier-client-ethereum.git && cd pier-client-ethereum cp ./config $HOME /.pier2/ether 配置目录结构 ├── account.key ├── broker.abi ├── data_swapper.abi ├── ether.validators ├── ethereum.toml ├── password ├── pier.toml // 仅作参考，无需配置 ├── transfer.abi └── validating.wasm **注意：**插件目录下的pier.toml仅作参考，系统使用的配置文件是位于pier的配置文件目录下的pier.toml。 主要修改账户信息、abi，跨链合约设置。 以太坊账户配置 启动以太坊网络时，在指定的 datadir 目录下，将 keystore 的账户信息拷贝到account.key中。 cp <eth_datadir>/keystore/<account> $HOME/.pier2/ether/config/account.key **修改Plugin配置文件ethereum.toml ** 配置项和说明： 配置项 说明 addr ethereum 区块链所在的服务器地址和端口 name 以太坊链名称 contract_address 部署的broker合约地址 key_path 账户信息 password 账户密码 min_confirm 最低确认区块数 contract_abi 部署的业务合约地址及所对应的abi 示例配置 [ether] addr = \"ws://127.0.0.1:8546\" // 若部署在服务器上，该为服务器地址 name = \"appchain2\" contract_address = \"0xC8C086200f92c9226b42079eCB3137eFc8752801\" // 该链部署的broker合约地址 key_path = \"account.key\" // 确保提前更改了account.key password = \"password\" min_confirm = 1 [contract_abi] 0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f=\"transfer.abi\" // 替换为该链部署的业务合约地址 修改Plugin配置文件abi信息 broker合约和业务合约如果使用的是插件的 example 文件下的合约，则不用更改相关abi内容。如果使用自定义的broker合约或业务合约，请替换为对应的abi文件。 启动程序 #以用户目录下的pier1为例 pier --repo=~/pier1 start #以用户目录下的pier2为例 pier --repo=~/pier2 start 观察日志信息没有报错信息，pier启动成功 说明：1. 因为跨链合约和验证规则的部署涉及到不同应用链的细节，且需依赖应用链的安装部署，具体操作请见快速开始手册或使用文档，这里不再赘述。2. 本文是以一方的跨链网关为例进行部署，而另一方的跨链网关的部署与之基本一样，这里不再赘述。 直连模式下，两边的跨链网关需要相互注册同时部署验证规则 idA = $( pier --repo ~/pier1 id ) idB = $( pier --repo ~/pier2 id ) pier --repo ~/pier1 client register --pier_id ${ idB } --name fab --type fabric --desc simple --version 1 --validators ~/pier1/fabric/fabric.validators --consensusType raft pier --repo ~/pier2 client register --pier_id ${ idA } --name eth --type ethereum --desc simple --version 1 --validators ~/pier2/ethereum/ether.validators --consensusType raft pier --repo ~/pier1 client rule --pier_id ${ idB } --path ~/pier1/fabric/rule.wasm pier --repo ~/pier2 client rule --pier_id ${ idA } --path ~/pier2/ethereum/rule.wasm 完成上述布置后，跨链网关直连模式下部署就已经完成，两边的应用链可以进行跨链操作","text_tokens":["eth","说明","14","url","信息","上","为","端口","不","13","cert","合约","directory","如果","$","区块","位于","直连","validating","中继","以","户名","_","ccid","qmxfangyiakb44ofp1633ak4nktkwabhmqbve1tspjzqtx","用","需","所以","rule","并","用户名","操作","指代","仿照","而且","wqeawihgdambgnvhrmbaf8eajaamcsga1ud","mkdir","务器","ws","log","dayg2bxmhmtdkfqrenw3p9ttmk130qf5lqo5zlbg8sa3vioclnvjjg6a","=","simple","项","另一方","。","clone","peer","启动","可","wasm","不同","system","dak7nmgr2","开始","fabric1.4",",","能够","编译","好","darwin","完成","1b5b79f","即可","两边","certs","产生","1.4","区别","依赖","拷贝到","出","旨在","或","插件","0xc8c086200f92c9226b42079ecb3137efc8752801","prepare","中","tcp","tree","https","运行","设置","确认","start","com","validators","client","-","安全","ida","相对","bitxhub"," ","3","路由","和","绝对","pier2","之后","org","执行","go1.15","p","key","lm9yzziuzxhhbxbszs5jb20whhcnmjawmja1mdgymjawwhcnmzawmjaymdgymjaw","最低","r","服务器","下载","自己","（","保存","&&","44555","业务","若","账户","拷贝","broker","3003","这","异常情况","abi","到","jeve8t2jttblma4ga1uddweb","部署","[","用户","keystore","x","register","bin","plugin","consensustype","ip地址","raft","绝对路径","l","amd64","查看","名字","data","一样","makga1uebhmcvvmxezarbgnvbagtcknhbglmb3juawexfjaubgnvbactdvnhbibg","对接","plugins","保证","文档","因为","：","是","这里","成功","一致","mychannel","priv","pem","wjbqmqswcqydvqqgewjvuzetmbega1uecbmkq2fsawzvcm5pytewmbqga1uebxmn","appchain2",":","api","50","规则","证书","在","mode","certificate","interchain","transfer","具体操作","dev","指定","之","类似","or","系统","account","注意","peer1","定义","转到","一些","yaml","导入","ethereum","后","的","私链","没有","与","qmwlrvrbjxkzxbzsr2umnez7elgcexw6ktax89wdrmxaww","交易","则","不用","对应","布置","idb","使用","yknwv","end","而","name","所","同时","文件夹","坊","swapper","password","上述",">","└","调用","后面","+","本","文件目录","repo","字段","16.48","常情","接入","包括","连接","当前","44544","direct","app","命令","私钥","config","更改","路径","内容","网络拓扑","github","crypto","其中","到达","配置","抛出","miicktccac","密码","cd","iwqkmckaimvl","记录","情况","还","冲突","grpc","peers","也","人","bamca0gameuciqdmyoqiyemiqztxlrkj","date","项目","p2p","这个","上面","修改","git","复制","地址","初始化","口号","7050","可信","1","ether","授权","请","id","无需","如","互联","cp","to","相互","事件","具体","日志","relay","desc","json","来","是否","名称","赖于","赘述","version","event","验证","10.1","confirm","目标","address","所在","）","获取","2021","会","程序","之前","7053","描述","init","体操","/","关键","及","#","两方","成本","下面","报错","signcerts","pier","用到","介绍","appchain","已经","且","必要","支持","相应","异常","fab","golang","isi","链","\"","pier1","files","pprof","user","依赖于","aqixtspfkdd3uipvdkwtkh5ujnalemaogccqgsm49","3004","-----","开源","ip4",")","不仅","文件","wwllf24ciabq2azyi8q4gj0yfwa","提供","home","基础","自定义","toml","等","admin","数","功能","order","注册","--","部分","4","格式","可以","于","username","主要","进制","时","需要","release","打印","本文","u2fuiezyyw5jaxnjbzenmasga1uecxmecgvlcjefmb0ga1ueaxmwcgvlcjeub3jn","核心","基本","~","按照","自定","参考","来源","应用","一段","相对路径","观察","把","就","拓扑","模板","示例","适配","01t17","]","begin","}","example","一步","1.6","见","(","所有","jjyvwwdccx5awufmraihkugigfkx","输出","环境","...","模式","type","并且","快速","将","结构","生成","8546","0.1","├","配置文件","peerorganizations","节点","grpcs","相关","形成","port","件夹","确保","localhost","之下","那","不是","6uitsd0lz8p","该链","<","filter","端口号","不再","手册","从","make","现有","便捷","contract","降低","涉及","方式","内部","细节","消息","fabric","v1.6","你","提前","进行","如下",".","根据","安装","build","都","仓库","这些","addr","datadir","node","的话","安装包","gopath","样例","0xa5dd12e27ee5e79ce0b50adb376414351c8eea5f","*","min","2","一方","下","为例","12","仅作","代码","二进制","目录","交互","直接","─","meshplus","hyperchain","cmfuy2lzy28xgtaxbgnvbaoteg9yzziuzxhhbxbszs5jb20xhdaabgnvbamte2nh","正常","跨链","大","网络","、","版本号","初始","install","步骤","msp","gawibagiraibo31azaszoeysy2ajuhjcwcgyikozizj0eawiwczel","127.0","path","channel","转换","http","以太","本身","版本","v1","替换","，","网关","服务","org2","mi5legftcgxllmnvbtbzmbmgbyqgsm49agegccqgsm49aweha0iabg3jszfptbgm","了","源码","该","{"],"title":"跨链网关直连模式部署","title_tokens":["模式","网关","跨链","直连","部署"]},{"location":"bitxhub/usage/direct_mode_pier/pier_direct_mode_deploy/#_1","text":"跨链网关Pier能够支持跨链消息格式转换、跨链消息的路由、跨链操作的调用等核心功能，不仅保证不同格式的跨链消息能够安全可信的到达目标应用链，而且保证了跨链交易异常情况下来源链的安全。跨链网关为区块链互联形成网络提供了便捷的接入方式，旨在降低跨链互联的使用成本。在之前的文档中介绍了中继模式的pier安装步骤，下面介绍直连模式下pier的安装步骤。请注意，pier直连不依赖于中继链节点，所以本文档不赘述bitxhub的部署了。","text_tokens":["介绍","操作","能够","异常情况","便捷","到达","支持","异常","安全","链","而且","降低","在","为","之前","bitxhub","部署","格式","请","调用","不","方式","依赖于","互联","路由","消息","本","节点","不仅","情况","跨链","形成","网络","、","常情","区块","注意","直连","安装","接入","依赖","步骤","。","转换","保证","文档","的","提供","中继","赖于","成本","赘述","交易","下面","模式","旨在","，","核心","不同","网关","目标","使用","中","等","来源","应用","了","下","所以","pier","功能","可信"],"title":"跨链网关直连模式部署","title_tokens":["模式","网关","跨链","直连","部署"]},{"location":"bitxhub/usage/direct_mode_pier/pier_direct_mode_deploy/#_2","text":"","text_tokens":[],"title":"安装包获取","title_tokens":["获取","安装包","安装"]},{"location":"bitxhub/usage/direct_mode_pier/pier_direct_mode_deploy/#_3","text":"跨链网关启动的话需要应用链插件，所以从源码安装的话，还需要编译相应的应用链插件的二进制。 # 编译跨链网关本身 cd $HOME git clone https://github.com/meshplus/pier.git cd pier make prepare && make install # 编译Fabric cd $HOME git clone https://github.com/meshplus/pier-client-fabric.git cd pier-client-fabric make fabric1.4 # 编译以太坊私链插件 cd $HOME git clone https://github.com/meshplus/pier-client-ethereum.git cd pier-client-ethereum make eth # 插件执行make的编译之后，都会在项目目录的之下的build目录生成相应的二进制文件 编译跨链网关步骤会在 $GOPATH/bin 下生成 pier 二进制，运行下面的命令查看是否安装成功： # $GOPATH/bin需要在PATH目录下 pier version 如果正常安装会打印出类似下面的说明 Pier version: dev-release-1.6-1b5b79f App build date: 2021-12-01T17:50:14 System version: darwin/amd64 Golang version: go1.15.13","text_tokens":["eth","说明","14","01t17","13","bin","1.6","如果","$","amd64","查看","是否","version","：","所以","成功","2021","会",":","生成","50","在","dev","类似","/","之下","。","clone","ethereum","#","的","私链","启动","下面","system","pier","从","fabric1.4","make","坊","编译","相应","darwin","golang","链","1b5b79f","fabric",".","文件","安装","build","都","的话","出","app","home","命令","gopath","源码","插件","prepare","下","https","运行","github","12","com","二进制","目录","client","-","meshplus"," ","cd","正常","跨链","还","之后","进制","执行","install","需要","go1.15","步骤","release","date","打印","path","项目","以太","本身","，","网关","git","应用","&&"],"title":"源码安装","title_tokens":["源码","安装"]},{"location":"bitxhub/usage/direct_mode_pier/pier_direct_mode_deploy/#_4","text":"没有现有编译环境的用户，也可以在GitHub开源仓库下载编译好的二进制。 Pier二进制安装 ：, 根据需要的版本进行下载即可。 网关插件安装： pier-client-fabric 和 pier-client-ethereum 的应用链插件的二进制。 注意：网关与网关插件对应大版本号一致即可。如pier v1.6.x对应pier-client-ethereum v1.6.x。","text_tokens":["github",",","现有","编译","好","二进制","client","-","在","链"," ","用户","x","如","fabric","开源","v1.6","可以","即可","进行","和","大","版本号","根据","注意",".","安装","进制","也","需要","。","仓库","ethereum","的","与","没有","环境","版本","下载","，","对应","网关","插件","：","一致","应用","pier"],"title":"二进制安装","title_tokens":["进制","二进制","安装"]},{"location":"bitxhub/usage/direct_mode_pier/pier_direct_mode_deploy/#_5","text":"","text_tokens":[],"title":"修改配置文件","title_tokens":["配置","文件","配置文件","修改"]},{"location":"bitxhub/usage/direct_mode_pier/pier_direct_mode_deploy/#pier","text":"在进行应用链注册、验证规则部署等步骤之前，需要初始化跨链网关的配置目录 #以用户目录下的pier为例 pier --repo = ~/pier1 init 该命令会生成跨链网关的一些基础配置文件模板，使用 tree 命令可查看目录信息： tree -L 1 ~/.pier1 ├── api ├── certs ├── key.json ├── node.priv └── pier.toml 1 directory, 4 files 导入插件二进制（hyperchain的插件二进制和配置文件示例需要内部授权） mkdir -p ~/.pier1/plugins cp fabric-client-1.4 ~/.pier1/plugins pier.toml 文件描述链跨链网关启动的必要配置，具体的配置项和说明如下： 配置项 说明 [port] http、grpc服务端口 [log] 日志输出相关设置 [bitxhub] 连接的bitxhub的IP地址、验证人地址 [appchain] 对接的应用链的基础配置信息 主要需要修改的部分是端口信息、中继链的信息、应用链的信息 修改端口信息 [port] // 如果不冲突的话，可以不用修改 http = 44544 pprof = 44555 修改pier配置文件下的api文件信息 # 修改为上一步配置的http的端口号 http://localhost:<http port>/v1/ 修改跨链网关信息 [mode] type = \"direct\" # relay or direct ... ... [mode.direct] peers = [\"/ip4/127.0.0.1/tcp/3003/p2p/QmXfAngyiAkb44ofp1633Ak4nKTKWaBhmQbvE1tsPJzQTX\", \"/ip4/127.0.0.1/tcp/3004/p2p/QmWLrVrbJxkZxBZsr2UmNEz7eLgCExW6KTax89wDRMXaWw\"] 注意：上面peers字段需要配置两方的pier的p2p地址，其中后面那一段是根据pier私钥生成的id，可以使用 pier p2p id 命令来获取，这也是直连模式区别于中继模式的关键配置。 修改应用链信息 [appchain] // 所连接的应用链对应的Plugin文件在跨链网关配置文件夹下的相对路径 plugin = \"fabric-client-1.4\" // 所连接的应用链的配置文件夹在跨链网关配置文件夹下的相对路径 config = \"fabric\" 网关pier适配以太坊插件的配置仿照上述步骤即可。","text_tokens":["口号","3003","模板","这","说明","信息","示例","上","端口","授权","为","部署","[","用户","适配","id","不","]","cp","plugin","ip地址","l","一步","directory","如果","具体","日志","relay","查看","直连","json","对接","来","plugins","输出","中继","以","...","模式","验证","type","：","是","qmxfangyiakb44ofp1633ak4nktkwabhmqbve1tspjzqtx","）","priv","获取","会",":","api","生成","规则","仿照","在","0.1","mode","├","之前","mkdir","配置文件","描述","log","init","port","相关","or","件夹","=","注意","/","localhost","关键","一些","项","。","导入","#","的","启动","那","可","两方","qmwlrvrbjxkzxbzsr2umnez7elgcexw6ktax89wdrmxaww","<","不用","对应","端口号","使用","pier","所","文件夹","坊","appchain",",","上述",">","必要","└","链","\"","pier1","files","pprof","内部","后面","3004","fabric","ip4","即可","进行","repo","certs","如下","字段",".","文件","根据","1.4","区别","连接","node","的话","44544","direct","基础","命令","私钥","config","toml","插件","路径","tcp","等","tree","下","设置","为例","注册","--","其中","二进制","部分","目录","client","-","配置","4","─","bitxhub"," ","相对","hyperchain","可以","于","和","跨链","冲突","、","主要","grpc","进制","peers","初始","人","需要","也","步骤","p","127.0","key","p2p","http","以太","v1","上面","，","修改","网关","~","（","服务","地址","应用","初始化","一段","相对路径","44555","该","1"],"title":"修改pier配置","title_tokens":["pier","配置","修改"]},{"location":"bitxhub/usage/direct_mode_pier/pier_direct_mode_deploy/#fabric","text":"Fabric插件配置的模板在 pier-client-fabric 项目中，并且已经在GitHub上进行开源，所以直接在GitHub上下载代码即可 # 转到pier-client-fabric项目路径下 git clone https://github.com/meshplus/pier-client-fabric.git && cd pier-client-fabric cp ./config $HOME /.pier1/fabric 配置目录结构 ├── crypto-config/ ├── config.yaml ├── fabric.toml └── fabric.validators 主要修改Fabric网络配置，验证证书，跨链合约设置： Fabric证书配置 启动Fabric网络时，会生成所有节点（包括Order、peer等）的证书信息，并保存在 crypto-config文件夹中，Fabric插件和Fabric交互时需要用到这些证书。 # 复制你所部署的Fabric所产生的crypto-config文件夹 cp -r /path/to/crypto-config $HOME /.pier1/fabric/ # 复制Fabric上验证人证书 cp $HOME /.pier1/fabric/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp/signcerts/peer1.org2.example.com-cert.pem $HOME /.pier1/fabric/fabric.validators 修改Plugin配置文件 config.yaml config.yaml 文件记录的Fabric网络配置（如果你是按照你自己的网络拓扑部署的Fabric，用你的网络拓扑配置文件替换这个样例文件），需要使用绝对路径，把所有的路径都修改为 crypto-config 文件夹所在的绝对路径，$USER指代当前用户名 path : { CONFIG_PATH } /fabric/crypto-config => path : /home/$USER/.pier/fabric/crypto-config 替换为你部署的Fabric网络的拓扑设置文件即可，同时需要修改所有的Fabric 的IP地址，如： url : grpcs://localhost:7050 => url : grpcs://10.1.16.48:7050 修改Plugin配置文件 fabric.toml 配置项和说明： 配置项 说明 addr Fabric 区块链所在的服务器地址和端口 event_filter 跨链合约中抛出的跨链事件的名称 username Fabric用户名称 ccid 所部署的跨链合约名称 channel_id 部署的跨链合约所在的channel org 部署的跨链合约所在的org 示例配置 addr = \"localhost:7053\" // 若Fabric部署在服务器上，该为服务器地址 event_filter = \"interchain-event-name\" username = \"Admin\" ccid = \"broker\" // 若部署跨链broker合约名字不是broker需要修改 channel_id = \"mychannel\" org = \"org2\" 修改Plugin配置文件fabric.validators fabric.validators 是Fabric验证人的证书，配置示例： -----BEGIN CERTIFICATE----- MIICKTCCAc+gAwIBAgIRAIBO31aZaSZoEYSy2AJuhJcwCgYIKoZIzj0EAwIwczEL MAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG cmFuY2lzY28xGTAXBgNVBAoTEG9yZzIuZXhhbXBsZS5jb20xHDAaBgNVBAMTE2Nh Lm9yZzIuZXhhbXBsZS5jb20wHhcNMjAwMjA1MDgyMjAwWhcNMzAwMjAyMDgyMjAw WjBqMQswCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMN U2FuIEZyYW5jaXNjbzENMAsGA1UECxMEcGVlcjEfMB0GA1UEAxMWcGVlcjEub3Jn Mi5leGFtcGxlLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABG3jszFPTbGm dAYg2BxmHMTDKfQReNw3p9ttMK130qF5lQo5zLBG8Sa3viOCLnvjjg6A/P+yKnwv isI/jEVE8T2jTTBLMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8EAjAAMCsGA1Ud IwQkMCKAIMVL+daK7nMGr2/AQIXTSPFkdd3UiPVDkWtkh5ujnalEMAoGCCqGSM49 BAMCA0gAMEUCIQDMYOQiYeMiQZTxlRkj/3/jjYvwwdCcX5AWuFmraiHkugIgFkX/ 6uiTSD0lz8P+wwlLf24cIABq2aZyi8q4gj0YfwA= -----END CERTIFICATE-----","text_tokens":["broker","拓扑","模板","说明","url","把","信息","上","示例","jeve8t2jttblma4ga1uddweb","为","端口","部署","用户","id","cert","begin","cp","plugin","to","合约","}","example","绝对路径","ip地址","如","如果","事件","$","区块","名字","makga1uebhmcvvmxezarbgnvbagtcknhbglmb3juawexfjaubgnvbactdvnhbibg","所有","名称","jjyvwwdccx5awufmraihkugigfkx","_","户名","event","验证","10.1","：","是","用","ccid","所以","并且","所在","）","并","pem","用户名","mychannel","wjbqmqswcqydvqqgewjvuzetmbega1uecbmkq2fsawzvcm5pytewmbqga1uebxmn","会",":","结构","生成","指代","证书","在","├","certificate","interchain","wqeawihgdambgnvhrmbaf8eajaamcsga1ud","7053","务器","peerorganizations","配置文件","该","节点","grpcs","件夹","dayg2bxmhmtdkfqrenw3p9ttmk130qf5lqo5zlbg8sa3vioclnvjjg6a","=","peer1","/","localhost","转到","yaml","项","。","clone","#","peer","的","启动","不是","6uitsd0lz8p","filter","使用","yknwv","signcerts","end","dak7nmgr2","pier","用到","name","所","同时","文件夹","已经",">","└","链","isi","\"","pier1","user","aqixtspfkdd3uipvdkwtkh5ujnalemaogccqgsm49","-----","你","fabric","开源","+","即可","进行",".","文件","产生","16.48","包括","都","addr","这些","当前","wwllf24ciabq2azyi8q4gj0yfwa","home","config","样例","toml","插件","路径","中","网络拓扑","等","admin","下","https","设置","order","github","crypto","com","代码","validators","目录","client","-","直接","交互","配置","─","meshplus"," ","抛出","miicktccac","3","cd","cmfuy2lzy28xgtaxbgnvbaoteg9yzziuzxhhbxbszs5jb20xhdaabgnvbamte2nh","iwqkmckaimvl","记录","username","和","跨链","绝对","网络","org","主要","、","peers","时","需要","人","msp","bamca0gameuciqdmyoqiyemiqztxlrkj","p","gawibagiraibo31azaszoeysy2ajuhjcwcgyikozizj0eawiwczel","path","channel","项目","这个","lm9yzziuzxhhbxbszs5jb20whhcnmjawmja1mdgymjawwhcnmzawmjaymdgymjaw","r","替换","服务器","下载","u2fuiezyyw5jaxnjbzenmasga1uecxmecgvlcjefmb0ga1ueaxmwcgvlcjeub3jn","，","修改","自己","git","（","org2","按照","服务","复制","地址","mi5legftcgxllmnvbtbzmbmgbyqgsm49agegccqgsm49aweha0iabg3jszfptbgm","保存","&&","7050","若","{"],"title":"修改fabric插件配置","title_tokens":["插件","配置","fabric","修改"]},{"location":"bitxhub/usage/direct_mode_pier/pier_direct_mode_deploy/#ethereum","text":"ethereum插件配置的模板在 pier-client-ethereum 项目中，并且已经在GitHub上进行开源，所以直接在GitHub上下载代码即可 # 转到pier-client-ethereum项目路径下 git clone https://github.com/meshplus/pier-client-ethereum.git && cd pier-client-ethereum cp ./config $HOME /.pier2/ether 配置目录结构 ├── account.key ├── broker.abi ├── data_swapper.abi ├── ether.validators ├── ethereum.toml ├── password ├── pier.toml // 仅作参考，无需配置 ├── transfer.abi └── validating.wasm **注意：**插件目录下的pier.toml仅作参考，系统使用的配置文件是位于pier的配置文件目录下的pier.toml。 主要修改账户信息、abi，跨链合约设置。 以太坊账户配置 启动以太坊网络时，在指定的 datadir 目录下，将 keystore 的账户信息拷贝到account.key中。 cp <eth_datadir>/keystore/<account> $HOME/.pier2/ether/config/account.key **修改Plugin配置文件ethereum.toml ** 配置项和说明： 配置项 说明 addr ethereum 区块链所在的服务器地址和端口 name 以太坊链名称 contract_address 部署的broker合约地址 key_path 账户信息 password 账户密码 min_confirm 最低确认区块数 contract_abi 部署的业务合约地址及所对应的abi 示例配置 [ether] addr = \"ws://127.0.0.1:8546\" // 若部署在服务器上，该为服务器地址 name = \"appchain2\" contract_address = \"0xC8C086200f92c9226b42079eCB3137eFc8752801\" // 该链部署的broker合约地址 key_path = \"account.key\" // 确保提前更改了account.key password = \"password\" min_confirm = 1 [contract_abi] 0xA5dD12E27Ee5E79cE0B50adb376414351C8eea5f=\"transfer.abi\" // 替换为该链部署的业务合约地址 修改Plugin配置文件abi信息 broker合约和业务合约如果使用的是插件的 example 文件下的合约，则不用更改相关abi内容。如果使用自定义的broker合约或业务合约，请替换为对应的abi文件。","text_tokens":["拷贝","broker","模板","eth","abi","说明","信息","上","示例","ether","端口","为","keystore","部署","[","请","无需","]","cp","plugin","合约","example","如果","$","data","区块","位于","validating","名称","_","confirm","：","是","所以","并且","address","所在","appchain2","将",":","结构","8546","在","0.1","├","transfer","指定","务器","配置文件","ws","相关","系统","account","=","注意","确保","定义","/","转到","项","。","clone","及","ethereum","#","的","启动","wasm","该链","<","则","不用","对应","使用","pier","name","所","swapper","password","坊","已经",">","contract","└","链","\"","开源","提前","即可","进行","文件目录",".","文件","datadir","addr","拷贝到","home","0xa5dd12e27ee5e79ce0b50adb376414351c8eea5f","config","自定义","*","toml","更改","或","插件","路径","0xc8c086200f92c9226b42079ecb3137efc8752801","中","内容","min","数","业务","下","https","设置","确认","github","com","仅作","代码","validators","目录","client","-","直接","配置","─","meshplus"," ","密码","cd","和","跨链","pier2","网络","主要","、","时","127.0","path","key","项目","最低","以太","服务器","替换","下载","，","修改","git","服务","自定","地址","参考","了","&&","该","若","1","账户"],"title":"修改ethereum插件配置","title_tokens":["插件","配置","ethereum","修改"]},{"location":"bitxhub/usage/direct_mode_pier/pier_direct_mode_deploy/#_6","text":"#以用户目录下的pier1为例 pier --repo=~/pier1 start #以用户目录下的pier2为例 pier --repo=~/pier2 start 观察日志信息没有报错信息，pier启动成功 说明：1. 因为跨链合约和验证规则的部署涉及到不同应用链的细节，且需依赖应用链的安装部署，具体操作请见快速开始手册或使用文档，这里不再赘述。2. 本文是以一方的跨链网关为例进行部署，而另一方的跨链网关的部署与之基本一样，这里不再赘述。 直连模式下，两边的跨链网关需要相互注册同时部署验证规则 idA = $( pier --repo ~/pier1 id ) idB = $( pier --repo ~/pier2 id ) pier --repo ~/pier1 client register --pier_id ${ idB } --name fab --type fabric --desc simple --version 1 --validators ~/pier1/fabric/fabric.validators --consensusType raft pier --repo ~/pier2 client register --pier_id ${ idA } --name eth --type ethereum --desc simple --version 1 --validators ~/pier2/ethereum/ether.validators --consensusType raft pier --repo ~/pier1 client rule --pier_id ${ idB } --path ~/pier1/fabric/rule.wasm pier --repo ~/pier2 client rule --pier_id ${ idA } --path ~/pier2/ethereum/rule.wasm 完成上述布置后，跨链网关直连模式下部署就已经完成，两边的应用链可以进行跨链操作","text_tokens":["eth","说明","信息","到","ether","部署","用户","请","id","register","consensustype","}","合约","raft","相互","具体","$","日志","{","一样","见","desc","直连","(","文档","因为","赘述","version","以","_","模式","验证","type","：","是","需","这里","rule","成功","快速","操作","规则","具体操作","之","体操","=","/","simple","另一方","。","ethereum","#","后","的","与","没有","启动","wasm","报错","不同","布置","idb","使用","不再","pier","而","手册","name","同时","已经","且","上述","fab","完成","链","pier1","涉及","细节","fabric",")","两边","进行","repo",".","安装","依赖","或","2","一方","下","为例","--","start","注册","validators","目录","client","ida","1"," ","可以","和","跨链","pier2","需要","path","本文","，","网关","~","基本","应用","观察","就","开始"],"title":"启动程序","title_tokens":["启动","程序"]},{"location":"bitxhub/usage/single_bitxhub/deploy_bitxhub/","text":"中继链部署 中继链用于应用链的跨链管理，以及跨链交易的可信验证与可靠路由，是一种实现IBTP协议的开放许可链。部署中继链节点主要是三个步骤：安装包获取（准备）、配置文件修改和程序启动，下面依次进行说明。 安装包获取 源码编译 您可以自行拉取BitXHub项目的源码，然后在本地编译BitXHub及插件的二进制文件，具体操作步骤可参考如下： # 1. 首先拉取bitxhub项目源代码 git clone https://github.com/meshplus/bitxhub.git # 2. 进入bitxhub目录，切换到指定的分支或版本后编译bitxhub二进制 cd bitxhub && git checkout v1.11.2 && make build # 注意⚠️：首次编译需要在build之前先执行 make prepare 完成依赖安装 # 编译完成后可以在项目的bin目录下看到刚刚生成的bitxhub二进制文件，可以确认下bitxhub版本是v1.11.2 ./bin/bitxhub version # 注意⚠️：v1.11.2版本的bitxhub共识通过模块化的方式提供 提示：在bitxhub v1.7.0及以上的版本，我们也提供了一键生成部署所需的文件包的make命令：make release-binary，执行完成后可以在项目的dist目录看到符合您系统的压缩包，解压即可使用。 经过以上的步骤，相信您已经编译出了部署中继链节点所需的二进制文件，中继链节点运行还需要外部依赖库，均在项目build目录下（Macos使用libwasmer.dylib，Linux使用libwasmer.so）,建议将得到的二进制和适配的依赖库文件拷贝到同一目录，方便之后的操作。 二进制直接下载 除了源码编译外，我们也提供了直接下载BitXHub二进制的方式，下载地址链接如下： BitXHub二进制包下载 ，链接中已经包含了所需的二进制和依赖库，您只需跟据实际情况选择合适的版本和系统下载即可，建议使用最新的BitXHub发布版本。 快速启动BitXHub节点 获取到安装包后，接下来要根据您的实际情况修改配置文件。 如果您是在本地编译的二进制包，您也可以在项目根目录执行 make cluster 一键启动四节点raft共识的BitXHub集群，或者执行 make solo 一键启动单节点solo共识的BitXHub节点。 如果您是直接下载的二进制安装包，为了简化操作，我们也提供了可以直接启动raft/solo共识的节点配置文件示例，其下载地址与二进制包一样，文件名以example开头。需要注意的是，raft共识的示例配置文件是四节点集群，solo共识的示例配置文件是单节点 接下来只需将上一步下载的BitXHub二进制及对应插件拷贝到配置目录即可，具体操作如下： # 1. 解压二进制压缩包 mkdir bitxhub && cd bitxhub cp ~/Downloads/bitxhub_darwin_x86_64_v1.11.2.tar.gz . tar -zxvf bitxhub_darwin_x86_64_v1.11.2.tar.gz # 2. 解压配置文件压缩包(以raft共识为例) mkdir raft-nodes tar -zxvf example_bitxhub_v1.11.2.tar.gz -C raft-nodes/ # 3. 将bitxhub和依赖库文件分别拷贝到4个节点的配置目录（以node1为例） cp bitxhub raft-nodes/node1/ cp libwasmer.dylib raft-nodes/node1/ # 注意⚠️：节点2、3、4也需要执行上面拷贝操作，对于Linux系统依赖库文件是libwasmer.so # 以上操作均是示例，执行时二进制和配置文件压缩包的名称可能存在差异，需要根据实际情况进行调整 拷贝完成后，可以进入各个节点的配置目录，依次启动BitXHub节点即可，启动操作如下： cd bitxhub/raft-nodes/node1 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$(pwd) ./bitxhub --repo ./ start ... ... cd bitxhub/raft-nodes/node4 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$(pwd) ./bitxhub --repo ./ start 待节点集群打印出bitxhub的LOGO，表示BitXHub集群开始正常工作 BitXHub配置文件说明 前面的提供的配置示例可以方便地快速启动BitXHub节点(集群)，但是没有对配置文件进行具体说明，考虑到您可能需要详细了解bitxhub的运行原理和配置项的具体含义，从而可以灵活配置和启动节点，我们接下来对BitXHub的具体配置项进行说明。 中继链节点主要包括bitxhub.toml、network.tom和order.toml配置文件，分别代表节点本身、节点网络以及节点共识方面的配置，其中order.toml一般使用默认配置即可，其它两个文件均需要根据实际部署情况进行修改，接下来的内容依然以node1为例。 bitxhub.toml文件配置修改 bitxhub.toml文件是BitXHub节点启动的主要配置文件。各配置项说明如下： 配置项 说明 solo 是否按照单节点模式启动BitXHub [port] gateway、grpc、pprof和monitor服务端口 [pprof] 性能剖析配置 [monitor] 监控服务配置 [gateway] 跨域配置 [ping] ping集群节点功能 [security] 证书体系 [limiter] 流量控制配置 [appchain] 同步以太坊区块头 [log] 日志输出相关设置 [cert] 是否开启认证节点p2p通信证书 [order] 共识模块，作为模块进行加载 [executor] 执行引擎类型 [ledger] 账本类型 [genesis] 创世节点配置 在快速体验部署流程中，需要修改的配置一般只有port、order的信息，其它配置默认即可。 以下为示例参考 根据您机器实际分配的端口进行变更： [ port ] gateway = 9091 grpc = 60011 pprof = 53121 monitor = 40011 共识算法类型选择（开源版本目前支持raft和solo）： [ order ] plugin = \"raft\" network.toml文件配置修改 network.toml文件是BitXHub节点网络配置文件，各配置项说明如下： 配置项 说明 N 集群节点数量 id 当前节点标识 new 判断当前节点是新加入的节点 [nodes] 集群节点信息 account 节点验证者地址 hosts 节点网络地址 id 节点标识 pid p2p网络唯一标识 在实际部署过程中，需要修改的配置一般是节点数量、nodes的信息，其它配置默认即可。 以下为示例参考 配置当前节点集群的数量以及自身的id: id = 1 # self id n = 4 # the number of vp nodes new = false # track whether the node is a new node 配置集群中各个节点的信息 [[ nodes ]] account = \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\" hosts = [ \"/ip4/127.0.0.1/tcp/4001/p2p/\" ] id = 1 pid = \"QmXi58fp9ZczF3Z5iz1yXAez3Hy5NYo1R8STHWKEM9XnTL\" 说明：上面 account就是上一节中bitxhub节点的address地址，hosts中一般就改变ip地址即可，节点的pid信息可以通过如下命令获取： . / bitxhub cert priv pid -- path certs / node . priv # 示例输出 ： QmWAaFDQ3p2Hj383WsBGU2nLMtsJk1aT9obXXXxL5UyUuA order.toml文件配置修改 order.toml文件是bitxhub共识配置文件。各配置项说明如下： 配置项 说明 [raft] raft 相关配置 [rbft] rbft 相关配置 [solo] solo相关配置 配置示例如下（无特殊情况不要修改此配置）： [ raft ] batch_timeout = \"0.3s\" # Block packaging time period . tick_timeout = \"0.1s\" # TickTimeout is the internal logical clock for the Node by a single tick , Election timeouts and heartbeat timeouts are in units of ticks . election_tick = 10 # ElectionTick is the number of Node . Tick invocations that must pass between elections . heartbeat_tick = 1 # HeartbeatTick is the number of Node . Tick invocations that must pass between heartbeats . max_size_per_msg = 1048576 # 1024 * 1024 , MaxSizePerMsg limits the max size of each append message . max_inflight_msgs = 500 # MaxInflightMsgs limits the max number of in - flight append messages during optimistic replication phase . check_quorum = true # Leader steps down when quorum is not active for an electionTimeout . pre_vote = true # PreVote prevents reconnected node from disturbing network . disable_proposal_forwarding = true # This prevents blocks from being accidentally proposed by followers . [ raft . mempool ] batch_size = 200 # How many transactions should the primary pack . pool_size = 50000 # How many transactions could the txPool stores in total . tx_slice_size = 10 # How many transactions should the node broadcast at once tx_slice_timeout = \"0.1s\" # Node broadcasts transactions if there are cached transactions , although set_size isn 't reached yet [raft.syncer] sync_blocks = 1 # How many blocks should the behind node fetch at once snapshot_count = 1000 # How many apply index(blocks) should the node trigger at once [rbft] #RBFT configurations set_size = 25 # How many transactions should the node broadcast at once batch_size = 500 # How many transactions should the primary pack before sending pre-prepare pool_size = 50000 # How many transactions could the txPool stores in total vc_period = 0 # After how many checkpoint periods( Blocks = 10 * vcperiod ) the primary gets cycled automatically. ( Set 0 to disable ) check_interval = \"3m\" # interval of the check loop tolerance_time = \"5m\" # The max tolerance time duration (in seconds) of out-of-date batch_mem_limit = false # Indicates whether limit batch mem size or not batch_max_mem = 10000 # The max memory size of one batch [rbft.timeout] sync_state = \"3s\" # How long to wait quorum sync state response sync_interval = \"1m\" # How long to restart sync state process recovery = \"15s\" # How long to wait before recovery finished(This is for release1.2) first_request = \"30s\" # How long to wait before first request should come batch = \"0.5s\"# Primary send a pre-prepare if there are pending requests, although batchsize isn' t reached yet , request = \"6s\" # How long may a request ( transaction batch ) take between reception and execution , must be greater than the batch timeout null_request = \"9s\" # Primary send it to inform aliveness , must be greater than request timeout viewchange = \"8s\" # How long may a view change take resend_viewchange = \"10s\" # How long to wait for a view change quorum before resending ( the same ) view change clean_viewchange = \"60s\" # How long to clean out - of - data view change message update = \"4s\" # How long may a update - n take set = \"0.1s\" # Node broadcasts transactions if there are cached transactions , although set_size isn 't reached yet [rbft.syncer] sync_blocks = 1 # How many blocks should the behind node fetch at once [solo] batch_timeout = \"0.3s\" # Block packaging time period. [solo.mempool] batch_size = 200 # How many transactions should the primary pack. pool_size = 50000 # How many transactions could the txPool stores in total. tx_slice_size = 10 # How many transactions should the node broadcast at once tx_slice_timeout = \"0.1s\" # Node broadcasts transactions if there are cached transactions, although set_size isn' t reached yet","text_tokens":["者","10000","same","说明","30s","协议","包含","各","上","信息","您","max","端口","为","node1","cert","包","msgs","通信","如果","$","区块","就是","node4","checkpoint","aliveness","tolerance","limiter","中继","logical","new","以","_","yet","gz","前面","操作步骤","one","需","一般","操作","clean","依次","改变","msg","本地","mkdir","进入","链接","log","reconnected","=","tx","项","zxvf","。","clone","新","启动","'","可","total","periods","默认","rbft","或者","提示","9s","库",",","编译","when","darwin","change","完成","linux","solo","state","in","即可","certs","maxinflightmsgs","stores","broadcasts","依赖","are","拷贝到","出","number","自身","40011","一键","两个","或","插件","prepare","中","tcp","between","should","block","开放","requests","automatically","https","运行","设置","interval","确认","start","com","账本","以及","append","创世","-","调整","对","外部","文件名","bitxhub","v1.7"," ","heartbeattick","3","路由","elections","和","cached","之后","macos","it","执行","符合","用于","optimistic","灵活","压缩","primary","behind","解压","下载","ticktimeout","（","libwasmer","管理","据","&&","源代码","拷贝","️","从而","index","period","proposed","到","snapshot","部署","[","合适","executor","being","流程","bin","plugin","raft","timeout","0.5","开启","data","一样","vcperiod","其它","简化","pending","blocks","目前","模块化","刚刚","首次","out","压缩包","followers","：","差异","isn","是","作为","message","priv","an","四","mem","than",":","只","证书","prevents","request","在","具体操作","指定","其","0","could","pool","from","加入","系统","跨域","or","account","注意","vp","接下","后","的","与","没有","交易","50000","clock","对应","分别","为了","先","使用","disable","ip","分配","所","坊","response","500","v1.11","for","实现","batchsize","replication","集群","经过","repo","viewchange","过程","single","count","包括","10s","reception","9091","自行","当前","三个","最新","头","命令","首先","export","mempool","根目录","内容","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013","github","security","其中","cycled","8s","均","引擎","配置","ld","cd","so","情况","还","grpc","units","internal","once","也","date","limit","library","项目","p2p","4001","a","long","64","上面","execution","修改","剖析","git","然后","地址","heartbeats","可信","1","单","可能","唯一","一节","time","性能","send","prevote","id","steps","cp","phase","to","sending","具体","cluster","日志","genesis","is","选择","track","代表","是否","pack","名称","5m","inform","version","each","类型","验证","共识","address","）","获取","存在","但是","判断","qmwaafdq3p2hj383wsbgu2nlmtsjk1at9obxxxxl5uyuua","程序","网络地址","gets","对于","之前","finished","不要","during","接下来","accidentally","体操","60s","/","tom","及","syncer","set","#","the","个","下面","self","per","many","be","vote","checkout","binary","downloads","broadcast","disturbing","pid","of","appchain","gateway","1024","已经","view","原理","支持","messages","first","⚠","tick","链","除了","\"","10","process","pprof","看到","txpool","开源",")","ip4","leader","electiontimeout","文件","active","标识","机器","qmxi58fp9zczf3z5iz1yxaez3hy5nyo1r8sthwkem9xntl","electiontick","network","4s","了解","提供","数量","200","toml","ledger","分支","transactions","flight","1000","发布","功能","order","how","--","memory","monitor","要","apply","以上","ibtp","各个","4","after","by","and","相信","heartbeat","that","可以","主要","logo","进制","duration","切换","时","需要","release","pass","打印","可靠","quorum","~","得到","按照","false","含义","参考","应用","表示","就","0.3","pre","工作","6s","indicates","模块","许可","准备","示例","maxsizepermsg","before","ticks","实际","适配","true","]","t","流量","example","一步","election","通过","vc","down","(","25","方面","跟","待","size","输出","there","3s","体验","...","模式","特殊","at","依然","监控","详细","proposal","3m","下来","n","快速","将","认证","greater","生成","0.1","无","开头","1m","建议","配置文件","同一","节点","nodes","控制","相关","port","must","加载","update","外","s","if","15s","may","invocations","restart","考虑","trigger","x86","一种","reached","体系","拉取","hosts","batch","inflight","c","make","wait","check","although","53121","packaging","方式","resending","sync","whether","进行","如下","this",".","根据","come","null","方便","pwd","安装","build","resend","node","recovery","变更","安装包","slice","1048576","*","transaction","2","下","release1.2","为例","代码","二进制","算法","目录","直接","seconds","timeouts","meshplus","not","dist","tar","ping","只有","dylib","configurations","正常","地","跨链","loop","网络","此","、","我们","步骤","127.0","path","forwarding","60011","以太","本身","版本","同步","，","服务","fetch","take","了","limits","源码","以下","开始"],"title":"中继链部署","title_tokens":["部署","链","中继"]},{"location":"bitxhub/usage/single_bitxhub/deploy_bitxhub/#_1","text":"中继链用于应用链的跨链管理，以及跨链交易的可信验证与可靠路由，是一种实现IBTP协议的开放许可链。部署中继链节点主要是三个步骤：安装包获取（准备）、配置文件修改和程序启动，下面依次进行说明。","text_tokens":["说明","依次","以及","协议","许可","准备","程序","链","ibtp","配置","部署","实现","路由","配置文件","节点","和","跨链","进行","主要","、","文件","安装","用于","步骤","。","可靠","三个","的","与","启动","安装包","中继","交易","下面","一种","验证","，","修改","（","：","是","开放","应用","管理","）","获取","可信"],"title":"中继链部署","title_tokens":["部署","链","中继"]},{"location":"bitxhub/usage/single_bitxhub/deploy_bitxhub/#_2","text":"","text_tokens":[],"title":"安装包获取","title_tokens":["获取","安装包","安装"]},{"location":"bitxhub/usage/single_bitxhub/deploy_bitxhub/#_3","text":"您可以自行拉取BitXHub项目的源码，然后在本地编译BitXHub及插件的二进制文件，具体操作步骤可参考如下： # 1. 首先拉取bitxhub项目源代码 git clone https://github.com/meshplus/bitxhub.git # 2. 进入bitxhub目录，切换到指定的分支或版本后编译bitxhub二进制 cd bitxhub && git checkout v1.11.2 && make build # 注意⚠️：首次编译需要在build之前先执行 make prepare 完成依赖安装 # 编译完成后可以在项目的bin目录下看到刚刚生成的bitxhub二进制文件，可以确认下bitxhub版本是v1.11.2 ./bin/bitxhub version # 注意⚠️：v1.11.2版本的bitxhub共识通过模块化的方式提供 提示：在bitxhub v1.7.0及以上的版本，我们也提供了一键生成部署所需的文件包的make命令：make release-binary，执行完成后可以在项目的dist目录看到符合您系统的压缩包，解压即可使用。 经过以上的步骤，相信您已经编译出了部署中继链节点所需的二进制文件，中继链节点运行还需要外部依赖库，均在项目build目录下（Macos使用libwasmer.dylib，Linux使用libwasmer.so）,建议将得到的二进制和适配的依赖库文件拷贝到同一目录，方便之后的操作。","text_tokens":["拷贝","️","模块","到","您","部署","适配","bin","包","通过","具体","中继","version","模块化","刚刚","首次","操作步骤","压缩包","：","是","需","共识","）","将",":","操作","生成","在","之前","指定","本地","进入","0","建议","同一","节点","系统","注意","/","及","clone","。","#","后","的","可","先","使用","拉取","checkout","提示","binary","所","库","make",",","编译","已经","v1.11","⚠","完成","链","linux","看到","方式","即可","经过","如下",".","文件","方便","build","安装","依赖","自行","拷贝到","出","提供","一键","命令","首先","源码","或","插件","分支","prepare","2","下","https","运行","确认","github","com","代码","二进制","目录","-","均","以上","外部","bitxhub","meshplus"," ","v1.7","相信","dist","cd","dylib","so","可以","和","还","之后","macos","进制","执行","切换","也","符合","需要","我们","步骤","release","压缩","解压","项目","版本","，","git","（","libwasmer","得到","然后","参考","了","&&","1","源代码"],"title":"源码编译","title_tokens":["编译","源码"]},{"location":"bitxhub/usage/single_bitxhub/deploy_bitxhub/#_4","text":"除了源码编译外，我们也提供了直接下载BitXHub二进制的方式，下载地址链接如下： BitXHub二进制包下载 ，链接中已经包含了所需的二进制和依赖库，您只需跟据实际情况选择合适的版本和系统下载即可，建议使用最新的BitXHub发布版本。","text_tokens":["库","编译","已经","二进制","只","直接","包含","您","除了","bitxhub","实际"," ","合适","方式","包","链接","建议","即可","和","情况","如下","系统","外","选择","进制","也","我们","依赖","。","跟","的","提供","最新","版本","下载","，","：","中","使用","地址","需","了","发布","据","源码","所"],"title":"二进制直接下载","title_tokens":["进制","直接","二进制","下载"]},{"location":"bitxhub/usage/single_bitxhub/deploy_bitxhub/#bitxhub","text":"获取到安装包后，接下来要根据您的实际情况修改配置文件。 如果您是在本地编译的二进制包，您也可以在项目根目录执行 make cluster 一键启动四节点raft共识的BitXHub集群，或者执行 make solo 一键启动单节点solo共识的BitXHub节点。 如果您是直接下载的二进制安装包，为了简化操作，我们也提供了可以直接启动raft/solo共识的节点配置文件示例，其下载地址与二进制包一样，文件名以example开头。需要注意的是，raft共识的示例配置文件是四节点集群，solo共识的示例配置文件是单节点 接下来只需将上一步下载的BitXHub二进制及对应插件拷贝到配置目录即可，具体操作如下： # 1. 解压二进制压缩包 mkdir bitxhub && cd bitxhub cp ~/Downloads/bitxhub_darwin_x86_64_v1.11.2.tar.gz . tar -zxvf bitxhub_darwin_x86_64_v1.11.2.tar.gz # 2. 解压配置文件压缩包(以raft共识为例) mkdir raft-nodes tar -zxvf example_bitxhub_v1.11.2.tar.gz -C raft-nodes/ # 3. 将bitxhub和依赖库文件分别拷贝到4个节点的配置目录（以node1为例） cp bitxhub raft-nodes/node1/ cp libwasmer.dylib raft-nodes/node1/ # 注意⚠️：节点2、3、4也需要执行上面拷贝操作，对于Linux系统依赖库文件是libwasmer.so # 以上操作均是示例，执行时二进制和配置文件压缩包的名称可能存在差异，需要根据实际情况进行调整 拷贝完成后，可以进入各个节点的配置目录，依次启动BitXHub节点即可，启动操作如下： cd bitxhub/raft-nodes/node1 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$(pwd) ./bitxhub --repo ./ start ... ... cd bitxhub/raft-nodes/node4 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$(pwd) ./bitxhub --repo ./ start 待节点集群打印出bitxhub的LOGO，表示BitXHub集群开始正常工作","text_tokens":["拷贝","️","工作","单","可能","示例","到","上","您","实际","node1","包","cp","raft","example","一步","如果","cluster","具体","$","一样","(","简化","待","node4","名称","以","_","...","gz","压缩包","：","差异","是","需","共识","下来","）","获取","存在","四","将",":","操作","依次","只","在","对于","具体操作","开头","本地","mkdir","其","进入","接下来","配置文件","节点","nodes","体操","系统","=","注意","/","接下","。","及","zxvf","后","#","的","与","启动","个","x86","对应","分别","为了","或者","开始","downloads","c","make","库","编译","v1.11","darwin","⚠","linux","完成","solo","集群",")","即可","进行","repo","如下",".","文件","根据","pwd","安装","依赖","拷贝到","出","安装包","提供","一键","export","插件","根目录","2","为例","--","start","二进制","要","目录","直接","-","均","调整","以上","配置","文件名","4","bitxhub","各个"," ","3","ld","tar","cd","dylib","so","可以","正常","情况","和","、","logo","进制","执行","也","时","需要","我们","打印","path","压缩","library","解压","项目","64","下载","上面","，","修改","~","（","libwasmer","地址","了","表示","&&","1"],"title":"快速启动BitXHub节点","title_tokens":["节点","快速","启动","bitxhub"]},{"location":"bitxhub/usage/single_bitxhub/deploy_bitxhub/#bitxhub_1","text":"前面的提供的配置示例可以方便地快速启动BitXHub节点(集群)，但是没有对配置文件进行具体说明，考虑到您可能需要详细了解bitxhub的运行原理和配置项的具体含义，从而可以灵活配置和启动节点，我们接下来对BitXHub的具体配置项进行说明。 中继链节点主要包括bitxhub.toml、network.tom和order.toml配置文件，分别代表节点本身、节点网络以及节点共识方面的配置，其中order.toml一般使用默认配置即可，其它两个文件均需要根据实际部署情况进行修改，接下来的内容依然以node1为例。","text_tokens":["从而","可能","说明","示例","到","您","实际","部署","node1","具体","(","其它","代表","方面","中继","以","依然","前面","详细","共识","下来","快速","但是","一般","配置文件","接下来","节点","tom","项","接下","。","考虑","的","启动","没有","分别","默认","使用","原理","链","集群",")","即可","进行",".","文件","根据","方便","包括","network","了解","提供","两个","toml","内容","运行","order","为例","其中","以及","均","对","配置","bitxhub"," ","可以","地","情况","和","网络","主要","、","需要","我们","灵活","本身","，","修改","含义"],"title":"BitXHub配置文件说明","title_tokens":["说明","文件","配置文件","配置","bitxhub"]},{"location":"bitxhub/usage/single_bitxhub/deploy_bitxhub/#bitxhubtoml","text":"bitxhub.toml文件是BitXHub节点启动的主要配置文件。各配置项说明如下： 配置项 说明 solo 是否按照单节点模式启动BitXHub [port] gateway、grpc、pprof和monitor服务端口 [pprof] 性能剖析配置 [monitor] 监控服务配置 [gateway] 跨域配置 [ping] ping集群节点功能 [security] 证书体系 [limiter] 流量控制配置 [appchain] 同步以太坊区块头 [log] 日志输出相关设置 [cert] 是否开启认证节点p2p通信证书 [order] 共识模块，作为模块进行加载 [executor] 执行引擎类型 [ledger] 账本类型 [genesis] 创世节点配置 在快速体验部署流程中，需要修改的配置一般只有port、order的信息，其它配置默认即可。 以下为示例参考 根据您机器实际分配的端口进行变更： [ port ] gateway = 9091 grpc = 60011 pprof = 53121 monitor = 40011 共识算法类型选择（开源版本目前支持raft和solo）： [ order ] plugin = \"raft\"","text_tokens":["单","说明","模块","各","信息","示例","性能","您","端口","为","部署","[","实际","executor","流程","]","cert","plugin","流量","raft","通信","genesis","开启","日志","区块","选择","其它","是否","目前","limiter","输出","体验","模式","类型","监控","：","是","作为","共识","快速","）","一般","认证","证书","在","配置文件","节点","控制","log","相关","port","跨域","加载","=","项","。","的","启动","体系","默认","分配","坊","appchain","gateway","支持","solo","\"","53121","pprof","开源","集群","即可","进行","如下",".","文件","根据","机器","9091","变更","头","40011","toml","ledger","中","功能","设置","order","security","账本","monitor","算法","创世","引擎","配置","bitxhub"," ","ping","只有","和","主要","、","grpc","执行","需要","p2p","60011","以太","同步","版本","，","剖析","修改","（","按照","服务","参考","以下"],"title":"bitxhub.toml文件配置修改","title_tokens":["toml","修改",".","文件","bitxhub","配置"]},{"location":"bitxhub/usage/single_bitxhub/deploy_bitxhub/#networktoml","text":"network.toml文件是BitXHub节点网络配置文件，各配置项说明如下： 配置项 说明 N 集群节点数量 id 当前节点标识 new 判断当前节点是新加入的节点 [nodes] 集群节点信息 account 节点验证者地址 hosts 节点网络地址 id 节点标识 pid p2p网络唯一标识 在实际部署过程中，需要修改的配置一般是节点数量、nodes的信息，其它配置默认即可。 以下为示例参考 配置当前节点集群的数量以及自身的id: id = 1 # self id n = 4 # the number of vp nodes new = false # track whether the node is a new node 配置集群中各个节点的信息 [[ nodes ]] account = \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\" hosts = [ \"/ip4/127.0.0.1/tcp/4001/p2p/\" ] id = 1 pid = \"QmXi58fp9ZczF3Z5iz1yXAez3Hy5NYo1R8STHWKEM9XnTL\" 说明：上面 account就是上一节中bitxhub节点的address地址，hosts中一般就改变ip地址即可，节点的pid信息可以通过如下命令获取： . / bitxhub cert priv pid -- path certs / node . priv # 示例输出 ： QmWAaFDQ3p2Hj383WsBGU2nLMtsJk1aT9obXXXxL5UyUuA","text_tokens":["者","唯一","说明","一节","各","信息","示例","上","为","实际","[","部署","id","]","cert","通过","is","track","其它","就是","输出","new","验证","：","是","n","address","获取","priv","qmwaafdq3p2hj383wsbgu2nlmtsjk1at9obxxxxl5uyuua","判断","一般",":","改变","网络地址","在","0.1","配置文件","节点","nodes","加入","account","=","/","vp","项","新","。","#","的","the","self","默认","hosts","ip","pid","of","\"","ip4","集群","即可","whether","certs","如下","过程",".","文件","标识","qmxi58fp9zczf3z5iz1yxaez3hy5nyo1r8sthwkem9xntl","network","当前","node","number","自身","命令","数量","toml","tcp","中","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013","--","以及","配置","各个","4","bitxhub"," ","可以","网络","、","需要","127.0","path","p2p","4001","a","上面","，","修改","false","地址","参考","就","以下","1"],"title":"network.toml文件配置修改","title_tokens":["toml","修改","network",".","文件","配置"]},{"location":"bitxhub/usage/single_bitxhub/deploy_bitxhub/#ordertoml","text":"order.toml文件是bitxhub共识配置文件。各配置项说明如下： 配置项 说明 [raft] raft 相关配置 [rbft] rbft 相关配置 [solo] solo相关配置 配置示例如下（无特殊情况不要修改此配置）： [ raft ] batch_timeout = \"0.3s\" # Block packaging time period . tick_timeout = \"0.1s\" # TickTimeout is the internal logical clock for the Node by a single tick , Election timeouts and heartbeat timeouts are in units of ticks . election_tick = 10 # ElectionTick is the number of Node . Tick invocations that must pass between elections . heartbeat_tick = 1 # HeartbeatTick is the number of Node . Tick invocations that must pass between heartbeats . max_size_per_msg = 1048576 # 1024 * 1024 , MaxSizePerMsg limits the max size of each append message . max_inflight_msgs = 500 # MaxInflightMsgs limits the max number of in - flight append messages during optimistic replication phase . check_quorum = true # Leader steps down when quorum is not active for an electionTimeout . pre_vote = true # PreVote prevents reconnected node from disturbing network . disable_proposal_forwarding = true # This prevents blocks from being accidentally proposed by followers . [ raft . mempool ] batch_size = 200 # How many transactions should the primary pack . pool_size = 50000 # How many transactions could the txPool stores in total . tx_slice_size = 10 # How many transactions should the node broadcast at once tx_slice_timeout = \"0.1s\" # Node broadcasts transactions if there are cached transactions , although set_size isn 't reached yet [raft.syncer] sync_blocks = 1 # How many blocks should the behind node fetch at once snapshot_count = 1000 # How many apply index(blocks) should the node trigger at once [rbft] #RBFT configurations set_size = 25 # How many transactions should the node broadcast at once batch_size = 500 # How many transactions should the primary pack before sending pre-prepare pool_size = 50000 # How many transactions could the txPool stores in total vc_period = 0 # After how many checkpoint periods( Blocks = 10 * vcperiod ) the primary gets cycled automatically. ( Set 0 to disable ) check_interval = \"3m\" # interval of the check loop tolerance_time = \"5m\" # The max tolerance time duration (in seconds) of out-of-date batch_mem_limit = false # Indicates whether limit batch mem size or not batch_max_mem = 10000 # The max memory size of one batch [rbft.timeout] sync_state = \"3s\" # How long to wait quorum sync state response sync_interval = \"1m\" # How long to restart sync state process recovery = \"15s\" # How long to wait before recovery finished(This is for release1.2) first_request = \"30s\" # How long to wait before first request should come batch = \"0.5s\"# Primary send a pre-prepare if there are pending requests, although batchsize isn' t reached yet , request = \"6s\" # How long may a request ( transaction batch ) take between reception and execution , must be greater than the batch timeout null_request = \"9s\" # Primary send it to inform aliveness , must be greater than request timeout viewchange = \"8s\" # How long may a view change take resend_viewchange = \"10s\" # How long to wait for a view change quorum before resending ( the same ) view change clean_viewchange = \"60s\" # How long to clean out - of - data view change message update = \"4s\" # How long may a update - n take set = \"0.1s\" # Node broadcasts transactions if there are cached transactions , although set_size isn 't reached yet [rbft.syncer] sync_blocks = 1 # How many blocks should the behind node fetch at once [solo] batch_timeout = \"0.3s\" # Block packaging time period. [solo.mempool] batch_size = 200 # How many transactions should the primary pack. pool_size = 50000 # How many transactions could the txPool stores in total. tx_slice_size = 10 # How many transactions should the node broadcast at once tx_slice_timeout = \"0.1s\" # Node broadcasts transactions if there are cached transactions, although set_size isn' t reached yet","text_tokens":["index","6s","10000","same","period","indicates","说明","time","30s","proposed","各","示例","max","maxsizepermsg","before","prevote","snapshot","send","ticks","[","true","being","]","t","steps","phase","to","raft","msgs","election","sending","timeout","0.5","vc","down","data","is","vcperiod","(","25","checkpoint","aliveness","size","blocks","pack","tolerance","5m","pending","inform","logical","there","3s","each","_","yet","特殊","at","out","followers","one","：","isn","是","proposal","message","共识","3m","n","）","an","mem","greater","than","clean","prevents","request","gets","0.1","无","finished","msg","不要","during","0","1m","could","pool","配置文件","reconnected","from","accidentally","相关","must","or","60s","=","update","s","if","15s","may","tx","invocations","项","。","syncer","restart","set","#","trigger","'","the","total","per","50000","clock","periods","reached","rbft","many","disable","be","batch","vote","inflight","broadcast","disturbing","9s","of","1024","wait",",","view","response","check","500","messages","for","tick","when","first","change","solo","\"","although","10","state","process","packaging","resending","in","batchsize","replication","txpool",")","sync","leader","whether","如下","maxinflightmsgs","electiontimeout","this",".","文件","single","active","stores","come","null","resend","count","broadcasts","electiontick","10s","reception","network","4s","are","node","number","recovery","slice","1048576","200","*","toml","mempool","viewchange","transactions","prepare","between","flight","should","block","requests","transaction","1000","automatically","release1.2","order","how","interval","memory","cycled","append","8s","-","apply","seconds","配置","timeouts","bitxhub"," ","heartbeattick","after","by","and","not","configurations","heartbeat","elections","that","情况","cached","loop","此","it","units","internal","duration","once","optimistic","pass","date","limit","primary","behind","forwarding","quorum","long","a","ticktimeout","execution","修改","（","false","fetch","take","heartbeats","limits","0.3","1","pre"],"title":"order.toml文件配置修改","title_tokens":["order","toml","修改",".","文件","配置"]},{"location":"bitxhub/usage/single_bitxhub/deploy_pier/","text":"跨链网关部署 跨链网关Pier能够支持业务所在区块链（以下简称 应用链）便捷、快速的接入到跨链平台BitXHub中，从而实现和其他业务区块链的跨链操作。目前中继链和跨链网关已经支持 Fabric 、 Ethereum 、 BCOS 、 CITA 和 Hyperchain 五种应用链接入并完成跨链交易，如果您有兴趣，也可以参与开发适配另外种类应用链的插件和合约。 跨链网关的部署需要提前确定应用链类型（对应不同的插件和配置），也需要提前在对应的应用链上部署跨链合约，我们将跨链网关的部署依次分为如下五个步骤： 部署跨链合约 获取部署包和修改Pier配置 注册应用链信息 部署验证规则 启动跨链网关 部署跨链合约 这一章是要在应用链上部署跨链合约， 注意：在此操作之前，您需要确认已经部署有可接入的应用链 。 我们提供了针对不同应用链的跨链合约，broker合约是管理合约，transfer合约是业务交易合约，需要说明的是 transfer合约需要经过broker合约审核通过后才能发起或接受跨链交易，具体方法是：调用broker合约的audit方法，其参数依次是业务合约地址和合约状态（数字1表示审核通过，数字2表示审核失败）。 下面以Ethereum和Fabric为例进行介绍，其它类型的应用链部署跨链合约的步骤基本上是一致的。 Ethereum 在Ethereum上部署合约的工具有很多，您可以使 Remix 进行合约的编译和部署，这里关键的是跨链合约的获取。可以在 pier-client-ethereum项目 的exampe文件夹中获取。 说明： 1. 合约文件就在项目的example目录下，broker.sol是跨链管理合约，transfer.sol是示例业务合约； 2. 首先部署broker合约，然后将返回的合约地址填入transfer合约中的 BrokerAddr 字段，这样业务合约才能正确跨链调用。 Fabric 在Fabric上部署跨链合约工具一般是fabric-cli（可以参考 官方项目的使用说明 ）， 在Fabric上部署跨链合约的过程和部署其它合约没有区别，只是合约名称和代码文件需要替换，以下操作的命令可供参考，默认应用链是使用的fabric-sample项目的v1.4.3版本部署。 Step1: 安装部署合约的工具fabric-cli go get github.com/securekey/fabric-examples/fabric-cli/cmd/fabric-cli Step2: 获取需要部署的合约文件并解压 git clone https://github.com/meshplus/pier-client-fabric.git cd pier-client-fabric && git checkout v1.6.2 # 需要部署的合约文件就在example目录下 #解压即可 unzip -q contracts.zip Step3: 部署broker、transfer合约 #安装和示例化broker合约 fabric-cli chaincode install --gopath ./contracts --ccp broker --ccid broker --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel fabric-cli chaincode instantiate --ccp broker --ccid broker --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel #安装和示例化transfer合约 fabric-cli chaincode install --gopath ./contracts --ccp transfer --ccid transfer --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel fabric-cli chaincode instantiate --ccp transfer --ccid transfer --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel #业务合约需要broker管理合约审计后，才能进行跨链交易 fabric-cli chaincode invoke --cid mychannel --ccid=broker \\ --args='{\"Func\":\"audit\", \"Args\":[\"mychannel\", \"transfer\", \"1\"]}' \\ --user Admin --orgid org2 --payload --config \"${CONFIG_YAML}\" 获取部署包和修改Pier配置 这一章是要获取部署包和修改Pier的配置，为启动pier节点作准备，主要分为pier本身和应用链插件的配置修改。可以通过源码编译和二进制下载的方式获取部署包。 获取部署包 Ethereum 源码下载编译 # 编译跨链网关本身 cd $HOME git clone https://github.com/meshplus/pier.git cd pier && git checkout v1.6.2 make prepare && make build # 编译Ethereum 插件 cd $HOME git clone https://github.com/meshplus/pier-client-ethereum.git cd pier-client-ethereum && git checkout v1.6.2 make eth # 说明：1.ethereum插件编译之后会在插件项目的build目录生成eth-client文件； 2.pier编译之后会在跨链网关项目bin目录生成同名的二进制文件，需要将它拷贝到配置主目录方便后续执行。 二进制下载 除了源码编译外，我们也提供了直接下载Pier及其插件二进制的方式，下载地址链接如下： Pier二进制包下载 和 ethereum插件二进制包下载 链接中已经包含了所需的二进制程序和依赖库，您只需跟据操作系统的实际情况进行选择和下载即可。 Fabric 源码下载编译 # 编译跨链网关本身 cd $HOME git clone https://github.com/meshplus/pier.git cd pier && git checkout v1.6.2 make prepare && make build # 编译Fabric插件 cd $HOME git clone https://github.com/meshplus/pier-client-fabric.git cd pier-client-fabric && git checkout v1.6.2 make fabric1.4 # 说明：1.fabric插件编译之后会在插件项目的build目录生成fabric-client-1.4文件； 2.pier编译之后会在跨链网关项目bin目录生成同名的二进制文件，需要将它拷贝到配置主目录方便后续执行。 二进制下载 除了源码编译外，我们也提供了直接下载Pier及其插件二进制的方式，下载地址链接如下： Pier二进制包下载 和 fabric插件二进制包下载 链接中已经包含了所需的二进制程序和依赖库，您只需跟据操作系统的实际情况进行选择和下载即可。 经过以上的步骤，相信您已经编译出了部署Pier和fabric/ethereum应用链插件的二进制文件，Pier节点运行还需要外部依赖库，均在项目build目录下（Macos使用libwasmer.dylib，Linux使用libwasmer.so）,建议将得到的二进制和适配的依赖库文件拷贝到同一目录，然后使用 export LD_LIBRARY_PATH=$(pwd) 命令指定依赖文件的路径，方便之后的操作。 修改Pier配置 在进行应用链注册、验证规则部署等步骤之前，需要初始化跨链网关的配置目录，以用户目录下的pier为例： ./pier --repo=~/.pier init 该命令会生成跨链网关的一些基础配置文件模板，使用 tree 命令可查看目录信息： tree -L 1 ~/.pier ├── api ├── certs ├── key.json ├── node.priv └── pier.toml 1 directory, 4 files pier.toml是描述链跨链网关启动的主要配置，一般需要修改的是端口信息、中继链的信息、应用链的信息。 修改端口信息 [port] # 如果不冲突的话，可以不用修改 http = 44544 pprof = 44555 修改中继链信息（一般只修改addrs字段，指定bitxhub的节点地址） [mode] type = \"relay\" # relay or direct [mode.relay] addrs = [\"localhost:60011\", \"localhost:60012\", \"localhost:60013\", \"localhost:60014\"] quorum = 2 validators = [ \"0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd\", \"0xe93b92f1da08f925bdee44e91e7768380ae83307\", \"0xb18c8575e3284e79b92100025a31378feb8100d6\", \"0x856E2B9A5FA82FD1B031D1FF6863864DBAC7995D\", ] 修改应用链信息（针对不同应用链类型进行配置） Ethereum [appchain] # ethereum插件文件的名称 plugin = \"eth-client\" # ethereum配置文件夹在跨链网关配置文件夹下的相对路径 config = \"ether\" Fabric [appchain] # fabric插件文件的名称 plugin = \"fabric-client-1.4\" # ethereum配置文件夹在跨链网关配置文件夹下的相对路径 config = \"fabric\" 修改应用链插件的配置 应用链插件的配置目录即是pier.toml中的config字段，它的模板在 pier-client-ethereum 或 pier-client-ethereum 项目（之前拉取跨链合约时已经clone），直接在GitHub上下载代码即可。 Ethereum # 将ethereum插件拷贝到plugins目录下 cp ether-client ~/.pier/plugins/ # 切换到pier-client-ethereum项目路径下 cd pier-client-ethereum cp ./config $HOME /.pier/ether ​ 其中重要配置如下： ├── account.key ├── broker.abi ├── ether.validators ├── ethereum.toml ├── password └── validating.wasm 说明**： account.key和password建议换成应用链上的真实账户，且须保证有一定金额（ethereum上调用合约需要gas费） broker.abi可以使用示例，也可以使用您自己编译/部署broker合约时返回的abi； ether.validators和validating.wasm一般不需要修改。 ethereum.toml是需要重点修改的，需要根据应用链实际情况填写**ethereum网络地址**、broker合约地址及业务合约abi**，账户的key等，示例如下： [ether] addr = \"wss://kovan.infura.io/ws/v3/cc512c8c74c94938aef1c833e1b50b9a\" name = \"ether-kovan\" ## 此处合约地址需要替换成变量代表的实际字符串 contract_address = \"$brokerAddr\" abi_path = \"broker.abi\" key_path = \"account.key\" password = \"password\" min_confirm = 1 [contract_abi] \"($transfer) Addr\"=\"transfer.abi\" Fabric # 将fabric插件拷贝到plugins目录下 cp fabric-client-1.4 ~/.pier/plugins/ # 切换到pier-client-fabric项目路径下 cd pier-client-fabric cp ./config $HOME /.pier/fabric 其中重要配置如下： ├── crypto-config/ ├── config.yaml ├── fabric.toml ├── fabric.validators └── validating.wasm 接下来主要修改Fabric网络配置，验证证书，跨链合约设置： fabric证书配置 启动Fabric网络时，会生成所有节点（包括Order、peer等）的证书信息，并保存在 crypto-config文件夹中，Fabric插件和Fabric交互时需要用到这些证书。 # 复制您所部署的Fabric所产生的crypto-config文件夹 cp -r /path/to/crypto-config $HOME/.pier/fabric/ # 复制Fabric上验证人证书 cp $HOME/.pier/fabric/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp/signcerts/peer1.org2.example.com-cert.pem $HOME/.pier/fabric/fabric.validators 2. 修改Plugin配置文件config.yaml config.yaml 文件记录的Fabric网络配置（用您的网络拓扑配置文件替换这个样例文件），需要使用绝对路径，把所有的路径都修改为 crypto-config 文件夹所在的绝对路径。 {CONFIG_PATH}/fabric/crypto-config =>～/.pier/fabric/crypto-config # 替换为您部署的Fabric网络的拓扑设置文件即可，同时需要修改所有的Fabric 的IP地址，如： url: grpcs://localhost:7050 => url: grpcs://10.1.16.48:7050 3. 修改Plugin配置文件 fabric.toml 示例是以官方部署脚本进行配置： addr = \"localhost:7053\" // 若Fabric部署在服务器上，该为服务器地址 event_filter = \"interchain-event-name\" username = \"Admin\" ccid = \"broker\" // 若部署跨链broker合约名字不是broker需要修改 channel_id = \"mychannel\" org = \"org2\" 至此，对接ethereum和fabric应用链的pier及其插件的配置已经完成，接下来需要进行应用链注册和验证规则部署后，再启动pier节点。 注册应用链 在启动跨链网关Pier之前，需要先注册应用链并部署验证规则，这些操作均是Pier命令行发起。需要注意的是，在v1.6.0及以上的版本，注册应用链需要中继链BitXHub节点管理员进行投票，投票通过之后才能接入。这一步Ethereum和Fabric（包括其它类型应用链）的流程一样，只是注册信息有所不同，以下是以Ethereum为例进行说明： Pier命令行发起应用链注册 # 以用户目录下的pier为例 ./pier --repo ~/.pier appchain register --name=ethereum --type=ether --consensusType POS --validators=~/.pier1/ether/ether.validators --desc=\"ethereum appchain for test\" --version=1.0.0 # 发起注册后会打印出应用链id和提案id appchain register successfully, chain id is 0xcb33b10104cd217aAB4b302e9BbeEd1957EDaA31, proposal id is 0xcb33b10104cd217aAB4b302e9BbeEd1957EDaA31-0 中继链节点依次投票 # 进入bitxhub节点的安装目录，用上一步得到的提案id进行投票 ./bitxhub --repo ../node1 client governance vote --id 0xcb33b10104cd217aAB4b302e9BbeEd1957EDaA31-0 --info approve --reason approve # 投票完后会打印：vote successfully! # 如果是多个bitxhub节点组成的集群，依次指定各节点的安装目录进行投票 当BitXHub集群超过半数的管理员投票通过后，应用链注册成功（如果BitXHub是solo模式，则只需要一票同意即可） ，可以通过如下命令查询提案状态： ./bitxhub --repo ../node1 client governance proposals --type AppchainMgr 部署验证规则 应用链只有在可用状态下可以部署验证规则，即需要应用链注册成功且中继链投票通过后才可以进行规则部署。之前已经准备好了验证规则文件，接下来在Pier端发起部署验证规则的命令。 Ethereum #以用户目录下的pier为例 pier --repo ~/.pier rule deploy --path=~/.pier/ether/validating.wasm Fabric #以用户目录下的pier为例 pier --repo ~/.pier rule deploy --path=~/.pier/fabric/validating.wasm 启动跨链网关节点 在完成以上步骤之后，可以启动跨链网关节点了 #以用户目录下的pier为例 ./pier --repo=~/.pier start 观察日志信息没有报错信息，可以正常同步到中继链上的区块信息，即说明pier启动成功。","text_tokens":["eth","说明","url","包含","信息","上","各","您","为","端口","step1","get","node1","不","cert","0xcb33b10104cd217aab4b302e9bbeed1957edaa31","包","合约","directory","如果","具体方法","$","区块","兴趣","基本上","validating","主目录","0x856e2b9a5fa82fd1b031d1ff6863864dbac7995d","中继","以","_","step2","io","ccid","需","用","rule","并","一般","操作","cc512c8c74c94938aef1c833e1b50b9a","依次","进入","链接","务器","ws","=","examples","。","clone","peer","启动","'","可","这样","wasm","cita","不同","默认","fabric1.4","库",",","能够","编译","好","完成","linux","solo","返回","invoke","关节","即可","test","certs","产生","1.4","完后","instantiate","区别","依赖","拷贝到","出","开发","发起","或","sample","插件","种类","使","中","prepare","tree","gas","kovan","https","换成","运行","设置","确认","start","com","参与","validators","client","-","chaincode","外部","相对","bitxhub"," ","投票","3","和","绝对","之后","macos","org","remix","组成","执行","当","..","key","有所不同","解压","r","服务器","下载","自己","（","libwasmer","可供","管理","保存","据","&&","业务","44555","若","账户","governance","拷贝","broker","从而","这","abi","0xb18c8575e3284e79b92100025a31378feb8100d6","1.0","到","网","部署","[","用户","deploy","register","流程","bin","plugin","此处","consensustype","ip地址","官方","绝对路径","l","五个","查看","名字","一样","对接","其它","数字","plugins","保证","目前","失败","：","可用","是","这里","一致","成功","mychannel","priv","pem","关节点",":","工具","api","规则","只","证书","费","在","mode","interchain","transfer","指定","其","0","系统","or","account","注意","peer1","一些","yaml","接下","ethereum","后","的","没有","交易","则","不用","对应","使用","先","管理员","name","所","替换成","同时","文件夹","password","v1.4","audit",">","for","info","└","实现","调用","集群","～","经过","repo","过程","字段","16.48","接入","包括","44544","direct","zip","命令","step3","config","首先","export","提案","金额","路径","网络拓扑","github","ccp","crypto","其中","go","均","配置","再启动","ld","cli","cd","so","记录","情况","还","冲突","也","peers","人","library","方法","项目","这个","分为","修改","git","然后","复制","地址","一票","初始化","7050","1","重要","infura","ether","其他","id","orgid","!","cp","如","to","至此","具体","日志","relay","字符串","is","desc","选择","json","及其","代表","脚本","名称","version","作","bcos","类型","event","验证","confirm","10.1","入","段","address","所在","）","获取","0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd","针对","会","即","appchainmgr","程序","网络地址","cmd","之前","7053","brokeraddr","接下来","描述","init","链上","reason","/","关键","状态","化","及","#","命令行","下面","报错","proposals","正确","signcerts","sol","vote","pier","checkout","后续","用到","60012","func","介绍","appchain","已经","q","且","支持","链","除了","\"","pier1","user","files","pprof","填入",")","文件","查询","提供","home","基础","toml","0xe93b92f1da08f925bdee44e91e7768380ae83307","等","admin","order","注册","--","供参考","要","以上","args","4","unzip","securekey","chain","相信","接受","##","端","可以","username","主要","进制","切换","时","需要","打印","quorum","基本","~","得到","很多","successfully","参考","应用","相对路径","表示","观察","把","就","超过","拓扑","模板","示例","准备","半数","实际","适配","同名","​","]","；","简称","}","example","一定","一步","通过","contracts","(","所有","跟","模式","type","才","proposal","下来","pos","快速","确定","真实","可供参考","将","重点","生成","├","操作系统","建议","配置文件","审计","同一","节点","peerorganizations","grpcs","port","件夹","有","外","localhost","exampe","另外","payload","v3","不是","filter","参数","拉取","变量","make","60013","须","便捷","contract","审核","cid","wss","方式","一章","fabric","提前","v1.6","填写","进行","如下",".","根据","方便","pwd","安装","build","都","addr","这些","node","的话","gopath","样例","*","平台","min","2","\\","下","多个","链是","五种","字","同意","为例","60014","代码","二进制","目录","交互","直接","字符","─","meshplus","hyperchain","它","approve","只有","dylib","addrs","正常","跨链","网络","此","、","才能","install","初始","我们","步骤","只是","msp","path","channel","60011","http","替换","版本","本身","同步","，","网关","服务","org2","了","源码","有所","该","以下","{"],"title":"跨链网关部署","title_tokens":["网关","跨链","部署"]},{"location":"bitxhub/usage/single_bitxhub/deploy_pier/#_1","text":"跨链网关Pier能够支持业务所在区块链（以下简称 应用链）便捷、快速的接入到跨链平台BitXHub中，从而实现和其他业务区块链的跨链操作。目前中继链和跨链网关已经支持 Fabric 、 Ethereum 、 BCOS 、 CITA 和 Hyperchain 五种应用链接入并完成跨链交易，如果您有兴趣，也可以参与开发适配另外种类应用链的插件和合约。 跨链网关的部署需要提前确定应用链类型（对应不同的插件和配置），也需要提前在对应的应用链上部署跨链合约，我们将跨链网关的部署依次分为如下五个步骤： 部署跨链合约 获取部署包和修改Pier配置 注册应用链信息 部署验证规则 启动跨链网关","text_tokens":["从而","信息","到","您","其他","适配","部署","包","简称","合约","五个","如果","区块","兴趣","目前","中继","bcos","类型","验证","入","：","快速","所在","并","获取","确定","）","将","操作","依次","规则","在","链接","链上","有","另外","。","ethereum","的","启动","交易","cita","对应","不同","pier","能够","已经","便捷","支持","完成","链","实现","fabric","提前","如下","接入","开发","平台","插件","种类","中","五种","注册","参与","配置","bitxhub"," ","hyperchain","可以","和","跨链","、","也","需要","我们","步骤","分为","，","修改","网关","（","应用","业务","以下"],"title":"跨链网关部署","title_tokens":["网关","跨链","部署"]},{"location":"bitxhub/usage/single_bitxhub/deploy_pier/#_2","text":"这一章是要在应用链上部署跨链合约， 注意：在此操作之前，您需要确认已经部署有可接入的应用链 。 我们提供了针对不同应用链的跨链合约，broker合约是管理合约，transfer合约是业务交易合约，需要说明的是 transfer合约需要经过broker合约审核通过后才能发起或接受跨链交易，具体方法是：调用broker合约的audit方法，其参数依次是业务合约地址和合约状态（数字1表示审核通过，数字2表示审核失败）。 下面以Ethereum和Fabric为例进行介绍，其它类型的应用链部署跨链合约的步骤基本上是一致的。 Ethereum 在Ethereum上部署合约的工具有很多，您可以使 Remix 进行合约的编译和部署，这里关键的是跨链合约的获取。可以在 pier-client-ethereum项目 的exampe文件夹中获取。 说明： 1. 合约文件就在项目的example目录下，broker.sol是跨链管理合约，transfer.sol是示例业务合约； 2. 首先部署broker合约，然后将返回的合约地址填入transfer合约中的 BrokerAddr 字段，这样业务合约才能正确跨链调用。 Fabric 在Fabric上部署跨链合约工具一般是fabric-cli（可以参考 官方项目的使用说明 ）， 在Fabric上部署跨链合约的过程和部署其它合约没有区别，只是合约名称和代码文件需要替换，以下操作的命令可供参考，默认应用链是使用的fabric-sample项目的v1.4.3版本部署。 Step1: 安装部署合约的工具fabric-cli go get github.com/securekey/fabric-examples/fabric-cli/cmd/fabric-cli Step2: 获取需要部署的合约文件并解压 git clone https://github.com/meshplus/pier-client-fabric.git cd pier-client-fabric && git checkout v1.6.2 # 需要部署的合约文件就在example目录下 #解压即可 unzip -q contracts.zip Step3: 部署broker、transfer合约 #安装和示例化broker合约 fabric-cli chaincode install --gopath ./contracts --ccp broker --ccid broker --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel fabric-cli chaincode instantiate --ccp broker --ccid broker --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel #安装和示例化transfer合约 fabric-cli chaincode install --gopath ./contracts --ccp transfer --ccid transfer --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel fabric-cli chaincode instantiate --ccp transfer --ccid transfer --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel #业务合约需要broker管理合约审计后，才能进行跨链交易 fabric-cli chaincode invoke --cid mychannel --ccid=broker \\ --args='{\"Func\":\"audit\", \"Args\":[\"mychannel\", \"transfer\", \"1\"]}' \\ --user Admin --orgid org2 --payload --config \"${CONFIG_YAML}\"","text_tokens":["broker","这","说明","示例","上","您","部署","[","step1","get","orgid","]","；","}","合约","example","官方","通过","contracts","具体","具体方法","$","{","基本上","其它","数字","名称","失败","以","_","类型","step2","：","是","ccid","这里","段","一致","）","获取","并","mychannel","针对","一般","可供参考","将",":","操作","工具","依次","在","cmd","之前","transfer","其","brokeraddr","审计","链上","件夹","有","=","注意","/","exampe","关键","状态","化","yaml","examples","。","clone","payload","ethereum","后","#","的","没有","'","可","这样","交易","下面","不同","默认","使用","参数","&&","正确","sol","pier","checkout","文件夹","func","介绍","v1.4",",","已经","audit","编译","q","链","审核","cid","\"","返回","invoke","user","调用","一章","填入","fabric","v1.6","经过","进行","即可","过程",".","文件","安装","instantiate","区别","接入","提供","zip","命令","step3","gopath","首先","config","发起","或","sample","使","中","2","admin","下","\\","https","链是","字","为例","确认","github","--","ccp","com","代码","供参考","要","go","目录","client","-","chaincode","args","meshplus"," ","unzip","3","securekey","接受","cli","cd","可以","和","跨链","此","、","remix","才能","install","需要","我们","步骤","只是","方法","解压","项目","替换","版本","，","基本","（","git","org2","很多","然后","地址","参考","可供","应用","了","管理","表示","业务","就","以下","1"],"title":"部署跨链合约","title_tokens":["合约","跨链","部署"]},{"location":"bitxhub/usage/single_bitxhub/deploy_pier/#pier","text":"这一章是要获取部署包和修改Pier的配置，为启动pier节点作准备，主要分为pier本身和应用链插件的配置修改。可以通过源码编译和二进制下载的方式获取部署包。","text_tokens":["这","编译","二进制","要","准备","链","为","配置","部署","方式","一章","包","节点","可以","和","通过","主要","进制","。","的","启动","作","分为","本身","下载","，","修改","插件","是","应用","pier","源码","获取"],"title":"获取部署包和修改Pier配置","title_tokens":["修改","包","和","pier","配置","获取","部署"]},{"location":"bitxhub/usage/single_bitxhub/deploy_pier/#_3","text":"Ethereum 源码下载编译 # 编译跨链网关本身 cd $HOME git clone https://github.com/meshplus/pier.git cd pier && git checkout v1.6.2 make prepare && make build # 编译Ethereum 插件 cd $HOME git clone https://github.com/meshplus/pier-client-ethereum.git cd pier-client-ethereum && git checkout v1.6.2 make eth # 说明：1.ethereum插件编译之后会在插件项目的build目录生成eth-client文件； 2.pier编译之后会在跨链网关项目bin目录生成同名的二进制文件，需要将它拷贝到配置主目录方便后续执行。 二进制下载 除了源码编译外，我们也提供了直接下载Pier及其插件二进制的方式，下载地址链接如下： Pier二进制包下载 和 ethereum插件二进制包下载 链接中已经包含了所需的二进制程序和依赖库，您只需跟据操作系统的实际情况进行选择和下载即可。 Fabric 源码下载编译 # 编译跨链网关本身 cd $HOME git clone https://github.com/meshplus/pier.git cd pier && git checkout v1.6.2 make prepare && make build # 编译Fabric插件 cd $HOME git clone https://github.com/meshplus/pier-client-fabric.git cd pier-client-fabric && git checkout v1.6.2 make fabric1.4 # 说明：1.fabric插件编译之后会在插件项目的build目录生成fabric-client-1.4文件； 2.pier编译之后会在跨链网关项目bin目录生成同名的二进制文件，需要将它拷贝到配置主目录方便后续执行。 二进制下载 除了源码编译外，我们也提供了直接下载Pier及其插件二进制的方式，下载地址链接如下： Pier二进制包下载 和 fabric插件二进制包下载 链接中已经包含了所需的二进制程序和依赖库，您只需跟据操作系统的实际情况进行选择和下载即可。 经过以上的步骤，相信您已经编译出了部署Pier和fabric/ethereum应用链插件的二进制文件，Pier节点运行还需要外部依赖库，均在项目build目录下（Macos使用libwasmer.dylib，Linux使用libwasmer.so）,建议将得到的二进制和适配的依赖库文件拷贝到同一目录，然后使用 export LD_LIBRARY_PATH=$(pwd) 命令指定依赖文件的路径，方便之后的操作。","text_tokens":["拷贝","eth","说明","包含","您","实际","部署","同名","适配","；","bin","包","$","选择","(","及其","跟","主目录","_","：","需","）","会","将",":","操作","生成","只","程序","在","指定","操作系统","链接","建议","同一","节点","系统","=","外","/","。","clone","ethereum","#","的","使用","checkout","后续","pier","所","fabric1.4","库","make",",","编译","已经","linux","链","除了","方式","v1.6","fabric",")","即可","进行","经过","如下",".","文件","1.4","方便","pwd","build","依赖","拷贝到","出","提供","home","命令","export","源码","插件","路径","prepare","中","2","下","https","运行","github","com","二进制","目录","client","-","直接","均","以上","配置","外部","meshplus"," ","ld","相信","它","cd","dylib","so","和","跨链","情况","还","之后","macos","进制","执行","也","需要","我们","步骤","path","library","项目","本身","下载","，","网关","git","（","libwasmer","得到","然后","地址","了","应用","据","&&","1"],"title":"获取部署包","title_tokens":["包","获取","部署"]},{"location":"bitxhub/usage/single_bitxhub/deploy_pier/#pier_1","text":"在进行应用链注册、验证规则部署等步骤之前，需要初始化跨链网关的配置目录，以用户目录下的pier为例： ./pier --repo=~/.pier init 该命令会生成跨链网关的一些基础配置文件模板，使用 tree 命令可查看目录信息： tree -L 1 ~/.pier ├── api ├── certs ├── key.json ├── node.priv └── pier.toml 1 directory, 4 files pier.toml是描述链跨链网关启动的主要配置，一般需要修改的是端口信息、中继链的信息、应用链的信息。 修改端口信息 [port] # 如果不冲突的话，可以不用修改 http = 44544 pprof = 44555 修改中继链信息（一般只修改addrs字段，指定bitxhub的节点地址） [mode] type = \"relay\" # relay or direct [mode.relay] addrs = [\"localhost:60011\", \"localhost:60012\", \"localhost:60013\", \"localhost:60014\"] quorum = 2 validators = [ \"0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd\", \"0xe93b92f1da08f925bdee44e91e7768380ae83307\", \"0xb18c8575e3284e79b92100025a31378feb8100d6\", \"0x856E2B9A5FA82FD1B031D1FF6863864DBAC7995D\", ] 修改应用链信息（针对不同应用链类型进行配置） Ethereum [appchain] # ethereum插件文件的名称 plugin = \"eth-client\" # ethereum配置文件夹在跨链网关配置文件夹下的相对路径 config = \"ether\" Fabric [appchain] # fabric插件文件的名称 plugin = \"fabric-client-1.4\" # ethereum配置文件夹在跨链网关配置文件夹下的相对路径 config = \"fabric\"","text_tokens":["模板","eth","0xb18c8575e3284e79b92100025a31378feb8100d6","信息","ether","端口","部署","[","用户","不","]","plugin","l","directory","如果","relay","查看","json","0x856e2b9a5fa82fd1b031d1ff6863864dbac7995d","名称","中继","以","类型","验证","type","：","是","）","priv","0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd","针对","会","一般",":","api","生成","规则","只","在","mode","├","之前","指定","配置文件","描述","节点","init","port","or","件夹","=","/","localhost","一些","。","ethereum","#","的","启动","可","不用","不同","使用","pier","60012","文件夹","60013","appchain",",","└","链","\"","files","pprof","fabric","进行","repo","certs","字段",".","文件","1.4","node","的话","44544","direct","基础","命令","config","toml","插件","路径","0xe93b92f1da08f925bdee44e91e7768380ae83307","等","tree","2","下","为例","注册","--","60014","validators","目录","client","-","配置","4","─","bitxhub"," ","相对","addrs","可以","跨链","冲突","、","主要","初始","需要","步骤","key","quorum","60011","http","，","修改","网关","~","（","地址","应用","初始化","相对路径","44555","该","1"],"title":"修改Pier配置","title_tokens":["pier","配置","修改"]},{"location":"bitxhub/usage/single_bitxhub/deploy_pier/#_4","text":"应用链插件的配置目录即是pier.toml中的config字段，它的模板在 pier-client-ethereum 或 pier-client-ethereum 项目（之前拉取跨链合约时已经clone），直接在GitHub上下载代码即可。 Ethereum # 将ethereum插件拷贝到plugins目录下 cp ether-client ~/.pier/plugins/ # 切换到pier-client-ethereum项目路径下 cd pier-client-ethereum cp ./config $HOME /.pier/ether ​ 其中重要配置如下： ├── account.key ├── broker.abi ├── ether.validators ├── ethereum.toml ├── password └── validating.wasm 说明**： account.key和password建议换成应用链上的真实账户，且须保证有一定金额（ethereum上调用合约需要gas费） broker.abi可以使用示例，也可以使用您自己编译/部署broker合约时返回的abi； ether.validators和validating.wasm一般不需要修改。 ethereum.toml是需要重点修改的，需要根据应用链实际情况填写**ethereum网络地址**、broker合约地址及业务合约abi**，账户的key等，示例如下： [ether] addr = \"wss://kovan.infura.io/ws/v3/cc512c8c74c94938aef1c833e1b50b9a\" name = \"ether-kovan\" ## 此处合约地址需要替换成变量代表的实际字符串 contract_address = \"$brokerAddr\" abi_path = \"broker.abi\" key_path = \"account.key\" password = \"password\" min_confirm = 1 [contract_abi] \"($transfer) Addr\"=\"transfer.abi\" Fabric # 将fabric插件拷贝到plugins目录下 cp fabric-client-1.4 ~/.pier/plugins/ # 切换到pier-client-fabric项目路径下 cd pier-client-fabric cp ./config $HOME /.pier/fabric 其中重要配置如下： ├── crypto-config/ ├── config.yaml ├── fabric.toml ├── fabric.validators └── validating.wasm 接下来主要修改Fabric网络配置，验证证书，跨链合约设置： fabric证书配置 启动Fabric网络时，会生成所有节点（包括Order、peer等）的证书信息，并保存在 crypto-config文件夹中，Fabric插件和Fabric交互时需要用到这些证书。 # 复制您所部署的Fabric所产生的crypto-config文件夹 cp -r /path/to/crypto-config $HOME/.pier/fabric/ # 复制Fabric上验证人证书 cp $HOME/.pier/fabric/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp/signcerts/peer1.org2.example.com-cert.pem $HOME/.pier/fabric/fabric.validators 2. 修改Plugin配置文件config.yaml config.yaml 文件记录的Fabric网络配置（用您的网络拓扑配置文件替换这个样例文件），需要使用绝对路径，把所有的路径都修改为 crypto-config 文件夹所在的绝对路径。 {CONFIG_PATH}/fabric/crypto-config =>～/.pier/fabric/crypto-config # 替换为您部署的Fabric网络的拓扑设置文件即可，同时需要修改所有的Fabric 的IP地址，如： url: grpcs://localhost:7050 => url: grpcs://10.1.16.48:7050 3. 修改Plugin配置文件 fabric.toml 示例是以官方部署脚本进行配置： addr = \"localhost:7053\" // 若Fabric部署在服务器上，该为服务器地址 event_filter = \"interchain-event-name\" username = \"Admin\" ccid = \"broker\" // 若部署跨链broker合约名字不是broker需要修改 channel_id = \"mychannel\" org = \"org2\" 至此，对接ethereum和fabric应用链的pier及其插件的配置已经完成，接下来需要进行应用链注册和验证规则部署后，再启动pier节点。","text_tokens":["拷贝","broker","拓扑","模板","重要","abi","说明","infura","url","把","示例","上","到","ether","您","信息","为","部署","实际","[","id","​","不","]","cert","cp","；","此处","合约","to","example","plugin","一定","绝对路径","}","ip地址","官方","至此","$","{","字符串","名字","(","对接","及其","所有","validating","代表","plugins","保证","脚本","_","以","event","验证","confirm","io","10.1","：","是","用","ccid","address","下来","所在","）","并","pem","mychannel","真实","一般","会","将","即",":","重点","cc512c8c74c94938aef1c833e1b50b9a","生成","规则","证书","费","在","网络地址","├","之前","interchain","transfer","7053","brokeraddr","建议","务器","接下来","ws","peerorganizations","节点","配置文件","grpcs","该","链上","件夹","account","有","=","peer1","/","localhost","yaml","接下","。","clone","及","ethereum","#","peer","后","的","启动","v3","不是","wasm","filter","使用","拉取","变量","signcerts","pier","用到","name","所","替换成","同时","文件夹","password","已经","须","且","编译",">","contract","└","链","完成","wss","\"","返回","调用","fabric",")","～","即可","填写","进行","如下","字段",".","根据","文件","1.4","产生","16.48","包括","都","addr","这些","拷贝到","home","config","样例","或","toml","*","金额","插件","路径","如","中","网络拓扑","等","gas","min","2","下","kovan","admin","换成","设置","order","注册","github","crypto","其中","com","代码","validators","目录","client","-","直接","交互","字符","配置","再启动","─"," ","3","它","cd","##","可以","记录","和","跨链","情况","绝对","网络","username","org","、","主要","切换","也","时","需要","人","peers","msp","path","key","channel","项目","这个","r","替换","服务器","下载","，","修改","自己","（","~","org2","服务","复制","地址","应用","保存","业务","7050","若","1","账户"],"title":"修改应用链插件的配置","title_tokens":["修改","插件","的","应用","链","配置"]},{"location":"bitxhub/usage/single_bitxhub/deploy_pier/#_5","text":"在启动跨链网关Pier之前，需要先注册应用链并部署验证规则，这些操作均是Pier命令行发起。需要注意的是，在v1.6.0及以上的版本，注册应用链需要中继链BitXHub节点管理员进行投票，投票通过之后才能接入。这一步Ethereum和Fabric（包括其它类型应用链）的流程一样，只是注册信息有所不同，以下是以Ethereum为例进行说明： Pier命令行发起应用链注册 # 以用户目录下的pier为例 ./pier --repo ~/.pier appchain register --name=ethereum --type=ether --consensusType POS --validators=~/.pier1/ether/ether.validators --desc=\"ethereum appchain for test\" --version=1.0.0 # 发起注册后会打印出应用链id和提案id appchain register successfully, chain id is 0xcb33b10104cd217aAB4b302e9BbeEd1957EDaA31, proposal id is 0xcb33b10104cd217aAB4b302e9BbeEd1957EDaA31-0 中继链节点依次投票 # 进入bitxhub节点的安装目录，用上一步得到的提案id进行投票 ./bitxhub --repo ../node1 client governance vote --id 0xcb33b10104cd217aAB4b302e9BbeEd1957EDaA31-0 --info approve --reason approve # 投票完后会打印：vote successfully! # 如果是多个bitxhub节点组成的集群，依次指定各节点的安装目录进行投票 当BitXHub集群超过半数的管理员投票通过后，应用链注册成功（如果BitXHub是solo模式，则只需要一票同意即可） ，可以通过如下命令查询提案状态： ./bitxhub --repo ../node1 client governance proposals --type AppchainMgr","text_tokens":["governance","超过","这","说明","1.0","信息","上","各","ether","半数","部署","用户","register","id","node1","流程","!","0xcb33b10104cd217aab4b302e9bbeed1957edaa31","consensustype","一步","通过","如果","一样","desc","is","其它","中继","version","以","类型","模式","验证","type","：","是","用","proposal","pos","成功","）","并","会","操作","依次","规则","只","appchainmgr","在","之前","指定","进入","0","节点","reason","=","注意","/","状态","。","及","ethereum","#","后","的","启动","命令行","则","proposals","不同","先","管理员","vote","pier","name","appchain",",","for","info","链","solo","\"","pier1","v1.6","fabric","集群","即可","进行","repo","test","如下",".","安装","完后","接入","包括","查询","这些","出","命令","提案","发起","下","多个","同意","为例","注册","--","validators","目录","client","-","均","以上","bitxhub"," ","投票","chain","approve","可以","和","跨链","之后","组成","才能","需要","只是","当","..","打印","有所不同","版本","，","网关","（","~","得到","successfully","一票","应用","管理","有所","以下"],"title":"注册应用链","title_tokens":["注册","应用","链"]},{"location":"bitxhub/usage/single_bitxhub/deploy_pier/#_6","text":"应用链只有在可用状态下可以部署验证规则，即需要应用链注册成功且中继链投票通过后才可以进行规则部署。之前已经准备好了验证规则文件，接下来在Pier端发起部署验证规则的命令。 Ethereum #以用户目录下的pier为例 pier --repo ~/.pier rule deploy --path=~/.pier/ether/validating.wasm Fabric #以用户目录下的pier为例 pier --repo ~/.pier rule deploy --path=~/.pier/fabric/validating.wasm","text_tokens":["为例","注册","--","即","pier","已经","好","且","规则","目录","准备","在","链","ether","之前","部署","deploy"," ","用户","投票","只有","接下来","端","fabric","可以","通过","进行","repo",".","文件","=","/","状态","需要","接下","。","validating","ethereum","path","后","#","的","中继","命令","以","wasm","验证","，","才","发起","~","可用","应用","下","了","rule","下来","成功"],"title":"部署验证规则","title_tokens":["验证","部署","规则"]},{"location":"bitxhub/usage/single_bitxhub/deploy_pier/#_7","text":"在完成以上步骤之后，可以启动跨链网关节点了 #以用户目录下的pier为例 ./pier --repo=~/.pier start 观察日志信息没有报错信息，可以正常同步到中继链上的区块信息，即说明pier启动成功。","text_tokens":["为例","--","start","即","说明","目录","信息","到","完成","在","以上","网","用户"," ","关节","可以","节点","正常","跨链","repo","链上","成功","之后","日志",".","=","区块","/","步骤","。","观察","#","的","启动","没有","中继","以","同步","报错","，","~","了","下","pier","关节点"],"title":"启动跨链网关节点","title_tokens":["关节","节点","关节点","跨链","启动","网"]},{"location":"goduck/","text":"Goduck运维小工具 1 安装 1.1 获取源码 下载源码并切到稳定版本release-1.0 git clone git@github.com:meshplus/goduck cd goduck git checkout release-1.0 1.2 编译安装 make install 1.3 初始化 goduck init 使用之前一定要先初始化 2 使用 2.1 命令格式 goduck [global options] command [command options] [arguments...] command deploy 远程部署bitxhub和pier version 查看组件版本信息 init 初始化配置 status 列举实例化组件状态 key 创建并展示密钥信息 bitxhub 启动或关闭bithxub节点 pier 有关pier的操作 playground 一键启动跨链组件 info 展示跨链基本信息 prometheus 启动或关闭prometheus help, h 这些命令中，比较重要的是init（使用前一定要初始化）、status（查看当前运行组件状态）、bitxhub、pier。 global options --repo value goduck配置文件默认存储路径 --help, -h 2.2 关于BitXHub的操作 goduck bitxhub command [command options] [arguments...] 2.2.1 启动BitXHub节点 goduck bitxhub start 该命令会初始化并启动BitXHub节点，如果有已启动的BitXHub节点会执行失败。执行成功后提示如下： 1 BitXHub nodes at /Users/fangbaozhu/.goduck/bitxhub are initialized successfully exec: /bin/bash /Users/fangbaozhu/.goduck/playground.sh up v1.4.0 solo binary 4 Start bitxhub solo by binary ===> Start bitxhub solo successful 这是默认启动方式，也可以携带参数自定义启动，参数设置如下： --type value 配置类型，binary或docker （默认：“binary”） --mode value 配置模式，solo或cluster （默认：“solo”） --num value 节点个数，只在cluster 模式下作用（默认：4） --tls 是否启动TLS, 只在v1.4.0+版本有效 (default: false) --version value BitXHub版本 (default: \"v1.4.0\") --help, -h 2.2.2 为BitXHub节点生成配置文件 goduck bitxhub config 该命令默认初始化4个BitXHub节点。执行成功后当前文件夹会生成相关证书、私钥文件以及四个节点的文件夹，成功提示如下： initializing 4 BitXHub nodes at . 4 BitXHub nodes at . are initialized successfully You can see the following in the current directory： . ├── agency.cert ├── agency.priv ├── ca.cert ├── ca.priv ├── key.priv ├── node1/ ├── node2/ ├── node3/ └── node4/ 可以携带参数自定义配置情况： --num value 节点个数，只在cluster 模式下作用（默认：4） --type value 配置类型，binary或docker （默认：“binary”） --mode value 配置模式，solo或cluster （默认：“solo”） --ips value 节点IP, 默认所有节点为127.0.0.1, e.g. --ips \"127.0.0.1\" --ips \"127.0.0.2\" --ips \"127.0.0.3\" --ips \" 127.0.0.4\" --target value 节点的配置文件位置（默认：当前目录） --tls 是否启动TLS, 只在v1.4.0+版本有效 (default: false) --version value BitXHub版本 (default: \"v1.4.0\") --help, -h 2.2.3 关闭BitXHub节点 goduck bitxhub stop 该命令会关闭所有启动的BitXHub节点。执行成功后会提示里会给出关闭节点的id： exec: /bin/bash /Users/fangbaozhu/.goduck/playground.sh down ===> Stop bitxhub node pid:65246 exit 2.2.4 清除BitXHub节点 goduck bitxhub clean 该命令会清除bitxhub节点的配置文件。如果bitxhub节点没有关闭，会先关闭节点再清除配置文件。 当bitxhub solo节点成功在关闭后执行此命令，会打印出提示如下： exec: /bin/bash /Users/fangbaozhu/.goduck/playground.sh clean ===> Stop bitxhub ===> Clean bitxhub remove bitxhub configure nodeSolo 当bitxhub solo节点成功在未关闭的情况下执行此命令，会打印出提示如下： exec: /bin/bash /Users/fangbaozhu/.goduck/playground.sh clean ===> Stop bitxhub node pid:65686 exit ===> Clean bitxhub remove bitxhub configure nodeSolo 2.3 关于pier的操作 GoDuck pier command [command options] [arguments...] 2.3.1 启动pier goduck pier start 参数设置如下： --chain value 应用链类型，ethereum 或 fabric（默认：ethereum） --cryptoPath value crypto-config路径, 只对fabric链有效, e.g $HOME/crypto-config --pier-type value pier类型，docker或者binary (默认: \"docker\") --version value pier版本 (默认: \"v1.4.0\") --tls value 是否启动TLS, true or false, 只对v1.4.0+版本有效 (默认: \"false\") --http-port value pier的http端口号, 只对v1.4.0+版本有效 (默认: \"44544\") --pprof-port value pier的pprof端口号, 只对binary有效 (默认: \"44550\") --api-port value pier的api端口号, 只对binary有效 (默认: \"8080\") --overwrite value 当本地默认路径存在pier配置文件时是否重写配置 (默认: \"true\") --appchainIP value pier连接的应用链ip (默认: \"127.0.0.1\") --help, -h 在使用此命令之前，您需要启动一个相同版本的BitxHub和一个需要pier连接的应用链。如果应用链或bitxhub不存在，pier将无法启动，打印提示如下: exec: /bin/bash run_pier.sh up -m ethereum -t docker -r .pier_ethereum -v v1.4.0 -c -p 44550 -a 8080 ===> Start pier of ethereum-v1.4.0 in docker... ===> Start a new pier-ethereum container ===> Wait for ethereum-node container to start for seconds... 136d323b1418a026101515313dbbdafee240ac0f0c0d63b4f202304019e13e24 ===> Start pier fail 如果要连接的应用链和BitxHub已经启动，且PIER已经启动成功，打印提示如下: exec: /bin/bash run_pier.sh up -m ethereum -t docker -r .pier_ethereum -v v1.0.0-rc1 -c -p 44550 -a 8080 ===> Start pier of ethereum-v1.0.0-rc1 in docker... ===> Start a new pier-ethereum container ===> Wait for ethereum-node container to start for seconds... 351bd8e8eb8d5a1803690ac0cd9b77c274b775507f30cb6271164fb843442bfd ===> Start pier successfully 2.3.2 关闭pier goduck pier stop 该命令可以关闭pier，可以通过携带参数指定关闭那种类型应用链的pier 2.3.3 清除Pier goduck pier clean 该命令可以清除pier的配置文件，如果pier还没有关闭，该命令会先关闭pier再清除其配置文件。 2.3.4 生成Pier的配置文件 goduck pier config --mode value 配置模式, 直连模式或者中继模式(默认: \"direct\") --type value 配置类型, binary或者docker (默认: \"binary\") --bitxhub value BitXHub的地址，只在中继模式有效 --validators value BitXHub的验证人地址，只在中继模式有效, 例如 --validators \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\" --validators \"0x79a1215469FaB6f9c63c1816b45183AD3624bE34\" --validators \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\" --validators \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\" --port value pier的端口号，只在直连模式有效 (默认: 5001) --peers value 连接节点的地址，只在直连模式有效, 例如 --peers \" /ip4/127.0.0.1/tcp/4001/p2p/Qma1oh5JtrV24gfP9bFrVv4miGKz7AABpfJhZ4F2Z5ngmL\" --connectors value 待连接节点的地址，只在v1.4.0+版本的union模式有效, 例如 --connectors \" /ip4/127.0.0.1/tcp/4001/p2p/Qma1oh5JtrV24gfP9bFrVv4miGKz7AABpfJhZ4F2Z5ngmL\" --connectors \" /ip4/127.0.0.1/tcp/4002/p2p/Qma1oh5JtrV24gfP9bFrVv4miGKz7AABpfJhZ4F2Z5abcD\" --appchain-type value 应用链类型, ethereum或者fabric (默认: \"ethereum\") --appchain-IP value 应用链IP地址 (默认: \"127.0.0.1\") --target value 生成配置文件路径 (默认: \".\") --tls value 是否开启TLS，只在v1.4.0+版本有效 (默认: \"false\") --http-port value pier的http端口号, 只在v1.4.0+版本有效 (默认: \"44544\") --pprof-port value pier的pprof端口号 (默认: \"44550\") --api-port value pier的api端口号 (默认: \"8080\") --cryptoPath value crypto-config文件的路径，只对fabric链有效，例如 $HOME/crypto-config (default: \" $HOME/.goduck/crypto-config\") --version value pier版本 (默认: \"v1.4.0\") --help, -h","text_tokens":["2.3","关于","信息","您","为","端口","see","node1","未","不","cert","directory","如果","nodesolo","$","直连","0x79a1215469fab6f9c63c1816b45183ad3624be34","node4","有关","中继","configure","new","_","initialized","rc1","并","操作","clean","“","sh","本地","1.1","exit","=","存储","bithxub","clone","。","remove","启动","默认","或者","有效","例如","相同","global","已","提示","关闭",",","编译","再","solo","in","qma1oh5jtrv24gfp9bfrvv4migkz7aabpfjhz4f2z5ngml","0.2","run","重写","are","出","一键","或","tcp","中","运行","设置","start","com","以及","validators","help","-","对","fangbaozhu","bitxhub"," ","3","351bd8e8eb8d5a1803690ac0cd9b77c274b775507f30cb6271164fb843442bfd","和","执行","overwrite","当","p","key","2.2","r","can","下载","密钥","node2","（","exec","command","1.0","2.1","到","部署","[","deploy","bin","ip地址","开启","查看","following","清除","失败","：","136d323b1418a026101515313dbbdafee240ac0f0c0d63b4f202304019e13e24","是","成功","priv",":","工具","api","只","证书","在","mode","指定","其","0","appchainip","or","稳定","定义","65686","会先","1.3","ethereum","后","的","没有","default","使用","先","44550","ip","文件夹","v1.4","stop","connectors","一个",">","for","info","└","列举","无法","+","repo","运维小","参数设置","0x97c8b516d19edbf575d72a172af7f418be498c37","num","当前","连接","44544","direct","命令","config","私钥","路径","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013","github","crypto","v","配置","作用","cd","4002","情况","还","也","peers","人","v1.0","p2p","4001","a","git","bash","地址","携带","初始化","个数","口号","1","重要","g","创建","id","to","cluster","组件","0.4","是否","version","类型","qma1oh5jtrv24gfp9bfrvv4migkz7aabpfjhz4f2z5abcd","验证","65246","）","获取","存在","会","m","”","users","之前","arguments","init","这是","/","化","状态","里会","value","the","个","展示","pier","checkout","binary","pid","of","appchain","已经","且","up","goduck","链","\"","pprof","ip4",")","实例","status","文件","union","home","版本信息","e","比较","自定义","--","cryptopath","successful","1.2","要","container","5001","4","格式","by","chain","docker","可以","时","需要","四个","release","agency","打印","那种","基本","false","自定","successfully","应用","0.3","initializing","fail","ips","当前目录","true","]","t","给出","一定","通过","前","down","(","node3","所有","待","options","...","模式","type","at","位置","tls","将","prometheus","生成","current","0.1","├","配置文件","节点","nodes","相关","port","件夹","有","并切","@","端口号","playground","参数","c","make","wait","方式","fabric","如下",".","安装","这些","node","8080","2","下","目录","seconds","远程","h","─","meshplus","you","跨链","此","、","初始","install","127.0","http","版本","，","ca","target","源码","该"],"title":"Getting started","title_tokens":[" ","started","getting"]},{"location":"goduck/#goduck","text":"","text_tokens":[],"title":"Goduck运维小工具","title_tokens":["工具","运维小","goduck"]},{"location":"goduck/#1","text":"","text_tokens":[],"title":"1 安装","title_tokens":["安装","1"," "]},{"location":"goduck/#11","text":"下载源码并切到稳定版本release-1.0 git clone git@github.com:meshplus/goduck cd goduck git checkout release-1.0","text_tokens":["github",":","com","goduck","-","1.0","到","meshplus"," ","cd",".","稳定","/","release","clone","并切","@","版本","下载","git","checkout","源码"],"title":"1.1 获取源码","title_tokens":["1.1","获取","源码"," "]},{"location":"goduck/#12","text":"make install","text_tokens":["make","install"," "],"title":"1.2 编译安装","title_tokens":["编译","安装","1.2"," "]},{"location":"goduck/#13","text":"goduck init 使用之前一定要先初始化","text_tokens":["初始","使用","要","goduck","一定","先","init","初始化","之前"," "],"title":"1.3 初始化","title_tokens":["初始化","初始","1.3"," "]},{"location":"goduck/#2","text":"","text_tokens":[],"title":"2 使用","title_tokens":["2","使用"," "]},{"location":"goduck/#21","text":"goduck [global options] command [command options] [arguments...] command deploy 远程部署bitxhub和pier version 查看组件版本信息 init 初始化配置 status 列举实例化组件状态 key 创建并展示密钥信息 bitxhub 启动或关闭bithxub节点 pier 有关pier的操作 playground 一键启动跨链组件 info 展示跨链基本信息 prometheus 启动或关闭prometheus help, h 这些命令中，比较重要的是init（使用前一定要初始化）、status（查看当前运行组件状态）、bitxhub、pier。 global options --repo value goduck配置文件默认存储路径 --help, -h","text_tokens":["command","重要","信息","部署","deploy","[","创建","]","一定","前","查看","组件","options","有关","version","...","是","）","并","prometheus","操作","配置文件","arguments","节点","init","存储","化","状态","bithxub","。","的","启动","value","展示","默认","playground","使用","global","pier","关闭",",","goduck","info","列举","实例","status","repo","文件","这些","当前","一键","命令","版本信息","比较","或","路径","中","运行","--","要","help","-","远程","配置","h","bitxhub"," ","和","跨链","、","初始","key","版本","密钥","，","基本","（","初始化"],"title":"2.1 命令格式","title_tokens":["格式","命令","2.1"," "]},{"location":"goduck/#22-bitxhub","text":"goduck bitxhub command [command options] [arguments...]","text_tokens":["]","command","...","goduck","arguments","options","bitxhub","["," "],"title":"2.2 关于BitXHub的操作","title_tokens":["操作","关于","的","2.2","bitxhub"," "]},{"location":"goduck/#221-bitxhub","text":"goduck bitxhub start 该命令会初始化并启动BitXHub节点，如果有已启动的BitXHub节点会执行失败。执行成功后提示如下： 1 BitXHub nodes at /Users/fangbaozhu/.goduck/bitxhub are initialized successfully exec: /bin/bash /Users/fangbaozhu/.goduck/playground.sh up v1.4.0 solo binary 4 Start bitxhub solo by binary ===> Start bitxhub solo successful 这是默认启动方式，也可以携带参数自定义启动，参数设置如下： --type value 配置类型，binary或docker （默认：“binary”） --mode value 配置模式，solo或cluster （默认：“solo”） --num value 节点个数，只在cluster 模式下作用（默认：4） --tls 是否启动TLS, 只在v1.4.0+版本有效 (default: false) --version value BitXHub版本 (default: \"v1.4.0\") --help, -h","text_tokens":["bin","如果","cluster","(","是否","失败","version","类型","模式","type","at","：","initialized","成功","tls","）","并","会",":","”","只","“","在","users","mode","sh","0","节点","nodes","有","=","这是","定义","/","。","后","的","启动","value","default","默认","playground","有效","参数","已","提示","binary","v1.4",",","up",">","goduck","solo","\"","方式","+",")","如下",".","参数设置","num","are","命令","自定义","或","下","设置","start","--","successful","help","-","fangbaozhu","配置","4","bitxhub","h"," ","作用","by","docker","可以","exec","执行","也","初始","版本","，","（","bash","false","自定","successfully","携带","初始化","个数","该","1"],"title":"2.2.1 启动BitXHub节点","title_tokens":["节点","启动",".","2.2","bitxhub","1"," "]},{"location":"goduck/#222-bitxhub","text":"goduck bitxhub config 该命令默认初始化4个BitXHub节点。执行成功后当前文件夹会生成相关证书、私钥文件以及四个节点的文件夹，成功提示如下： initializing 4 BitXHub nodes at . 4 BitXHub nodes at . are initialized successfully You can see the following in the current directory： . ├── agency.cert ├── agency.priv ├── ca.cert ├── ca.priv ├── key.priv ├── node1/ ├── node2/ ├── node3/ └── node4/ 可以携带参数自定义配置情况： --num value 节点个数，只在cluster 模式下作用（默认：4） --type value 配置类型，binary或docker （默认：“binary”） --mode value 配置模式，solo或cluster （默认：“solo”） --ips value 节点IP, 默认所有节点为127.0.0.1, e.g. --ips \"127.0.0.1\" --ips \"127.0.0.2\" --ips \"127.0.0.3\" --ips \" 127.0.0.4\" --target value 节点的配置文件位置（默认：当前目录） --tls 是否启动TLS, 只在v1.4.0+版本有效 (default: false) --version value BitXHub版本 (default: \"v1.4.0\") --help, -h","text_tokens":["g","initializing","ips","为","see","node1","当前目录","cert","directory","cluster","following","(","0.4","node3","所有","node4","是否","version","模式","类型","type","at","位置","：","initialized","成功","tls","）","priv","会",":","”","生成","只","current","证书","“","在","0.1","mode","├","0","配置文件","节点","nodes","相关","件夹","定义","/","。","后","的","启动","value","the","个","default","默认","有效","参数","ip","提示","binary","文件夹","v1.4",",","goduck","└","solo","\"","in","+",")","如下","0.2",".","文件","num","当前","are","命令","config","私钥","e","自定义","或","下","--","以及","help","目录","-","配置","4","bitxhub","─"," ","you","作用","h","docker","可以","情况","、","执行","初始","四个","agency","127.0","key","0.3","can","版本","，","node2","（","false","自定","successfully","ca","携带","target","初始化","个数","该"],"title":"2.2.2 为BitXHub节点生成配置文件","title_tokens":["生成","文件","配置文件","节点","2","配置",".","为","2.2","bitxhub"," "]},{"location":"goduck/#223-bitxhub","text":"goduck bitxhub stop 该命令会关闭所有启动的BitXHub节点。执行成功后会提示里会给出关闭节点的id： exec: /bin/bash /Users/fangbaozhu/.goduck/playground.sh down ===> Stop bitxhub node pid:65246 exit","text_tokens":["pid","会","关闭","stop",":",">","goduck","users","fangbaozhu","sh","bitxhub"," ","id","bin","exit","给出","节点","down",".","=","exec","/","执行","所有","。","里会","后","node","的","启动","命令","65246","bash","：","playground","成功","提示","该"],"title":"2.2.3 关闭BitXHub节点","title_tokens":["3","关闭","节点",".","2.2","bitxhub"," "]},{"location":"goduck/#224-bitxhub","text":"goduck bitxhub clean 该命令会清除bitxhub节点的配置文件。如果bitxhub节点没有关闭，会先关闭节点再清除配置文件。 当bitxhub solo节点成功在关闭后执行此命令，会打印出提示如下： exec: /bin/bash /Users/fangbaozhu/.goduck/playground.sh clean ===> Stop bitxhub ===> Clean bitxhub remove bitxhub configure nodeSolo 当bitxhub solo节点成功在未关闭的情况下执行此命令，会打印出提示如下： exec: /bin/bash /Users/fangbaozhu/.goduck/playground.sh clean ===> Stop bitxhub node pid:65686 exit ===> Clean bitxhub remove bitxhub configure nodeSolo","text_tokens":["pid","会","关闭",":","stop","再","clean",">","goduck","在","users","solo","fangbaozhu","配置","sh","bitxhub"," ","未","bin","exit","配置文件","节点","如果","情况","如下","nodesolo","此",".","文件","=","exec","65686","/","执行","会先","清除","。","当","打印","后","node","的","出","没有","remove","命令","configure","，","bash","：","playground","下","成功","提示","该"],"title":"2.2.4 清除BitXHub节点","title_tokens":["4","清除","节点",".","2.2","bitxhub"," "]},{"location":"goduck/#23-pier","text":"GoDuck pier command [command options] [arguments...]","text_tokens":["]","command","...","goduck","arguments","options","pier","["," "],"title":"2.3 关于pier的操作","title_tokens":["2.3","操作","关于","的","pier"," "]},{"location":"goduck/#231-pier","text":"goduck pier start 参数设置如下： --chain value 应用链类型，ethereum 或 fabric（默认：ethereum） --cryptoPath value crypto-config路径, 只对fabric链有效, e.g $HOME/crypto-config --pier-type value pier类型，docker或者binary (默认: \"docker\") --version value pier版本 (默认: \"v1.4.0\") --tls value 是否启动TLS, true or false, 只对v1.4.0+版本有效 (默认: \"false\") --http-port value pier的http端口号, 只对v1.4.0+版本有效 (默认: \"44544\") --pprof-port value pier的pprof端口号, 只对binary有效 (默认: \"44550\") --api-port value pier的api端口号, 只对binary有效 (默认: \"8080\") --overwrite value 当本地默认路径存在pier配置文件时是否重写配置 (默认: \"true\") --appchainIP value pier连接的应用链ip (默认: \"127.0.0.1\") --help, -h 在使用此命令之前，您需要启动一个相同版本的BitxHub和一个需要pier连接的应用链。如果应用链或bitxhub不存在，pier将无法启动，打印提示如下: exec: /bin/bash run_pier.sh up -m ethereum -t docker -r .pier_ethereum -v v1.4.0 -c -p 44550 -a 8080 ===> Start pier of ethereum-v1.4.0 in docker... ===> Start a new pier-ethereum container ===> Wait for ethereum-node container to start for seconds... 136d323b1418a026101515313dbbdafee240ac0f0c0d63b4f202304019e13e24 ===> Start pier fail 如果要连接的应用链和BitxHub已经启动，且PIER已经启动成功，打印提示如下: exec: /bin/bash run_pier.sh up -m ethereum -t docker -r .pier_ethereum -v v1.0.0-rc1 -c -p 44550 -a 8080 ===> Start pier of ethereum-v1.0.0-rc1 in docker... ===> Start a new pier-ethereum container ===> Wait for ethereum-node container to start for seconds... 351bd8e8eb8d5a1803690ac0cd9b77c274b775507f30cb6271164fb843442bfd ===> Start pier successfully","text_tokens":["g","fail","您","端口","true","不","t","bin","to","如果","$","(","是否","version","_","new","...","类型","type","：","136d323b1418a026101515313dbbdafee240ac0f0c0d63b4f202304019e13e24","rc1","成功","tls","）","存在","将",":","m","api","只","0.1","在","sh","之前","本地","0","appchainip","配置文件","or","port","=","/","。","ethereum","的","启动","value","端口号","默认","使用","或者","有效","参数","相同","44550","pier","ip","binary","提示","c","of","v1.4","wait",",","已经","一个","且","up",">","goduck","for","链","\"","pprof","无法","in","fabric","+",")","如下",".","文件","run","参数设置","重写","连接","node","44544","home","8080","命令","config","e","或","路径","设置","start","--","cryptopath","crypto","v","要","help","-","对","container","seconds","配置","h","bitxhub"," ","chain","docker","351bd8e8eb8d5a1803690ac0cd9b77c274b775507f30cb6271164fb843442bfd","和","此","时","需要","overwrite","当","p","127.0","打印","v1.0","a","http","r","版本","，","（","false","bash","successfully","应用","口号","exec"],"title":"2.3.1 启动pier","title_tokens":["pier","2.3","启动",".","1"," "]},{"location":"goduck/#232-pier","text":"goduck pier stop 该命令可以关闭pier，可以通过携带参数指定关闭那种类型应用链的pier","text_tokens":["指定","类型","关闭","stop","，","goduck","可以","携带","通过","参数","应用","的","链","pier","命令","该","那种"," "],"title":"2.3.2 关闭pier","title_tokens":["关闭","pier","2.3","2","."," "]},{"location":"goduck/#233-pier","text":"goduck pier clean 该命令可以清除pier的配置文件，如果pier还没有关闭，该命令会先关闭pier再清除其配置文件。","text_tokens":["关闭","再","clean","goduck","配置"," ","其","配置文件","可以","如果","还","文件","会先","清除","。","的","没有","命令","，","pier","该"],"title":"2.3.3 清除Pier","title_tokens":["3","pier","2.3","清除","."," "]},{"location":"goduck/#234-pier","text":"goduck pier config --mode value 配置模式, 直连模式或者中继模式(默认: \"direct\") --type value 配置类型, binary或者docker (默认: \"binary\") --bitxhub value BitXHub的地址，只在中继模式有效 --validators value BitXHub的验证人地址，只在中继模式有效, 例如 --validators \"0xc7F999b83Af6DF9e67d0a37Ee7e900bF38b3D013\" --validators \"0x79a1215469FaB6f9c63c1816b45183AD3624bE34\" --validators \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\" --validators \"0x97c8B516D19edBf575D72a172Af7F418BE498C37\" --port value pier的端口号，只在直连模式有效 (默认: 5001) --peers value 连接节点的地址，只在直连模式有效, 例如 --peers \" /ip4/127.0.0.1/tcp/4001/p2p/Qma1oh5JtrV24gfP9bFrVv4miGKz7AABpfJhZ4F2Z5ngmL\" --connectors value 待连接节点的地址，只在v1.4.0+版本的union模式有效, 例如 --connectors \" /ip4/127.0.0.1/tcp/4001/p2p/Qma1oh5JtrV24gfP9bFrVv4miGKz7AABpfJhZ4F2Z5ngmL\" --connectors \" /ip4/127.0.0.1/tcp/4002/p2p/Qma1oh5JtrV24gfP9bFrVv4miGKz7AABpfJhZ4F2Z5abcD\" --appchain-type value 应用链类型, ethereum或者fabric (默认: \"ethereum\") --appchain-IP value 应用链IP地址 (默认: \"127.0.0.1\") --target value 生成配置文件路径 (默认: \".\") --tls value 是否开启TLS，只在v1.4.0+版本有效 (默认: \"false\") --http-port value pier的http端口号, 只在v1.4.0+版本有效 (默认: \"44544\") --pprof-port value pier的pprof端口号 (默认: \"44550\") --api-port value pier的api端口号 (默认: \"8080\") --cryptoPath value crypto-config文件的路径，只对fabric链有效，例如 $HOME/crypto-config (default: \" $HOME/.goduck/crypto-config\") --version value pier版本 (默认: \"v1.4.0\") --help, -h","text_tokens":["端口","ip地址","开启","$","直连","(","0x79a1215469fab6f9c63c1816b45183ad3624be34","待","是否","中继","version","模式","类型","qma1oh5jtrv24gfp9bfrvv4migkz7aabpfjhz4f2z5abcd","type","验证","tls",":","api","生成","只","在","0.1","mode","0","配置文件","节点","port","/","ethereum","的","value","default","端口号","默认","或者","有效","例如","44550","ip","pier","binary","appchain","v1.4","connectors",",","goduck","链","\"","pprof","+","ip4",")","fabric","qma1oh5jtrv24gfp9bfrvv4migkz7aabpfjhz4f2z5ngml",".","文件","union","0x97c8b516d19edbf575d72a172af7f418be498c37","连接","direct","44544","home","8080","config","路径","tcp","0xc7f999b83af6df9e67d0a37ee7e900bf38b3d013","--","cryptopath","crypto","validators","help","-","对","5001","配置","h","bitxhub"," ","docker","4002","peers","人","127.0","p2p","4001","http","版本","，","false","地址","target","应用","口号"],"title":"2.3.4 生成Pier的配置文件","title_tokens":["pier","2.3","生成","文件","配置文件","的",".","配置","4"," "]},{"location":"premo/usage/","text":"Premo使用文档 Premo是BitXHub跨链系统测试框架，目前支持系统集成测试、接口测试和压力测试 安装 获取源码 git clone git@github.com:meshplus/premo.git 编译 进入premo工程目录: cd premo make install 初始化 premo init 基本使用 premo [global options] command [command options] [arguments...] COMMANDS: init init config home for premo version Premo version test test bitxhub function pier Start or stop the pier bitxhub Start or stop the bitxhub cluster appchain Bring up the appchain network interchain Start or Stop the interchain system status List the status of instantiated components help, h Shows a list of commands or help for one command GLOBAL OPTIONS: --repo value Premo storage repo path --help, -h show help (default: false) 集成测试 进入premo的工程目录 cd premo make bitxhub-tester 注意：集成测试默认前置条件是本机已启动bitxhub四节点集群（可在bitxhub工程目录下通过 make cluster 命令启动） 接口测试 进入premo的工程目录 cd premo make http-tester 注意：集成测试默认前置条件是本机已启动bitxhub四节点集群（可在bitxhub工程目录下通过 make cluster 命令启动） 压力测试 test命令用于压测bitxhub的TPS性能。使用下面的命令获取使用帮助信息： premo test --help 帮助信息如下： NAME: premo test - test bitxhub function USAGE: premo test [command options] [arguments...] OPTIONS: --concurrent value, -c value concurrent number (default: 100) --tps value, -t value all tx number (default: 500) --duration value, -d value test duration (default: 60) --key_path value, -k value Specific key path --remote_bitxhub_addr value, -r value Specific remote bitxhub address (default: \"localhost:60011\") --type value Specific tx type: interchain, data, transfer (default: \"transfer\") --help, -h show help (default: false) --concurrent 或者 -c 指定并发量； --tps 或者 -t 指定每秒交易数量； --duration 或者 -d 指定压测时间； --key_path 或者 -k 指定私钥路径； --remote_bitxhub_addr 或者 -r 指定bitxhub的地址； --type 指定交易类型，其中 transfer 是普通转账交易， data 是调用BVM交易， interchain 是跨链交易； 压测完成后会打印压测的实际情况： $ premo test -c 50 -t 3000 -d 1000 INFO[0000] Premo configuration concurrent=50 duration=1000 tps=3000 type=transfer INFO[0000] generate all bees number=50 2020-08-10 13:51:11 [INFO] [$(GOPATH)/src/meshplus/premo/internal/bitxhub/bitxhub.go:92] starting broker INFO[0000] start all bees number=50 INFO[0001] current tps is 834.000000 INFO[0002] current tps is 1346.000000 INFO[0003] current tps is 2469.000000 INFO[0004] current tps is 1732.000000 INFO[0005] current tps is 2221.000000 INFO[0006] current tps is 2068.000000 INFO[0007] current tps is 1145.000000 INFO[0008] current tps is 1626.000000 INFO[0009] current tps is 2425.000000 INFO[0010] current tps is 1703.000000 INFO[0011] current tps is 1772.000000 INFO[0012] current tps is 1823.000000 INFO[0013] current tps is 1213.000000 INFO[0014] current tps is 1974.000000 INFO[0015] current tps is 1965.000000 INFO[0016] current tps is 2001.000000 INFO[0017] current tps is 975.000000 INFO[0018] current tps is 1505.000000 INFO[0019] current tps is 2338.000000 INFO[0020] current tps is 1704.000000 INFO[0021] current tps is 1270.000000 INFO[0022] current tps is 2418.000000 INFO[0023] current tps is 1673.000000 INFO[0024] current tps is 997.000000 INFO[0025] current tps is 1935.000000 INFO[0026] current tps is 1840.000000 INFO[0027] current tps is 710.000000 INFO[0028] current tps is 1041.000000 INFO[0029] current tps is 837.000000 INFO[0030] current tps is 1403.000000 received interrupt signal, shutting down... INFO[0030] finish testing duration=30.468557927 number=50880 tps=1669.9181872450927 tx_delay=968.0890066430818","text_tokens":["broker","0008","command","2221.000000","3000","0009","2425.000000","0025","普通","信息","08","性能","bees","0012","实际","[","0029","0019","]","commands","t","；","13","usage","0007","1840.000000","通过","cluster","$","0005","starting","data","is","tps","0027","down","1673.000000","(","specific","834.000000","0026","转账","options","文档","目前","前置条件","list","0023","version","_","11","系统集成","...","类型","710.000000","type","delay","bring","0001","one","：","generate","是","1703.000000","1704.000000","address","）","获取","四","会",":","50","current","1626.000000","837.000000","在","interchain","transfer","指定","进入","remote","2020","0011","前置","arguments","storage","节点","2001.000000","init","系统","测试","or","=","注意","0028","/","localhost","tx","1732.000000","0021","。","clone","量","show","交易类型","本机","后","的","启动","value","the","可","@","下面","交易","0013","1965.000000","1669.9181872450927","default","默认","使用","或者","system","0014","50880","条件","global","1772.000000","已","k","pier","name","c","make","of","appchain","stop","1145.000000",",","编译","接口","0018","up","2338.000000","帮助","支持","500","for","0004","info","完成","0006","\"","10","finish","调用","0024","压测","received","signal",")","集群","test","status","repo","如下","1041.000000","all",".","安装","92","0016","network","addr","number","premo","home","命令","51","config","数量","并发","私钥","gopath","路径","configuration","1935.000000","下","1000","function","时间","0030","1213.000000","997.000000","start","github","--","1974.000000","其中","1823.000000","com","0015","1270.000000","interrupt","go","2469.000000","help","目录","-","2418.000000","30.468557927","h","bitxhub","meshplus"," ","concurrent","968.0890066430818","2068.000000","0017","60","cd","975.000000","shows","和","跨链","情况","d","、","压力","internal","duration","0002","100","初始","install","用于","instantiated","tester","bvm","src","打印","path","key","testing","0022","components","框架","a","http","r","60011","1403.000000","1346.000000","，","0000","基本","git","false","（","1505.000000","地址","0010","集成","初始化","0003","工程","源码","shutting","每秒","0020"],"title":"使用文档","title_tokens":["文档","使用"]},{"location":"premo/usage/#premo","text":"Premo是BitXHub跨链系统测试框架，目前支持系统集成测试、接口测试和压力测试","text_tokens":["，","接口","是","支持","目前","跨链","集成","系统","premo","测试","框架","、","和","压力","bitxhub","系统集成"],"title":"Premo使用文档","title_tokens":["文档","使用","premo"]},{"location":"premo/usage/#_1","text":"","text_tokens":[],"title":"安装","title_tokens":["安装"]},{"location":"premo/usage/#_2","text":"git clone git@github.com:meshplus/premo.git","text_tokens":["github","/",":","com","git","clone","premo",".","@","meshplus"," "],"title":"获取源码","title_tokens":["源码","获取"]},{"location":"premo/usage/#_3","text":"进入premo工程目录: cd premo make install","text_tokens":["make","进入",":","install","cd","目录","premo","工程"," "],"title":"编译","title_tokens":["编译"]},{"location":"premo/usage/#_4","text":"premo init","text_tokens":["init","premo"," "],"title":"初始化","title_tokens":["初始","初始化"]},{"location":"premo/usage/#_5","text":"premo [global options] command [command options] [arguments...]","text_tokens":["]","command","...","arguments","options","global","premo","["," "],"title":"基本使用","title_tokens":["基本","使用"]},{"location":"premo/usage/#commands","text":"init init config home for premo version Premo version test test bitxhub function pier Start or stop the pier bitxhub Start or stop the bitxhub cluster appchain Bring up the appchain network interchain Start or Stop the interchain system status List the status of instantiated components help, h Shows a list of commands or help for one command","text_tokens":["start","of","appchain","stop","command",",","up","help","for","h","bitxhub","interchain"," ","commands","shows","test","status","init","or","cluster","instantiated","network","premo","components","the","home","list","version","config","a","bring","one","system","function","pier"],"title":"COMMANDS:","title_tokens":[":","commands"]},{"location":"premo/usage/#global-options","text":"--repo value Premo storage repo path --help, -h show help (default: false)","text_tokens":["--","(",":",",","false","default","show","path","help","storage",")","-","repo","premo","value","h"," "],"title":"GLOBAL OPTIONS:","title_tokens":["options","global",":"," "]},{"location":"premo/usage/#_6","text":"进入premo的工程目录 cd premo make bitxhub-tester 注意：集成测试默认前置条件是本机已启动bitxhub四节点集群（可在bitxhub工程目录下通过 make cluster 命令启动）","text_tokens":["make","目录","-","在","bitxhub"," ","进入","cd","前置","节点","集群","通过","测试","cluster","注意","tester","本机","的","前置条件","premo","启动","可","命令","（","默认","：","是","集成","条件","下","已","工程","）","四"],"title":"集成测试","title_tokens":["集成","测试"]},{"location":"premo/usage/#_7","text":"进入premo的工程目录 cd premo make http-tester 注意：集成测试默认前置条件是本机已启动bitxhub四节点集群（可在bitxhub工程目录下通过 make cluster 命令启动）","text_tokens":["make","目录","-","在","bitxhub"," ","进入","cd","前置","节点","集群","通过","测试","cluster","注意","tester","本机","的","前置条件","premo","启动","可","命令","http","（","默认","：","是","集成","条件","下","已","工程","）","四"],"title":"接口测试","title_tokens":["接口","测试"]},{"location":"premo/usage/#_8","text":"test命令用于压测bitxhub的TPS性能。使用下面的命令获取使用帮助信息： premo test --help 帮助信息如下： NAME: premo test - test bitxhub function USAGE: premo test [command options] [arguments...] OPTIONS: --concurrent value, -c value concurrent number (default: 100) --tps value, -t value all tx number (default: 500) --duration value, -d value test duration (default: 60) --key_path value, -k value Specific key path --remote_bitxhub_addr value, -r value Specific remote bitxhub address (default: \"localhost:60011\") --type value Specific tx type: interchain, data, transfer (default: \"transfer\") --help, -h show help (default: false) --concurrent 或者 -c 指定并发量； --tps 或者 -t 指定每秒交易数量； --duration 或者 -d 指定压测时间； --key_path 或者 -k 指定私钥路径； --remote_bitxhub_addr 或者 -r 指定bitxhub的地址； --type 指定交易类型，其中 transfer 是普通转账交易， data 是调用BVM交易， interchain 是跨链交易； 压测完成后会打印压测的实际情况： $ premo test -c 50 -t 3000 -d 1000 INFO[0000] Premo configuration concurrent=50 duration=1000 tps=3000 type=transfer INFO[0000] generate all bees number=50 2020-08-10 13:51:11 [INFO] [$(GOPATH)/src/meshplus/premo/internal/bitxhub/bitxhub.go:92] starting broker INFO[0000] start all bees number=50 INFO[0001] current tps is 834.000000 INFO[0002] current tps is 1346.000000 INFO[0003] current tps is 2469.000000 INFO[0004] current tps is 1732.000000 INFO[0005] current tps is 2221.000000 INFO[0006] current tps is 2068.000000 INFO[0007] current tps is 1145.000000 INFO[0008] current tps is 1626.000000 INFO[0009] current tps is 2425.000000 INFO[0010] current tps is 1703.000000 INFO[0011] current tps is 1772.000000 INFO[0012] current tps is 1823.000000 INFO[0013] current tps is 1213.000000 INFO[0014] current tps is 1974.000000 INFO[0015] current tps is 1965.000000 INFO[0016] current tps is 2001.000000 INFO[0017] current tps is 975.000000 INFO[0018] current tps is 1505.000000 INFO[0019] current tps is 2338.000000 INFO[0020] current tps is 1704.000000 INFO[0021] current tps is 1270.000000 INFO[0022] current tps is 2418.000000 INFO[0023] current tps is 1673.000000 INFO[0024] current tps is 997.000000 INFO[0025] current tps is 1935.000000 INFO[0026] current tps is 1840.000000 INFO[0027] current tps is 710.000000 INFO[0028] current tps is 1041.000000 INFO[0029] current tps is 837.000000 INFO[0030] current tps is 1403.000000 received interrupt signal, shutting down... INFO[0030] finish testing duration=30.468557927 number=50880 tps=1669.9181872450927 tx_delay=968.0890066430818","text_tokens":["broker","0008","command","2221.000000","3000","0009","2425.000000","0025","普通","信息","08","性能","bees","0012","实际","[","0029","0019","]","t","13","；","usage","0007","1840.000000","$","0005","starting","data","is","tps","0027","down","1673.000000","(","specific","834.000000","0026","转账","options","0023","710.000000","_","11","...","类型","type","delay","0001","：","generate","是","1703.000000","1704.000000","address","获取","会",":","50","current","1626.000000","837.000000","interchain","transfer","指定","remote","2020","0011","2001.000000","arguments","=","0028","localhost","/","tx","1732.000000","0021","。","量","show","交易类型","后","的","value","下面","交易","0013","1965.000000","1669.9181872450927","default","50880","使用","或者","0014","1772.000000","k","name","c","1145.000000","0018","2338.000000",",","帮助","500","0004","info","完成","0006","\"","10","finish","调用","0024","压测","received","signal",")","test","如下","1041.000000","all",".","92","0016","addr","number","premo","命令","51","数量","私钥","并发","gopath","路径","configuration","1935.000000","1000","function","时间","0030","1213.000000","997.000000","--","start","1974.000000","1270.000000","其中","1823.000000","0015","interrupt","go","2469.000000","help","-","2418.000000","30.468557927","h","bitxhub","concurrent"," ","meshplus","968.0890066430818","2068.000000","0017","60","975.000000","情况","跨链","d","internal","duration","0002","100","用于","bvm","src","打印","path","key","testing","0022","60011","r","1403.000000","1346.000000","，","0000","false","1505.000000","地址","0010","0003","shutting","每秒","0020"],"title":"压力测试","title_tokens":["压力","测试"]},{"location":"scan/","text":"跨链浏览器体验指南 一、测试网配置流程 我们建议使用 Google Chrome 并安装 MetaMask 钱包扩展程序(推荐使用10.0.1及以上)。以下是 MetaMask 常见问题解答 供参考！ 测试网自动配置 MetaMask插件安装完成后，点击浏览器【登陆】按钮，系统会弹出测试网自动配置添加页面，用户点击【Approve】，即可成功添加BitXHub测试网。 BitXHub测试网络添加成功后，系统会提示您进行网络切换，用户点击【Switch network】，即可成功切换至BitXHub测试网络并进行后续操作。 测试网RPC手动配置 选择顶部网络功能，然后选择【自定义RPC】进入网络配置页面。 BitXHub测试网配置信息详情 Chain ID 1356 RPC URL https://testnet-1.bitxhub.cn:8881 配置如下图所示 二、应用链环境准备 应用链接入中继链之前，需要进行相应的跨链合约部署以及跨链网关配置等操作。 部署跨链合约 可以参考BitXHub文档站 链接 进行跨链合约部署。（注意：文档中提到的二进制或开源项目，均是要对应 v1.11.0的版本） 获取Pier部署包和修改配置 可以参考BitXHub文档站 链接 。 注意： 1）文档中提到的二进制或开源项目，均是要对应 v1.11.0的版本； 2）以上pier配置过程，pier.toml中关于应用链的部分需要特别注意，以fabric为例，[appchain]字段下的配置示例如下， [mode.relay] addrs = [ \"testnet-1.bitxhub.cn:60111\" ] [appchain] plugin = \"fabric-client-1.4\" config = \"fabric\" 获取应用链私钥（用于导入MetaMask钱包） 完成以上配置后，在页面上注册应用链之前，还需要将上一步pier配置目录下的key.json转换显示成可以导入MetaMask钱包的公私钥对，具体示例如下： # 1.进入到pier的配置主目录，即pier.toml所在的目录 # 执行pier show命令 ./pier show --path ~/.pier/key.json # 返回结果示例： private key: 0x88b434530176d3faf4dbf10ede1c25c4f7af673392152d71a18758a1ba677ddc public key: 0x041b311209c6feb1587aaf16d7a1bac9f96c1fecb539d4cde416f97ff5048139beeac307d14d0e7196c7e15ad657530dedcc33bbe821276dadf3989bfff470747a address: 0xE7f5E3c3963c6a588AB3de753817B3F735a6Ab58 # 将返回的private key的字符串导入到MetaMask钱包即可 三、浏览器可视化操作 用户实名绑定 BitXHub测试网络下，新用户首次点击【登陆】，需要完成手机实名绑定，系统会提示【正在为您跳转，请先完成用户注册】，并跳转到注册页面。 注册页面中，用户需要输入手机号进行验证码校验，完成密码设置后，点击【注册】，即可跳转返回跨链浏览器页面。新用户完成注册后，您的地址1h内将收到BitXHub测试网发送的燃料费用于跨链体验。 应用链注册申请 对于新注册的用户，您的地址1h内将收到BitXHub测试网发送的燃料费用于跨链体验。当您的地址中BitXHub测试网燃料费为0时，系统会提示【您的测试网燃料正分发中，请稍后】。 应用链注册 注册字段说明： 节点ID：系统根据钱包地址自动生成 应用链名称：自定义应用链的名称 应用链类型：分为fabric1.4.3、fabric1.4.4 、hyperchain和 其他 四类 版本号：应用链对应的版本号 共识算法：应用链采用的共识算法 验证者信息：请参考 验证者信息生成 验证规则：分为fabric1.4.3、fabric1.4.4 、无验证规则和 其他 四类（用户可选择无验证规则模式进行快速跨链体验），根据对应应用链类型选择合适的验证规则。注意其他类型需要提交自定义的验证规则，并附带源码链接。编写规则请参考 验证规则编写 申请理由：填写申请接入跨链系统的理由 应用链接入BitXHub跨链系统需要获得中继链管理员的准入审批，中继链管理员会在24h内完成应用链注册申请审，审核通过即可接入应用链。 四、网关启动 在完成以上步骤之后，用户启动跨链网关，即完成应用链接入跨链系统的操作。 #以用户目录下的pier为例 pier --repo = ~/.pier start 五、跨链体验 目前测试网已经接入Fabric和Hyperchain，两条链都部署了存证服务，用户应用链接入跨链系统后，可通过BitXHub体验跨链存证服务。 两条测试应用链的信息如下： 1. Fabric 应用链DID： did:bitxhub:appchain0xc11bA472f5955B2a3b0e66a91fFc05f68995eFDf:. 存证合约地址： mychannel&data_swapper 2. Hyperchain 应用链DID： did:bitxhub:appchain0xe1E8c72408623Dd1825b704C21ceF7C03ab62aB6 存证合约地址： 0xb8dc305352edef315f6a7844948c864717e93c84 具体调用说明如下： 跨链存证 调用自己应用链上的data_swapper合约向我们内部的测试应用链发起跨链存证交易，调用方法是 set ，其参数有3个，依次是目的链合约的did、要存储的key，要存储的value 跨链获取 调用自己应用链上的data_swapper合约向我们内部的测试应用链发起跨链交易，将获取到的数据存到自己链上，调用方法是 get ，其参数有2个，依次是 目的链合约的did、要获取的key。 本地查询 调用自己应用链上的data_swapper合约查询上一步获取的数据，如果自己链是fabric，则调用方法是 get，如果自己链是hyperchain或其它，则调用方法是 getData，参数均只有1个，即要查询的key 用户如果想验证目的链上是否真正执行了跨链操作，可通过部署两条自己的应用链进行跨链存证的完整体验。","text_tokens":["者","关于","说明","url","信息","上","您","为","get","包","合约","如果","cn","主目录","正","中继","_","以","准入","10.0","并","操作","依次","本地","进入","链接","测试","=","成","存储","新","。","启动","可","！","google","1h","提示","页面","fabric1.4","完成","返回","即可","1.4","0x041b311209c6feb1587aaf16d7a1bac9f96c1fecb539d4cde416f97ff5048139beeac307d14d0e7196c7e15ad657530dedcc33bbe821276dadf3989bfff470747a","出","或","发起","插件","采用","解答","中","公私","料费","60111","https","设置","start","以及","client","-","bitxhub"," ","3","和","分发","之后","执行","用于","当","key","五","1356","自己","（","钱包","管理","getdata","appchain0xc11ba472f5955b2a3b0e66a91ffc05f68995efdf","审批","到","网","部署","[","用户","合适","流程","理由","plugin","data","其它","导入到","文档","目前","手动","图","首次","手机","输入","：","是","成功","mychannel","四",":","规则","在","mode","其","0","指南","用户注册","提到","系统","定义","注意","正在","【","导入","0xe7f5e3c3963c6a588ab3de753817b3f735a6ab58","后","的","交易","则","对应","使用","先","管理员","swapper","v1.11","浏览器","调用","自动","repo","过程","字段","】","接入","获得","命令","config","私钥","均","配置","按钮","密码","还","private","存","方法","真正","项目","分为","问题","修改","推荐","然后","向","地址","1","可视","其他","请","id","申请理由","手机号","具体","relay","字符串","选择","json","是否","名称","至","类型","验证","入","详情","共识","段","address","所在","）","获取","可视化","会","public","即","程序","rpc","对于","二","之前","链上","/","及","show","0x88b434530176d3faf4dbf10ede1c25c4f7af673392152d71a18758a1ba677ddc","set","#","value","个","添加","后续","pier","appchain","已经","appchain0xe1e8c72408623dd1825b704c21cef7c03ab62ab6","相应","链","\"","开源",")","0xb8dc305352edef315f6a7844948c864717e93c84","浏览","&","查询","network","顶部","审","自定义","toml","跳转","等","功能","注册","--","供参考","收到","switch","要","部分","实名","常见","以上","发送","4","绑定","chain","题解","登陆","可以","metamask","进制","切换","时","需要","编写","8881","显示","问题解答","~","自定","参考","应用","站","目的","燃料费","会弹","准备","示例","]","；","内","一步","申请","通过","钥对","三","(","附带","存证","校验","环境","完整","体验","所示","模式","稍后","快速","将","生成","无","验证码","建议","节点","两条","结果","有","did","提交","参数","参数均","特别","想","审核","内部","chrome","fabric","填写","进行","如下",".","点击","根据","安装","四类","一","都","24h","testnet","2","下","链是","字","为例","燃料","二进制","算法","目录","字符","hyperchain","扩展","approve","只有","addrs","跨链","网络","、","版本号","我们","步骤","path","转换","版本","，","网关","服务","了","源码","以下","数据"],"title":"使用文档","title_tokens":["文档","使用"]},{"location":"scan/#_1","text":"","text_tokens":[],"title":"跨链浏览器体验指南","title_tokens":["指南","浏览器","跨链","浏览","体验"]},{"location":"scan/#_2","text":"我们建议使用 Google Chrome 并安装 MetaMask 钱包扩展程序(推荐使用10.0.1及以上)。以下是 MetaMask 常见问题解答 供参考！","text_tokens":["供参考","程序","常见","以上"," ","扩展","题解","chrome","建议",")","metamask",".","安装","(","我们","及","。","！","问题","10.0","问题解答","推荐","解答","使用","google","是","参考","钱包","并","以下","1"],"title":"一、测试网配置流程","title_tokens":["一","流程","测试","、","配置","网"]},{"location":"scan/#_3","text":"MetaMask插件安装完成后，点击浏览器【登陆】按钮，系统会弹出测试网自动配置添加页面，用户点击【Approve】，即可成功添加BitXHub测试网。 BitXHub测试网络添加成功后，系统会提示您进行网络切换，用户点击【Switch network】，即可成功切换至BitXHub测试网络并进行后续操作。","text_tokens":["会","会弹","操作","后续","switch","完成","您","按钮","网","配置","bitxhub","浏览器","用户"," ","approve","自动","登陆","即可","成功","进行","metamask","浏览","系统","测试","点击","网络","】","安装","切换","【","。","network","后","出","至","，","插件","添加","提示","并","页面"],"title":"测试网自动配置","title_tokens":["自动","网","测试","配置"]},{"location":"scan/#rpc","text":"选择顶部网络功能，然后选择【自定义RPC】进入网络配置页面。","text_tokens":["自定义","，","进入","【","。","然后","自定","顶部","rpc","网络","配置","定义","功能","选择","页面","】"],"title":"测试网RPC手动配置","title_tokens":["测试","rpc","手动","配置","网"]},{"location":"scan/#bitxhub","text":"Chain ID 1356 RPC URL https://testnet-1.bitxhub.cn:8881 配置如下图所示","text_tokens":[":","url","-","rpc","配置","bitxhub"," ","id","chain","如下",".","/","cn","8881","testnet","1356","图","所示","https","1"],"title":"BitXHub测试网配置信息详情","title_tokens":["信息","详情","测试","配置","网","bitxhub"]},{"location":"scan/#_4","text":"应用链接入中继链之前，需要进行相应的跨链合约部署以及跨链网关配置等操作。","text_tokens":["操作","以及","相应","链","配置","之前","部署","链接","合约","进行","跨链","需要","。","的","中继","，","网关","入","等","应用"],"title":"二、应用链环境准备","title_tokens":["准备","应用","链","、","二","环境"]},{"location":"scan/#_5","text":"可以参考BitXHub文档站 链接 进行跨链合约部署。（注意：文档中提到的二进制或开源项目，均是要对应 v1.11.0的版本）","text_tokens":["二进制","要","v1.11","均","部署","bitxhub"," ","0","链接","合约","开源","可以","进行","跨链","提到",".","注意","进制","。","文档","的","项目","版本","或","，","对应","（","：","中","是","参考","站","）"],"title":"部署跨链合约","title_tokens":["合约","跨链","部署"]},{"location":"scan/#pier","text":"可以参考BitXHub文档站 链接 。 注意： 1）文档中提到的二进制或开源项目，均是要对应 v1.11.0的版本； 2）以上pier配置过程，pier.toml中关于应用链的部分需要特别注意，以fabric为例，[appchain]字段下的配置示例如下， [mode.relay] addrs = [ \"testnet-1.bitxhub.cn:60111\" ] [appchain] plugin = \"fabric-client-1.4\" config = \"fabric\"","text_tokens":["为例","特别","pier","appchain",":","关于","二进制","要","部分","v1.11","-","示例","均","client","链","以上","mode","配置","\"","bitxhub","["," ","0","]","；","链接","plugin","fabric","开源","addrs","可以","提到","如下","过程","字段",".","relay","注意","=","1.4","进制","cn","需要","。","文档","的","testnet","项目","以","config","版本","或","，","toml","对应","：","中","是","参考","2","应用","下","60111","站","）","1"],"title":"获取Pier部署包和修改配置","title_tokens":["修改","包","和","pier","配置","获取","部署"]},{"location":"scan/#metamask","text":"完成以上配置后，在页面上注册应用链之前，还需要将上一步pier配置目录下的key.json转换显示成可以导入MetaMask钱包的公私钥对，具体示例如下： # 1.进入到pier的配置主目录，即pier.toml所在的目录 # 执行pier show命令 ./pier show --path ~/.pier/key.json # 返回结果示例： private key: 0x88b434530176d3faf4dbf10ede1c25c4f7af673392152d71a18758a1ba677ddc public key: 0x041b311209c6feb1587aaf16d7a1bac9f96c1fecb539d4cde416f97ff5048139beeac307d14d0e7196c7e15ad657530dedcc33bbe821276dadf3989bfff470747a address: 0xE7f5E3c3963c6a588AB3de753817B3F735a6Ab58 # 将返回的private key的字符串导入到MetaMask钱包即可","text_tokens":["注册","将","--","即",":","public","目录","示例","上","完成","在","以上","链","1","配置","到","之前","返回","字符"," ","进入","一步","可以","即可","钥对","还","metamask","具体","如下",".","结果","private","字符串","成","/","0x041b311209c6feb1587aaf16d7a1bac9f96c1fecb539d4cde416f97ff5048139beeac307d14d0e7196c7e15ad657530dedcc33bbe821276dadf3989bfff470747a","执行","json","需要","导入到","导入","主目录","show","key","后","转换","#","的","path","0x88b434530176d3faf4dbf10ede1c25c4f7af673392152d71a18758a1ba677ddc","0xe7f5e3c3963c6a588ab3de753817b3f735a6ab58","显示","命令","，","toml","~","：","公私","应用","下","钱包","address","pier","所在","页面"],"title":"获取应用链私钥（用于导入MetaMask钱包）","title_tokens":["用于","（","导入","应用","metamask","链","钱包","）","获取","私钥"]},{"location":"scan/#_6","text":"","text_tokens":[],"title":"三、浏览器可视化操作","title_tokens":["操作","可视","浏览","、","三","可视化","浏览器"]},{"location":"scan/#_7","text":"BitXHub测试网络下，新用户首次点击【登陆】，需要完成手机实名绑定，系统会提示【正在为您跳转，请先完成用户注册】，并跳转到注册页面。 注册页面中，用户需要输入手机号进行验证码校验，完成密码设置后，点击【注册】，即可跳转返回跨链浏览器页面。新用户完成注册后，您的地址1h内将收到BitXHub测试网发送的燃料费用于跨链体验。","text_tokens":["会","注册","将","燃料","燃料费","收到","实名","到","完成","您","发送","为","网","bitxhub","绑定","用户","请"," ","验证码","密码","返回","浏览器","用户注册","登陆","内","即可","进行","跨链","手机号","测试","网络","系统","浏览","点击","】","正在","用于","需要","新","【","。","后","的","校验","体验","首次","手机","验证","，","输入","跳转","先","中","地址","1h","料费","下","提示","并","页面","设置"],"title":"用户实名绑定","title_tokens":["实名","绑定","用户"]},{"location":"scan/#_8","text":"对于新注册的用户，您的地址1h内将收到BitXHub测试网发送的燃料费用于跨链体验。当您的地址中BitXHub测试网燃料费为0时，系统会提示【您的测试网燃料正分发中，请稍后】。 应用链注册 注册字段说明： 节点ID：系统根据钱包地址自动生成 应用链名称：自定义应用链的名称 应用链类型：分为fabric1.4.3、fabric1.4.4 、hyperchain和 其他 四类 版本号：应用链对应的版本号 共识算法：应用链采用的共识算法 验证者信息：请参考 验证者信息生成 验证规则：分为fabric1.4.3、fabric1.4.4 、无验证规则和 其他 四类（用户可选择无验证规则模式进行快速跨链体验），根据对应应用链类型选择合适的验证规则。注意其他类型需要提交自定义的验证规则，并附带源码链接。编写规则请参考 验证规则编写 申请理由：填写申请接入跨链系统的理由 应用链接入BitXHub跨链系统需要获得中继链管理员的准入审批，中继链管理员会在24h内完成应用链注册申请审，审核通过即可接入应用链。","text_tokens":["者","燃料费","说明","信息","审批","您","为","网","其他","用户","请","id","合适","理由","内","申请理由","申请","通过","选择","附带","正","名称","中继","体验","类型","模式","验证","准入","稍后","入","：","共识","段","快速","）","并","会","将","生成","规则","在","无","对于","0","链接","节点","测试","系统","定义","注意","新","。","【","的","可","提交","对应","1h","管理员","提示","fabric1.4","完成","链","审核","自动","填写","进行","即可",".","根据","】","四类","接入","获得","24h","审","自定义","采用","中","料费","字","注册","燃料","算法","收到","发送","4","bitxhub"," ","3","hyperchain","和","跨链","分发","、","版本号","用于","时","需要","编写","当","分为","版本","，","（","自定","地址","参考","应用","钱包","管理","源码"],"title":"应用链注册申请","title_tokens":["申请","注册","应用","链"]},{"location":"scan/#_9","text":"在完成以上步骤之后，用户启动跨链网关，即完成应用链接入跨链系统的操作。 #以用户目录下的pier为例 pier --repo = ~/.pier start","text_tokens":["为例","--","start","即","操作","目录","完成","在","以上"," ","用户","链接","跨链","repo","系统","之后",".","=","/","步骤","。","#","的","启动","以","，","网关","~","入","应用","下","pier"],"title":"四、网关启动","title_tokens":["网关","、","启动","四"]},{"location":"scan/#_10","text":"目前测试网已经接入Fabric和Hyperchain，两条链都部署了存证服务，用户应用链接入跨链系统后，可通过BitXHub体验跨链存证服务。 两条测试应用链的信息如下：","text_tokens":["已经","信息","链","网","部署","bitxhub","用户"," ","hyperchain","链接","fabric","和","跨链","通过","测试","两条","系统","如下","接入","。","都","后","目前","存证","的","可","体验","，","服务","入","：","了","应用"],"title":"五、跨链体验","title_tokens":["五","、","跨链","体验"]},{"location":"scan/#1-fabric","text":"应用链DID： did:bitxhub:appchain0xc11bA472f5955B2a3b0e66a91fFc05f68995eFDf:. 存证合约地址： mychannel&data_swapper","text_tokens":["did","swapper",":","合约","：","appchain0xc11ba472f5955b2a3b0e66a91ffc05f68995efdf","地址","data","存证","应用","_","链",".","&","mychannel","bitxhub"," "],"title":"1. Fabric","title_tokens":[".","fabric","1"," "]},{"location":"scan/#2-hyperchain","text":"应用链DID： did:bitxhub:appchain0xe1E8c72408623Dd1825b704C21ceF7C03ab62aB6 存证合约地址： 0xb8dc305352edef315f6a7844948c864717e93c84 具体调用说明如下： 跨链存证 调用自己应用链上的data_swapper合约向我们内部的测试应用链发起跨链存证交易，调用方法是 set ，其参数有3个，依次是目的链合约的did、要存储的key，要存储的value 跨链获取 调用自己应用链上的data_swapper合约向我们内部的测试应用链发起跨链交易，将获取到的数据存到自己链上，调用方法是 get ，其参数有2个，依次是 目的链合约的did、要获取的key。 本地查询 调用自己应用链上的data_swapper合约查询上一步获取的数据，如果自己链是fabric，则调用方法是 get，如果自己链是hyperchain或其它，则调用方法是 getData，参数均只有1个，即要查询的key 用户如果想验证目的链上是否真正执行了跨链操作，可通过部署两条自己的应用链进行跨链存证的完整体验。","text_tokens":["getdata","目的","说明","到","上","部署","用户","get","合约","一步","如果","通过","具体","data","其它","是否","存证","完整","_","体验","验证","：","是","获取","将",":","即","操作","依次","本地","其","链上","测试","两条","有","did","存储","。","set","的","value","可","个","交易","则","参数","参数均","swapper","想","appchain0xe1e8c72408623dd1825b704c21cef7c03ab62ab6","链","调用","内部","fabric","进行","0xb8dc305352edef315f6a7844948c864717e93c84","如下","查询","发起","或","2","链是","要","bitxhub"," ","3","hyperchain","只有","跨链","、","存","执行","我们","key","方法","真正","，","自己","向","地址","应用","了","1","数据"],"title":"2. Hyperchain","title_tokens":[".","2","hyperchain"," "]},{"location":"scan/deploy_pier_testnet/","text":"跨链网关部署 跨链网关Pier能够支持业务所在区块链（以下简称 应用链）便捷、快速的接入到跨链平台BitXHub中，从而实现和其他业务区块链的跨链操作。目前中继链和跨链网关已经支持 Fabric 、 Ethereum 、 BCOS 、 CITA 和 Hyperchain 五种应用链接入并完成跨链交易，如果您有兴趣，也可以参与开发适配另外种类应用链的插件和合约。 跨链网关的部署需要提前确定应用链类型（对应不同的插件和配置），也需要提前在对应的应用链上部署跨链合约，我们将跨链网关的部署依次分为如下五个步骤： 部署跨链合约 获取部署包和修改Pier配置 部署跨链合约 这一章是要在应用链上部署跨链合约， 注意：在此操作之前，您需要确认已经部署有可接入的应用链 。 我们提供了针对不同应用链的跨链合约，broker合约是管理合约，transfer合约是业务交易合约，需要说明的是 transfer合约需要经过broker合约审核通过后才能发起或接受跨链交易，具体方法是：调用broker合约的audit方法，其参数依次是业务合约地址和合约状态（数字1表示审核通过，数字2表示审核失败）。 下面以Ethereum和Fabric为例进行介绍，其它类型的应用链部署跨链合约的步骤基本上是一致的。 Ethereum 在Ethereum上部署合约的工具有很多，您可以使 Remix 进行合约的编译和部署，这里关键的是跨链合约的获取。可以下载pier-client-ethereum项目： git clone https://github.com/meshplus/pier-client-ethereum.git && git checkout v1.6.2 说明： 1. 合约文件就在项目的example目录下，broker.sol是跨链管理合约，transfer.sol是示例业务合约； 2. 首先部署broker合约，然后将返回的合约地址填入transfer合约中的 BrokerAddr 字段，这样业务合约才能正确跨链调用。 Fabric 在Fabric上部署跨链合约工具一般是fabric-cli（可以参考 官方项目的使用说明 ）， 在Fabric上部署跨链合约的过程和部署其它合约没有区别，只是合约名称和代码文件需要替换，以下操作的命令可供参考，默认应用链是使用的fabric-sample项目的v1.4.3版本部署。 Step1: 安装部署合约的工具fabric-cli go get github.com/securekey/fabric-examples/fabric-cli/cmd/fabric-cli Step2: 获取需要部署的合约文件并解压 git clone https://github.com/meshplus/pier-client-ethereum.git && git checkout v1.6.2 # 需要部署的合约文件就在example目录下 #解压即可 unzip -q contracts.zip Step3: 部署broker、transfer合约 #安装和示例化broker合约 fabric-cli chaincode install --gopath ./contracts --ccp broker --ccid broker --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel fabric-cli chaincode instantiate --ccp broker --ccid broker --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel #安装和示例化transfer合约 fabric-cli chaincode install --gopath ./contracts --ccp transfer --ccid transfer --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel fabric-cli chaincode instantiate --ccp transfer --ccid transfer --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel #业务合约需要broker管理合约审计后，才能进行跨链交易 fabric-cli chaincode invoke --cid mychannel --ccid=broker \\ --args='{\"Func\":\"audit\", \"Args\":[\"mychannel\", \"transfer\", \"1\"]}' \\ --user Admin --orgid org2 --payload --config \"${CONFIG_YAML}\" 获取部署包和修改Pier配置 这一章是要获取部署包和修改Pier的配置，为启动pier节点作准备，主要分为pier本身和应用链插件的配置修改。可以通过源码编译和二进制下载的方式获取部署包。 获取部署包 Ethereum 源码下载编译 # 编译跨链网关本身 cd $HOME git clone https://github.com/meshplus/pier.git cd pier && git checkout v1.11.1 make prepare && make build # 编译Ethereum 插件 cd $HOME git clone https://github.com/meshplus/pier-client-ethereum.git cd pier-client-ethereum && git checkout v1.11.1 make eth # 说明：1.ethereum插件编译之后会在插件项目的build目录生成eth-client文件； 2.pier编译之后会在跨链网关项目bin目录生成同名的二进制文件。 二进制下载 除了源码编译外，我们也提供了直接下载Pier及其插件二进制的方式，下载地址链接如下： Pier二进制包下载 和 ethereum插件二进制包下载 链接中已经包含了所需的二进制程序和依赖库，您只需跟据操作系统的实际情况进行选择和下载即可。 Fabric 源码下载编译 # 编译跨链网关本身 cd $HOME git clone https://github.com/meshplus/pier.git cd pier && git checkout v1.11.1 make prepare && make build # 编译Fabric插件 cd $HOME git clone https://github.com/meshplus/pier-client-fabric.git cd pier-client-fabric && git checkout v1.11.1 make fabric1.4 # 说明：1.fabric插件编译之后会在插件项目的build目录生成fabric-client-1.4文件； 2.pier编译之后会在跨链网关项目bin目录生成同名的二进制文件。 二进制下载 除了源码编译外，我们也提供了直接下载Pier及其插件二进制的方式，下载地址链接如下： Pier二进制包下载 和 fabric插件二进制包下载 链接中已经包含了所需的二进制程序和依赖库，您只需跟据操作系统的实际情况进行选择和下载即可。 经过以上的步骤，相信您已经编译出了部署Pier和fabric/ethereum应用链插件的二进制文件，Pier节点运行还需要外部依赖库，均在项目build目录下（Macos使用libwasmer.dylib，Linux使用libwasmer.so）,建议将得到的二进制和适配的依赖库文件拷贝到同一目录，然后使用 export LD_LIBRARY_PATH=$(pwd) 命令指定依赖文件的路径，方便之后的操作。 修改Pier自身的配置 在进行应用链注册、验证规则部署等步骤之前，需要初始化跨链网关的配置目录，以用户目录下的pier为例： pier --repo=~/.pier init 该命令会生成跨链网关的一些基础配置文件模板，使用 tree 命令可查看目录信息： tree -L 1 ~/.pier ├── api ├── certs ├── key.json ├── node.priv └── pier.toml 1 directory, 4 files pier.toml是描述链跨链网关启动的主要配置，一般需要修改的是端口信息、中继链的信息、应用链的信息。 修改端口信息 [port] # 如果不冲突的话，可以不用修改 http = 44544 pprof = 44555 修改中继链信息（一般只修改addrs字段，指定bitxhub的节点地址） [mode] type = \"relay\" # relay or direct [mode.relay] addrs = [\"localhost:60011\", \"localhost:60012\", \"localhost:60013\", \"localhost:60014\"] quorum = 2 validators = [ \"0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd\", \"0xe93b92f1da08f925bdee44e91e7768380ae83307\", \"0xb18c8575e3284e79b92100025a31378feb8100d6\", \"0x856E2B9A5FA82FD1B031D1FF6863864DBAC7995D\", ] 修改应用链信息（针对不同应用链类型进行配置） Ethereum [appchain] # ethereum插件文件的名称 plugin = \"eth-client\" # ethereum配置文件夹在跨链网关配置文件夹下的相对路径 config = \"ether\" Fabric [appchain] # fabric插件文件的名称 plugin = \"fabric-client-1.4\" # ethereum配置文件夹在跨链网关配置文件夹下的相对路径 config = \"fabric\" 修改应用链插件的配置 应用链插件的配置目录即是pier.toml中的config字段，它的模板在 pier-client-ethereum 或 pier-client-ethereum 项目（之前拉取跨链合约时已经clone），直接在GitHub上下载代码即可 Ethereum # 将ethereum插件拷贝到plugins目录下 cp ether-client ~/.pier/plugins/ # 切换到pier-client-ethereum项目路径下 cd pier-client-ethereum cp ./config $HOME /.pier/ether 其中重要配置如下： ├── account.key ├── broker.abi ├── ether.validators ├── ethereum.toml ├── password └── validating.wasm 说明 ：account.key和password建议换成应用链上的真实账户，且须保证有一定金额（ethereum上调用合约需要gas费），broker.abi可以使用示例，也可以使用您自己编译/部署broker合约时返回的abi，ether.validators和validating.wasm一般不需要修改。ethereum.toml是需要重点修改的，需要根据应用链实际情况填写ethereum网络地址、broker合约地址及abi，账户的key等，示例如下： [ether] addr = \"wss://kovan.infura.io/ws/v3/cc512c8c74c94938aef1c833e1b50b9a\" name = \"ether-kovan\" ## 此处合约地址需要替换成变量代表的实际字符串 contract_address = \"$brokerAddr-kovan\" abi_path = \"broker.abi\" key_path = \"account.key\" password = \"password\" Fabric # 将fabric插件拷贝到plugins目录下 cp fabric-client-1.4 ~/.pier/plugins/ # 切换到pier-client-fabric项目路径下 cd pier-client-fabric cp ./config $HOME /.pier/fabric 其中重要配置如下： ├── crypto-config/ ├── config.yaml ├── fabric.toml ├── fabric.validators └── validating.wasm 接下来主要修改Fabric网络配置，验证证书，跨链合约设置： fabric证书配置 启动Fabric网络时，会生成所有节点（包括Order、peer等）的证书信息，并保存在 crypto-config文件夹中，Fabric插件和Fabric交互时需要用到这些证书。 # 复制您所部署的Fabric所产生的crypto-config文件夹 cp -r /path/to/crypto-config $HOME/.pier/fabric/ # 复制Fabric上验证人证书 cp $HOME/.pier/fabric/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp/signcerts/peer1.org2.example.com-cert.pem $HOME/.pier/fabric/fabric.validators 2. 修改Plugin配置文件config.yaml config.yaml 文件记录的Fabric网络配置（用您的网络拓扑配置文件替换这个样例文件），需要使用绝对路径，把所有的路径都修改为 crypto-config 文件夹所在的绝对路径。 {CONFIG_PATH}/fabric/crypto-config =>～/.pier/fabric/crypto-config # 替换为您部署的Fabric网络的拓扑设置文件即可，同时需要修改所有的Fabric 的IP地址，如： url: grpcs://localhost:7050 => url: grpcs://10.1.16.48:7050 3. 修改Plugin配置文件 fabric.toml 示例是以官方部署脚本进行配置： addr = \"localhost:7053\" // 若Fabric部署在服务器上，该为服务器地址 event_filter = \"interchain-event-name\" username = \"Admin\" ccid = \"broker\" // 若部署跨链broker合约名字不是broker需要修改 channel_id = \"mychannel\" org = \"org2\" 至此，对接ethereum和fabric应用链的pier及其插件的配置已经完成，接下来需要在测试网进行应用链注册和验证规则部署后，再启动pier节点。","text_tokens":["eth","说明","url","包含","信息","上","您","为","端口","step1","get","不","cert","包","合约","directory","如果","具体方法","$","区块","兴趣","基本上","validating","0x856e2b9a5fa82fd1b031d1ff6863864dbac7995d","中继","以","_","step2","io","ccid","需","用","并","一般","操作","cc512c8c74c94938aef1c833e1b50b9a","依次","链接","务器","ws","测试","=","examples","。","clone","peer","启动","'","可","这样","wasm","cita","不同","默认","fabric1.4","库",",","能够","编译","完成","linux","返回","invoke","即可","certs","产生","1.4","instantiate","区别","依赖","拷贝到","出","自身","开发","发起","或","sample","插件","种类","使","中","prepare","tree","gas","kovan","https","换成","运行","设置","确认","com","参与","validators","client","-","chaincode","外部","相对","bitxhub"," ","3","和","绝对","之后","macos","org","remix","key","解压","r","服务器","下载","自己","（","libwasmer","可供","管理","保存","据","&&","业务","44555","若","账户","拷贝","broker","从而","这","abi","0xb18c8575e3284e79b92100025a31378feb8100d6","到","网","部署","[","用户","bin","plugin","此处","ip地址","官方","绝对路径","l","五个","查看","名字","对接","其它","数字","plugins","保证","目前","失败","：","是","这里","一致","mychannel","priv","pem",":","工具","api","只","规则","证书","费","在","mode","interchain","transfer","指定","其","系统","or","account","注意","peer1","一些","yaml","接下","ethereum","后","的","没有","交易","不用","对应","使用","name","所","替换成","同时","文件夹","password","v1.4","audit",">","v1.11","└","实现","调用","～","经过","repo","过程","字段","16.48","接入","包括","44544","direct","zip","命令","step3","config","首先","export","金额","路径","网络拓扑","github","ccp","crypto","其中","go","均","配置","再启动","ld","cli","cd","so","记录","情况","还","冲突","也","peers","人","library","方法","项目","这个","分为","修改","git","然后","复制","地址","初始化","7050","1","重要","infura","ether","其他","id","orgid","cp","如","to","至此","具体","relay","字符串","选择","json","及其","代表","脚本","名称","作","bcos","类型","event","验证","10.1","入","段","address","所在","）","获取","0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd","针对","会","即","程序","网络地址","cmd","之前","7053","brokeraddr","接下来","描述","init","链上","/","关键","状态","化","及","#","下面","正确","signcerts","sol","pier","checkout","用到","60012","func","介绍","appchain","已经","q","且","支持","链","除了","\"","user","files","pprof","填入",")","文件","提供","home","基础","toml","0xe93b92f1da08f925bdee44e91e7768380ae83307","等","admin","order","--","注册","供参考","要","以上","args","4","unzip","securekey","相信","接受","##","可以","username","主要","进制","切换","时","需要","quorum","基本","~","得到","很多","参考","应用","相对路径","表示","把","就","拓扑","模板","示例","准备","实际","适配","同名","]","；","简称","}","example","一定","通过","contracts","(","所有","跟","type","下来","快速","确定","真实","可供参考","将","重点","生成","├","操作系统","建议","配置文件","审计","同一","节点","peerorganizations","grpcs","port","件夹","有","外","localhost","另外","payload","v3","不是","filter","参数","拉取","变量","make","60013","须","便捷","contract","审核","cid","wss","方式","一章","fabric","提前","v1.6","填写","进行","如下",".","根据","方便","pwd","安装","build","都","addr","这些","node","的话","gopath","样例","平台","2","\\","下","链是","五种","字","为例","60014","代码","二进制","目录","交互","直接","字符","─","meshplus","hyperchain","它","dylib","addrs","跨链","网络","此","、","才能","install","初始","我们","步骤","只是","msp","path","channel","60011","http","替换","版本","本身","，","网关","服务","org2","了","源码","该","以下","{"],"title":"跨链网关接入","title_tokens":["网关","跨链","接入"]},{"location":"scan/deploy_pier_testnet/#_1","text":"跨链网关Pier能够支持业务所在区块链（以下简称 应用链）便捷、快速的接入到跨链平台BitXHub中，从而实现和其他业务区块链的跨链操作。目前中继链和跨链网关已经支持 Fabric 、 Ethereum 、 BCOS 、 CITA 和 Hyperchain 五种应用链接入并完成跨链交易，如果您有兴趣，也可以参与开发适配另外种类应用链的插件和合约。 跨链网关的部署需要提前确定应用链类型（对应不同的插件和配置），也需要提前在对应的应用链上部署跨链合约，我们将跨链网关的部署依次分为如下五个步骤： 部署跨链合约 获取部署包和修改Pier配置","text_tokens":["从而","到","您","其他","适配","部署","包","简称","合约","五个","如果","区块","兴趣","目前","中继","bcos","类型","入","：","快速","所在","并","获取","确定","）","将","操作","依次","在","链接","链上","有","另外","。","ethereum","的","交易","cita","对应","不同","pier","能够","已经","便捷","支持","完成","链","实现","fabric","提前","如下","接入","开发","平台","插件","种类","中","五种","参与","配置","bitxhub"," ","hyperchain","可以","和","跨链","、","也","需要","我们","步骤","分为","，","修改","网关","（","应用","业务","以下"],"title":"跨链网关部署","title_tokens":["网关","跨链","部署"]},{"location":"scan/deploy_pier_testnet/#_2","text":"这一章是要在应用链上部署跨链合约， 注意：在此操作之前，您需要确认已经部署有可接入的应用链 。 我们提供了针对不同应用链的跨链合约，broker合约是管理合约，transfer合约是业务交易合约，需要说明的是 transfer合约需要经过broker合约审核通过后才能发起或接受跨链交易，具体方法是：调用broker合约的audit方法，其参数依次是业务合约地址和合约状态（数字1表示审核通过，数字2表示审核失败）。 下面以Ethereum和Fabric为例进行介绍，其它类型的应用链部署跨链合约的步骤基本上是一致的。 Ethereum 在Ethereum上部署合约的工具有很多，您可以使 Remix 进行合约的编译和部署，这里关键的是跨链合约的获取。可以下载pier-client-ethereum项目： git clone https://github.com/meshplus/pier-client-ethereum.git && git checkout v1.6.2 说明： 1. 合约文件就在项目的example目录下，broker.sol是跨链管理合约，transfer.sol是示例业务合约； 2. 首先部署broker合约，然后将返回的合约地址填入transfer合约中的 BrokerAddr 字段，这样业务合约才能正确跨链调用。 Fabric 在Fabric上部署跨链合约工具一般是fabric-cli（可以参考 官方项目的使用说明 ）， 在Fabric上部署跨链合约的过程和部署其它合约没有区别，只是合约名称和代码文件需要替换，以下操作的命令可供参考，默认应用链是使用的fabric-sample项目的v1.4.3版本部署。 Step1: 安装部署合约的工具fabric-cli go get github.com/securekey/fabric-examples/fabric-cli/cmd/fabric-cli Step2: 获取需要部署的合约文件并解压 git clone https://github.com/meshplus/pier-client-ethereum.git && git checkout v1.6.2 # 需要部署的合约文件就在example目录下 #解压即可 unzip -q contracts.zip Step3: 部署broker、transfer合约 #安装和示例化broker合约 fabric-cli chaincode install --gopath ./contracts --ccp broker --ccid broker --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel fabric-cli chaincode instantiate --ccp broker --ccid broker --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel #安装和示例化transfer合约 fabric-cli chaincode install --gopath ./contracts --ccp transfer --ccid transfer --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel fabric-cli chaincode instantiate --ccp transfer --ccid transfer --config \"${CONFIG_YAML}\" --orgid org2 --user Admin --cid mychannel #业务合约需要broker管理合约审计后，才能进行跨链交易 fabric-cli chaincode invoke --cid mychannel --ccid=broker \\ --args='{\"Func\":\"audit\", \"Args\":[\"mychannel\", \"transfer\", \"1\"]}' \\ --user Admin --orgid org2 --payload --config \"${CONFIG_YAML}\"","text_tokens":["broker","这","说明","示例","上","您","部署","[","step1","get","orgid","]","；","}","合约","example","官方","通过","contracts","具体","具体方法","$","{","基本上","其它","数字","名称","失败","以","_","类型","step2","：","是","ccid","这里","段","一致","）","获取","并","mychannel","针对","一般","可供参考","将",":","操作","工具","依次","在","cmd","之前","transfer","其","brokeraddr","审计","链上","有","=","注意","/","关键","状态","化","yaml","examples","。","clone","payload","ethereum","后","#","的","没有","'","可","这样","交易","下面","不同","默认","使用","参数","&&","正确","sol","pier","checkout","func","介绍","v1.4",",","已经","audit","编译","q","链","审核","cid","\"","返回","invoke","user","调用","一章","填入","fabric","v1.6","经过","进行","即可","过程",".","文件","安装","instantiate","区别","接入","提供","zip","命令","step3","gopath","首先","config","发起","或","sample","使","中","2","admin","下","\\","https","链是","字","为例","确认","github","--","ccp","com","代码","供参考","要","go","目录","client","-","chaincode","args","meshplus"," ","unzip","3","securekey","接受","cli","可以","和","跨链","此","、","remix","才能","install","需要","我们","步骤","只是","方法","解压","项目","替换","版本","下载","，","基本","（","git","org2","很多","然后","地址","参考","可供","应用","了","管理","表示","业务","就","以下","1"],"title":"部署跨链合约","title_tokens":["合约","跨链","部署"]},{"location":"scan/deploy_pier_testnet/#pier","text":"这一章是要获取部署包和修改Pier的配置，为启动pier节点作准备，主要分为pier本身和应用链插件的配置修改。可以通过源码编译和二进制下载的方式获取部署包。","text_tokens":["这","编译","二进制","要","准备","链","为","配置","部署","方式","一章","包","节点","可以","和","通过","主要","进制","。","的","启动","作","分为","本身","下载","，","修改","插件","是","应用","pier","源码","获取"],"title":"获取部署包和修改Pier配置","title_tokens":["修改","包","和","pier","配置","获取","部署"]},{"location":"scan/deploy_pier_testnet/#_3","text":"Ethereum 源码下载编译 # 编译跨链网关本身 cd $HOME git clone https://github.com/meshplus/pier.git cd pier && git checkout v1.11.1 make prepare && make build # 编译Ethereum 插件 cd $HOME git clone https://github.com/meshplus/pier-client-ethereum.git cd pier-client-ethereum && git checkout v1.11.1 make eth # 说明：1.ethereum插件编译之后会在插件项目的build目录生成eth-client文件； 2.pier编译之后会在跨链网关项目bin目录生成同名的二进制文件。 二进制下载 除了源码编译外，我们也提供了直接下载Pier及其插件二进制的方式，下载地址链接如下： Pier二进制包下载 和 ethereum插件二进制包下载 链接中已经包含了所需的二进制程序和依赖库，您只需跟据操作系统的实际情况进行选择和下载即可。 Fabric 源码下载编译 # 编译跨链网关本身 cd $HOME git clone https://github.com/meshplus/pier.git cd pier && git checkout v1.11.1 make prepare && make build # 编译Fabric插件 cd $HOME git clone https://github.com/meshplus/pier-client-fabric.git cd pier-client-fabric && git checkout v1.11.1 make fabric1.4 # 说明：1.fabric插件编译之后会在插件项目的build目录生成fabric-client-1.4文件； 2.pier编译之后会在跨链网关项目bin目录生成同名的二进制文件。 二进制下载 除了源码编译外，我们也提供了直接下载Pier及其插件二进制的方式，下载地址链接如下： Pier二进制包下载 和 fabric插件二进制包下载 链接中已经包含了所需的二进制程序和依赖库，您只需跟据操作系统的实际情况进行选择和下载即可。 经过以上的步骤，相信您已经编译出了部署Pier和fabric/ethereum应用链插件的二进制文件，Pier节点运行还需要外部依赖库，均在项目build目录下（Macos使用libwasmer.dylib，Linux使用libwasmer.so）,建议将得到的二进制和适配的依赖库文件拷贝到同一目录，然后使用 export LD_LIBRARY_PATH=$(pwd) 命令指定依赖文件的路径，方便之后的操作。","text_tokens":["拷贝","eth","说明","包含","您","实际","部署","同名","适配","；","bin","包","$","选择","(","及其","跟","_","：","需","）","会","将",":","操作","生成","只","程序","在","指定","操作系统","链接","建议","同一","节点","系统","=","外","/","。","clone","ethereum","#","的","使用","checkout","pier","所","fabric1.4","库","make",",","编译","已经","v1.11","linux","链","除了","方式","fabric",")","即可","进行","经过","如下",".","文件","1.4","方便","pwd","build","依赖","拷贝到","出","提供","home","命令","export","源码","插件","路径","prepare","中","2","下","https","运行","github","com","二进制","目录","client","-","直接","均","以上","外部","meshplus"," ","ld","相信","cd","dylib","so","和","跨链","情况","还","之后","macos","进制","也","需要","我们","步骤","path","library","项目","本身","下载","，","网关","git","（","libwasmer","得到","然后","地址","了","应用","据","&&","1"],"title":"获取部署包","title_tokens":["包","获取","部署"]},{"location":"scan/deploy_pier_testnet/#pier_1","text":"在进行应用链注册、验证规则部署等步骤之前，需要初始化跨链网关的配置目录，以用户目录下的pier为例： pier --repo=~/.pier init 该命令会生成跨链网关的一些基础配置文件模板，使用 tree 命令可查看目录信息： tree -L 1 ~/.pier ├── api ├── certs ├── key.json ├── node.priv └── pier.toml 1 directory, 4 files pier.toml是描述链跨链网关启动的主要配置，一般需要修改的是端口信息、中继链的信息、应用链的信息。 修改端口信息 [port] # 如果不冲突的话，可以不用修改 http = 44544 pprof = 44555 修改中继链信息（一般只修改addrs字段，指定bitxhub的节点地址） [mode] type = \"relay\" # relay or direct [mode.relay] addrs = [\"localhost:60011\", \"localhost:60012\", \"localhost:60013\", \"localhost:60014\"] quorum = 2 validators = [ \"0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd\", \"0xe93b92f1da08f925bdee44e91e7768380ae83307\", \"0xb18c8575e3284e79b92100025a31378feb8100d6\", \"0x856E2B9A5FA82FD1B031D1FF6863864DBAC7995D\", ] 修改应用链信息（针对不同应用链类型进行配置） Ethereum [appchain] # ethereum插件文件的名称 plugin = \"eth-client\" # ethereum配置文件夹在跨链网关配置文件夹下的相对路径 config = \"ether\" Fabric [appchain] # fabric插件文件的名称 plugin = \"fabric-client-1.4\" # ethereum配置文件夹在跨链网关配置文件夹下的相对路径 config = \"fabric\"","text_tokens":["模板","eth","0xb18c8575e3284e79b92100025a31378feb8100d6","信息","ether","端口","部署","[","用户","不","]","plugin","l","directory","如果","relay","查看","json","0x856e2b9a5fa82fd1b031d1ff6863864dbac7995d","名称","中继","以","类型","验证","type","：","是","）","priv","0x000f1a7a08ccc48e5d30f80850cf1cf283aa3abd","针对","会","一般",":","api","生成","规则","只","在","mode","├","之前","指定","配置文件","描述","节点","init","port","or","件夹","=","/","localhost","一些","。","ethereum","#","的","启动","可","不用","不同","使用","pier","60012","文件夹","60013","appchain",",","└","链","\"","files","pprof","fabric","进行","repo","certs","字段",".","文件","1.4","node","的话","44544","direct","基础","命令","config","toml","插件","路径","0xe93b92f1da08f925bdee44e91e7768380ae83307","等","tree","2","下","为例","注册","--","60014","validators","目录","client","-","配置","4","─","bitxhub"," ","相对","addrs","可以","跨链","冲突","、","主要","初始","需要","步骤","key","quorum","60011","http","，","修改","网关","~","（","地址","应用","初始化","相对路径","44555","该","1"],"title":"修改Pier自身的配置","title_tokens":["修改","的","自身","pier","配置"]},{"location":"scan/deploy_pier_testnet/#_4","text":"应用链插件的配置目录即是pier.toml中的config字段，它的模板在 pier-client-ethereum 或 pier-client-ethereum 项目（之前拉取跨链合约时已经clone），直接在GitHub上下载代码即可 Ethereum # 将ethereum插件拷贝到plugins目录下 cp ether-client ~/.pier/plugins/ # 切换到pier-client-ethereum项目路径下 cd pier-client-ethereum cp ./config $HOME /.pier/ether 其中重要配置如下： ├── account.key ├── broker.abi ├── ether.validators ├── ethereum.toml ├── password └── validating.wasm 说明 ：account.key和password建议换成应用链上的真实账户，且须保证有一定金额（ethereum上调用合约需要gas费），broker.abi可以使用示例，也可以使用您自己编译/部署broker合约时返回的abi，ether.validators和validating.wasm一般不需要修改。ethereum.toml是需要重点修改的，需要根据应用链实际情况填写ethereum网络地址、broker合约地址及abi，账户的key等，示例如下： [ether] addr = \"wss://kovan.infura.io/ws/v3/cc512c8c74c94938aef1c833e1b50b9a\" name = \"ether-kovan\" ## 此处合约地址需要替换成变量代表的实际字符串 contract_address = \"$brokerAddr-kovan\" abi_path = \"broker.abi\" key_path = \"account.key\" password = \"password\" Fabric # 将fabric插件拷贝到plugins目录下 cp fabric-client-1.4 ~/.pier/plugins/ # 切换到pier-client-fabric项目路径下 cd pier-client-fabric cp ./config $HOME /.pier/fabric 其中重要配置如下： ├── crypto-config/ ├── config.yaml ├── fabric.toml ├── fabric.validators └── validating.wasm 接下来主要修改Fabric网络配置，验证证书，跨链合约设置： fabric证书配置 启动Fabric网络时，会生成所有节点（包括Order、peer等）的证书信息，并保存在 crypto-config文件夹中，Fabric插件和Fabric交互时需要用到这些证书。 # 复制您所部署的Fabric所产生的crypto-config文件夹 cp -r /path/to/crypto-config $HOME/.pier/fabric/ # 复制Fabric上验证人证书 cp $HOME/.pier/fabric/crypto-config/peerOrganizations/org2.example.com/peers/peer1.org2.example.com/msp/signcerts/peer1.org2.example.com-cert.pem $HOME/.pier/fabric/fabric.validators 2. 修改Plugin配置文件config.yaml config.yaml 文件记录的Fabric网络配置（用您的网络拓扑配置文件替换这个样例文件），需要使用绝对路径，把所有的路径都修改为 crypto-config 文件夹所在的绝对路径。 {CONFIG_PATH}/fabric/crypto-config =>～/.pier/fabric/crypto-config # 替换为您部署的Fabric网络的拓扑设置文件即可，同时需要修改所有的Fabric 的IP地址，如： url: grpcs://localhost:7050 => url: grpcs://10.1.16.48:7050 3. 修改Plugin配置文件 fabric.toml 示例是以官方部署脚本进行配置： addr = \"localhost:7053\" // 若Fabric部署在服务器上，该为服务器地址 event_filter = \"interchain-event-name\" username = \"Admin\" ccid = \"broker\" // 若部署跨链broker合约名字不是broker需要修改 channel_id = \"mychannel\" org = \"org2\" 至此，对接ethereum和fabric应用链的pier及其插件的配置已经完成，接下来需要在测试网进行应用链注册和验证规则部署后，再启动pier节点。","text_tokens":["拷贝","broker","拓扑","模板","重要","abi","说明","infura","url","示例","上","到","ether","您","信息","为","网","部署","实际","[","id","不","]","cert","cp","此处","to","合约","plugin","example","绝对路径","一定","}","ip地址","官方","至此","$","字符串","名字","对接","及其","所有","validating","代表","plugins","保证","脚本","_","以","event","验证","10.1","io","：","是","用","ccid","address","下来","所在","）","并","pem","mychannel","真实","一般","会","将","即",":","重点","cc512c8c74c94938aef1c833e1b50b9a","生成","规则","证书","费","在","网络地址","├","之前","interchain","7053","brokeraddr","建议","务器","接下来","ws","peerorganizations","节点","配置文件","grpcs","该","链上","件夹","测试","account","有","=","peer1","/","localhost","yaml","接下","。","clone","及","ethereum","#","peer","后","的","启动","v3","不是","wasm","filter","使用","拉取","变量","signcerts","pier","用到","name","所","替换成","同时","文件夹","password","已经","须","且","编译",">","contract","└","链","完成","wss","\"","返回","调用","fabric","～","即可","填写","进行","如下","字段",".","根据","文件","1.4","产生","16.48","包括","都","addr","这些","拷贝到","home","config","样例","或","toml","金额","插件","路径","如","中","网络拓扑","等","gas","2","admin","下","kovan","换成","设置","order","注册","github","crypto","其中","com","代码","validators","目录","client","-","直接","交互","字符","配置","再启动","─"," ","3","它","cd","##","可以","记录","和","跨链","情况","绝对","网络","username","org","、","主要","切换","也","时","需要","人","peers","msp","path","key","channel","项目","这个","r","替换","服务器","下载","，","修改","自己","（","~","org2","服务","复制","地址","应用","保存","把","7050","若","{","账户"],"title":"修改应用链插件的配置","title_tokens":["修改","插件","的","应用","链","配置"]},{"location":"sdk/gosdk/","text":"Go SDK 1 前言 此SDK文档面向BitXHub平台的应用开发者，提供BitXHub Go SDK的使用指南。 2 接口使用流程示例 2.1 基础流程示例 为了更好的理解接口的使用，本示例将从初始化Client，部署合约，调用合约和返回值解析这个大致流程作介绍，具体详细接口可参考第三章SDK文档。 2.1.1 初始化Client 配置集群网络地址、日志以及密钥。 例如： privKey , err := asym . GenerateKeyPair ( crypto . Secp256k1 ) var cfg = & config { addrs : [] string { \"localhost:60011\" , \"localhost:60012\" , \"localhost:60013\" , \"localhost:60014\" , }, logger : logrus . New (), privateKey : privKey , } 初始化Client，所有RPC操作将通过该接口与BitXHub交互。 例如： cli , err := New ( WithAddrs ( cfg . addrs ), WithLogger ( cfg . logger ), WithPrivateKey ( cfg . privateKey ), ) 2.1.2 部署合约 开发者需提供已经编译的 WebAssembly 文件。 例如： contract , err := ioutil . ReadFile ( \"./testdata/example.wasm\" ) 通过client部署合约，部署完成后可以获取合约地址 addr 。 例如： addr , err := cli . DeployContract ( contract , nil ) // 第二个参数为跨链交易nonce，为nil时可以自动获取 2.1.3 调用合约 调用合约需传入合约地址、合约方法名和对应的参数。 例如： result , err := cli . InvokeXVMContract ( addr , \"a\" , nil , Int32 ( 1 ), Int32 ( 2 )) // 方法名为a，跨链交易nonce，传参1，传参2 2.1.4 返回值解析 得到返回值结果后，获得状态码可以判断是否调用成功，若调用成功，解析返回值可看到调用之后的结果。 例如： if cli . CheckReceipt ( result ) { fmt . Println ( string ( result . Ret )) } 2.1.5 完整示例 //获取wasm合约字节数组 contract , _ := ioutil . ReadFile ( \"./testdata/example.wasm\" ) //部署合约，获取合约地址 addr , _ := cli . DeployContract ( contract , nil ) //调用合约，获取交易回执 result , _ := cli . InvokeXVMContract ( addr , \"a\" , nil , Int32 ( 1 ), Int32 ( 2 )) //判断合约调用交易成功与否，打印合约调用数据 if cli . CheckReceipt ( result ) { fmt . Println ( string ( result . Ret )) } 2.2 应用链管理流程示例 本示例展示应用链管理流程中的注册、审核以及注销操作。 2.2.1 应用链注册 调用BVM合约的 Register 方法，向BitXHub注册应用链。 例如： args := [] * pb . Arg { rpcx . String ( \"\" ), //validators rpcx . Int32 ( 0 ), //consensus_type rpcx . String ( \"hyperchain\" ), //chain_type rpcx . String ( \"税务链\" ), //name rpcx . String ( \"趣链税务链\" ), //desc rpcx . String ( \"1.8\" ), //version } ret , err := cli . InvokeBVMContract ( constant . InterchainContractAddr . Address (), \"Register\" , nil , args ... ) 获取到成功的交易回执后，解析交易回执内容。 例如： { \"id\" : \"0x5098cc26b0d485145fb8258d2e79c49886cd4662\" , \\\\ 应用链ID \"name\" : \"税务链\" , \"validators\" : \"\" , \"consensus_type\" : 0 , \"status\" : 0 , \"chain_type\" : \"hyperchain\" , \"desc\" : \"趣链税务链\" , \"version\" : \"1.8\" } 2.2.2 应用链审核 调用BVM合约的 Aduit 方法，向BitXHub审核应用链。 例如： args := [] * pb . Arg { rpcx . String ( appchainID ), rpcx . Int32 ( 1 ), //审核通过 rpcx . String ( \"\" ), //desc } ret , err = cli . InvokeBVMContract ( constant . InterchainContractAddr . Address (), \"Aduit\" , nil , args ... ) 2.2.3 应用链注销 调用BVM合约的 DeleteAppchain 方法，向BitXHub注销应用链。 例如： ret , err = cli . InvokeBVMContract ( constant . InterchainContractAddr . Address (), \"DeleteAppchain\" , nil , rpcx . String ( appchainID )) 2.3 验证规则使用示例 本示例展示验证规则中的注册、审核操作，以及WebAssembly合约示例。 2.3.1 验证规则注册 调用BVM合约的 RegisterRule 方法，向应用链注册验证规则（WebAssembly合约），这里我们需要先注册应用链和部署验证规则合约，然后获取应用链ID和合约地址。 例如： ret , err = cli . InvokeBVMContract ( constant . RoleContractAddr . Address (), \"RegisterRule\" , nil , rpcx . String ( chainAddr ), rpcx . String ( contractAddr )) 2.3.2 验证规则审核 调用BVM合约的 Aduit 方法，向BitXHub审核验证规则。 例如： args := [] * pb . Arg { rpcx . String ( appchainID ), rpcx . Int32 ( 1 ), //审核通过 rpcx . String ( \"\" ), //desc } ret , err = cli . InvokeBVMContract ( constant . RuleManagerContractAddr . Address (), \"Aduit\" , nil , args ... ) 2.3.3 验证规则示例（WebAssembly合约, Fabric实例） extern crate protobuf ; extern crate sha2 ; use crate :: crypto :: ecdsa ; use crate :: model :: transaction ; use sha2 :: { Digest , Sha256 }; pub fn verify ( proof : & [ u8 ], validator : & [ u8 ]) -> bool { let cap = protobuf :: parse_from_bytes :: < transaction :: ChaincodeActionPayload > ( proof ). expect ( \"error\" ); let cap_act = cap . action . unwrap (); let endorsers = cap_act . endorsements ; let mut digest = Sha256 :: new (); let mut payload = cap_act . proposal_response_payload . to_owned (); payload . extend ( & endorsers [ 0 ]. endorser ); digest . input ( & payload ); let digest_byte = digest . result (); return ecdsa :: verify ( & endorsers [ 0 ]. signature , & digest_byte , & validator , ecdsa :: EcdsaAlgorithmn :: P256 , ); } 3 SDK文档 3.1 初始化和启动 3.1.1 初始化Client 用途：调用该接口获取与中继链交互的Client。 参数： opts 是中继链的网络地址，日志以及密钥的配置。 func New ( opts ... Option ) ( * ChainClient , error ) 3.1.2 停止Client 用途：调用该接口将与中继链交互的 Client 关闭。 func Stop () error 3.2 交易接口 3.2.1 发送交易 用途：调用该接口向中继链发送交易，交易类型包括普通交易、跨链交易和智能合约。 参数： tx 交易实例。 opts 跨链交易nonce。 func SendTransaction ( tx * pb . Transaction , opts * TransactOpts ) ( string , error ) 3.2.2 查询交易回执 用途：调用该接口向BitXHub查询交易回执。 参数： hash 交易哈希。 func GetReceipt ( hash string ) ( * pb . Receipt , error ) 用例： func TestChainClient_SendTransactionWithReceipt ( t * testing . T ) { // 生成from私钥 privKey , _ := asym . GenerateKeyPair ( crypto . Secp256k1 ) // 生成to私钥 toPrivKey , _ := asym . GenerateKeyPair ( crypto . Secp256k1 ) // 配置Client cli , _ := New ( WithAddrs ( cfg . addrs ), WithLogger ( cfg . logger ), WithPrivateKey ( privKey ), ) // 获取from地址 from , _ := privKey . PublicKey (). Address () // 获取to地址 to , _ := toPrivKey . PublicKey (). Address () // 构建交易体 tx := & pb . Transaction { From : from , To : to , Data : & pb . TransactionData { Amount : 10 , }, Timestamp : time . Now (). UnixNano (), Nonce : rand . Int63 (), } // 用from的私钥签名交易 _ = tx . Sign ( privKey ) // 通过client发送交易 hash , _ := cli . SendTransaction ( tx , nil ) // 获取交易回执，判断交易执行状态 ret , _ := cli . GetReceipt ( hash ) require . Equal ( t , tx . Hash (). String (), ret . TxHash . String ()) // 停止client _ = cli . Stop () } 3.2.3 查询交易 用途：调用该接口向BitXHub查询交易。 参数： hash 交易哈希。 func GetTransaction ( hash string ) ( * proto . GetTransactionResponse , error ) 3.3 合约接口 合约类型： BVM：BitXHub内置合约。 XVM：WebAssembly合约。 3.3.1 部署合约 用途：调用该接口向BitXHub部署XVM合约，返回合约地址。 参数： contract wasm合约编译后的字节数据。 opts 跨链交易nonce。 func DeployContract ( contract [] byte , opts * TransactOpts ) ( contractAddr * types . Address , err error ) 3.3.2 调用合约 用途：该接口向中继链调用合约获取交易回执。 参数： vmType 合约类型：BVM和XVM； address 合约地址； method 合约方法； opts 跨链交易nonce； args 合约方法参数。 func InvokeContract ( vmType pb . TransactionData_VMType , address types . Address , method string , opts * TransactOpts , args ...* pb . Arg ) ( * pb . Receipt , error ) 调用XVM合约用例： func TestChainClient_InvokeXVMContract ( t * testing . T ) { privKey , err := asym . GenerateKeyPair ( crypto . Secp256k1 ) require . Nil ( t , err ) cli , err := New ( WithAddrs ( cfg . addrs ), WithLogger ( cfg . logger ), WithPrivateKey ( privKey ), ) require . Nil ( t , err ) contract , err := ioutil . ReadFile ( \"./testdata/example.wasm\" ) require . Nil ( t , err ) addr , err := cli . DeployContract ( contract , nil ) require . Nil ( t , err ) result , err := cli . InvokeXVMContract ( addr , \"a\" , nil , Int32 ( 1 ), Int32 ( 2 )) require . Nil ( t , err ) require . Equal ( t , \"336\" , string ( result . Ret )) } 调用BVM合约用例： func TestChainClient_InvokeBVMContract ( t * testing . T ) { privKey , err := asym . GenerateKeyPair ( crypto . Secp256k1 ) require . Nil ( t , err ) cli , err := New ( WithAddrs ( cfg . addrs ), WithLogger ( cfg . logger ), WithPrivateKey ( privKey ), ) require . Nil ( t , err ) result , err := cli . InvokeBVMContract ( constant . StoreContractAddr . Address (), \"Set\" , nil , String ( \"a\" ), String ( \"10\" )) require . Nil ( t , err ) require . Nil ( t , result . Ret ) res , err := cli . InvokeBVMContract ( constant . StoreContractAddr . Address (), \"Get\" , nil , String ( \"a\" )) require . Nil ( t , err ) require . Equal ( t , string ( res . Ret ), \"10\" ) } 3.4 区块接口 3.4.1 查询区块 参数： value 区块高度或者区块哈希。 blockType 查询类型。 GetBlock ( value string , blockType pb . GetBlockRequest_Type ) ( * pb . Block , error ) 3.4.2 批量查询区块 用途：批量查询区块，返回指定块高度范围（start到end）的区块信息。 参数： start 指定范围的起始区块高度。 end 指定范围的结束区块高度。 func GetBlocks ( start uint64 , end uint64 ) ( * pb . GetBlocksResponse , error ) 3.4.3 查询区块Meta 用途：返回当前链的高度和区块哈希。 func GetChainMeta () ( * pb . ChainMeta , error ) 3.4.4 查询区块链状态 用途：返回当前区块链共识的状态（正常或者不正常）。 func GetChainStatus () ( * pb . Response , error ) 3.5 订阅接口 3.5.1 订阅事件 用途：调用该接口向中继链发起订阅事件的。 参数： type 事件类型，包含区块事件，区块头事件，跨链交易事件。 func Subscribe ( ctx context . Context , typ pb . SubscriptionRequest_Type , extra [] byte ) ( <- chan interface {}, error ) 用例： func TestChainClient_Subscribe ( t * testing . T ) { privKey , err := asym . GenerateKeyPair ( crypto . Secp256k1 ) require . Nil ( t , err ) from , err := privKey . PublicKey (). Address () require . Nil ( t , err ) cli , err := New ( WithAddrs ( cfg . addrs ), WithLogger ( cfg . logger ), WithPrivateKey ( privKey ), ) require . Nil ( t , err ) ctx , cancel := context . WithCancel ( context . Background ()) defer cancel () c , err := cli . Subscribe ( ctx , pb . SubscriptionRequest_BLOCK , nil ) assert . Nil ( t , err ) go func () { tx := & pb . Transaction { From : from , To : from , Timestamp : time . Now (). UnixNano (), Nonce : rand . Int63 (), } err = tx . Sign ( privKey ) require . Nil ( t , err ) hash , err := cli . SendTransaction ( tx , nil ) require . Nil ( t , err ) require . EqualValues ( t , 66 , len ( hash )) }() for { select { case block := <- c : if block == nil { assert . Error ( t , fmt . Errorf ( \"channel is closed\" )) return } if err := cli . Stop (); err != nil { return } return case <- ctx . Done (): return } } } 3.5.2 获取MerkleWrapper 用途：获取指定区块高度范围的MerkleWrapper 参数： pid 应用链ID。 begin 起始区块高度。 end 结束区块高度。 ch Merkle Wrapper的通道。 func GetInterchainTxWrappers ( ctx context . Context , pid string , begin , end uint64 , ch chan <- * pb . InterchainTxWrapper ) error 3.6 其它接口 3.6.1 查询节点网络信息 用途：返回当前区块链网络的节点信息。 func GetNetworkMeta () ( * pb . Response , error ) 3.6.2 查询账户余额 参数： address 地址。 func GetAccountBalance ( address string ) ( * pb . Response , error ) 3.6.3 删除节点 用途：删除区块链网络中的节点（须往f+1个节点发送请求才可以删除） 参数： pid 节点的pid func DelVPNode ( pid string ) ( * pb . Response , error )","text_tokens":["2.3","普通","包含","信息","cfg","为","get","不","select","合约","delvpnode","区块","contractaddr","now","logrus","中继","new","_","withlogger","ioutil","需","用","理解","return","option","操作","趣链","rand","testchainclient","回执","=","tx","unixnano","withcancel","。","停止","启动","可","wasm","ecdsa","chainaddr","第二","或者","例如","digest","关闭",",","编译","接口","字节","完成","返回","webassembly","p256","sendtransaction","cancel","开发","ecdsaalgorithmn","toprivkey","发起",";","中","block","deleteappchain","start","unwrap","interchaintxwrapper","删除","以及","validators","client","-","xvm","bitxhub","string"," ","3","起始","proto","和","checkreceipt","sha256","之后","subscribe","logger","执行","println","testing","名为","2.2","密钥","注销","（","rolecontractaddr","gettransactionresponse","管理","体","若","账户","336","getchainstatus","2.1","到","registerrule","使用指南","sdk","部署","[","register","流程","getaccountbalance","data","endorser","批量","其它","请求","文档","let","signature","timestamp","：","是","这里","readfile","成功","context",":","sign","规则","action","第三","ch","typ","指定","0","指南","签名","from","len","66","sha2","3.4","后","的","与","rulemanagercontractaddr","交易","余额","对应","cap","为了","使用","先","end","二个","name","nil","blocktype","stop","response",">","for","调用","rpcx","返回值","nonce","自动","内置","+","本","集群","done","哈希","appchainid","mut","包括","传参","获得","当前","subscriptionrequest","endorsers","头","config","int32","私钥","范围","内容","deploycontract","crypto","getblockrequest","go","wrapper","解析","配置","getblocksresponse","cli","assert","bytes","testdata","method","proof","方法","validator","aduit","这个","privkey","a","3.1","interchaincontractaddr","然后","向","地址","初始化","consensus","1","time","前言","arg","用途","id","!","to","事件","具体","日志","is","desc","chainmeta","是否","verify","version","作","expect","类型","fn","3.5","验证","getinterchaintxwrappers","closed","endorsements","error","共识","address","invokexvmcontract","获取","）","判断","第二个","网络地址","rpc","须往","getchainmeta","码","/","面向","res","状态","chan","set","invokecontract","通道","value","个","展示","owned","传入","60012","pid","act","func","介绍","sendtransactionwithreceipt","已经","extend","secp256k1","链","bool","\"","10","background","var","看到","withaddrs",")","实例","status","&","文件","opts","订阅","查询","int63","hash","getreceipt","提供","byte","基础","gettransaction","require","result","merklewrapper","注册","fmt","args","发送","4","chain","ctx","结束","constant","可以","3.6","input","用例","bvm","时","需要","txhash","打印","ret","三章","transactiondata","得到","参考","应用","types","示例","crate","]","t","begin","；","}","第三章","example","通过","invokebvmcontract","(","extern","chaincodeactionpayload","所有","receipt","1.8","完整","5","...","type","getblocks","才","privatekey","详细","proposal","publickey","将","asym","errorf","生成","高度","3.2","与否","getblock","构建","case","节点","use","merkle","结果","pb","if","localhost","withprivatekey","payload","交易类型","model","税务","<","智能","transactopts","参数","从","c","60013","pub","名","contract","审核","vmtype","getnetworkmeta","fabric",".","3.3","meta","err","addr","protobuf","equal","amount","块","*","平台","interface","parse","transaction","defer","2","\\","f","60014","数组","交互","equalvalues","chainclient","generatekeypair","大致","hyperchain","addrs","正常","跨链","网络","此","更好","、","初始","我们","channel","uint64","60011","u8","extra","storecontractaddr","，","0x5098cc26b0d485145fb8258d2e79c49886cd4662","开发者","该","{","数据"],"title":"GoSDK使用文档","title_tokens":["文档","gosdk","使用"]},{"location":"sdk/gosdk/#go-sdk","text":"","text_tokens":[],"title":"Go SDK","title_tokens":["sdk","go"," "]},{"location":"sdk/gosdk/#1","text":"此SDK文档面向BitXHub平台的应用开发者，提供BitXHub Go SDK的使用指南。","text_tokens":["，","平台","指南"," ","。","go","使用","文档","的","应用","使用指南","提供","此","开发","开发者","sdk","bitxhub","面向"],"title":"1 前言","title_tokens":["前言","1"," "]},{"location":"sdk/gosdk/#2","text":"","text_tokens":[],"title":"2 接口使用流程示例","title_tokens":["流程","接口","使用","2","示例"," "]},{"location":"sdk/gosdk/#21","text":"为了更好的理解接口的使用，本示例将从初始化Client，部署合约，调用合约和返回值解析这个大致流程作介绍，具体详细接口可参考第三章SDK文档。","text_tokens":["将","介绍","接口","client","示例","第三","解析","sdk","部署","返回","大致","调用","流程","返回值","合约","第三章","本","和","具体","更好","初始","。","文档","的","这个","可","三章","作","，","为了","使用","详细","参考","初始化","从","理解"],"title":"2.1 基础流程示例","title_tokens":["流程","示例","2.1","基础"," "]},{"location":"sdk/gosdk/#211-client","text":"配置集群网络地址、日志以及密钥。 例如： privKey , err := asym . GenerateKeyPair ( crypto . Secp256k1 ) var cfg = & config { addrs : [] string { \"localhost:60011\" , \"localhost:60012\" , \"localhost:60013\" , \"localhost:60014\" , }, logger : logrus . New (), privateKey : privKey , } 初始化Client，所有RPC操作将通过该接口与BitXHub交互。 例如： cli , err := New ( WithAddrs ( cfg . addrs ), WithLogger ( cfg . logger ), WithPrivateKey ( cfg . privateKey ), )","text_tokens":["asym","60013",":","crypto",",","60014","操作","将","接口","以及","client","交互","网络地址","secp256k1","rpc","cfg","配置","\"","generatekeypair","["," ","string","bitxhub","var","]","cli","}","withaddrs","addrs","集群",")","通过","网络","日志","、","=",".","&","logger","localhost","(","withprivatekey","初始","err","所有","。","与","logrus","privkey","60011","new","config","密钥","，","privatekey","：","withlogger","例如","地址","初始化","该","60012","{"],"title":"2.1.1 初始化Client","title_tokens":["初始","client","2.1","初始化",".","1"," "]},{"location":"sdk/gosdk/#212","text":"开发者需提供已经编译的 WebAssembly 文件。 例如： contract , err := ioutil . ReadFile ( \"./testdata/example.wasm\" ) 通过client部署合约，部署完成后可以获取合约地址 addr 。 例如： addr , err := cli . DeployContract ( contract , nil ) // 第二个参数为跨链交易nonce，为nil时可以自动获取","text_tokens":["nil","第二个",":",",","已经","编译","client","contract","完成","\"","为","部署"," ","cli","nonce","合约","自动","example",")","可以","testdata","通过","跨链","webassembly",".","文件","=","/","(","时","err","。","addr","后","的","提供","开发","交易","wasm","，","：","第二","例如","ioutil","需","地址","参数","deploycontract","readfile","二个","开发者","获取"],"title":"2.1.2 部署合约","title_tokens":["合约","2","2.1",".","部署"," "]},{"location":"sdk/gosdk/#213","text":"调用合约需传入合约地址、合约方法名和对应的参数。 例如： result , err := cli . InvokeXVMContract ( addr , \"a\" , nil , Int32 ( 1 ), Int32 ( 2 )) // 方法名为a，跨链交易nonce，传参1，传参2","text_tokens":["nil",":",",","名","\""," ","调用","cli","nonce","合约",")","和","跨链","、","=",".","/","(","err","。","addr","传参","方法","的","名为","a","交易","int32","，","对应","传入","result","：","例如","地址","需","参数","2","invokexvmcontract","1"],"title":"2.1.3 调用合约","title_tokens":["调用","3","合约","2.1","."," "]},{"location":"sdk/gosdk/#214","text":"得到返回值结果后，获得状态码可以判断是否调用成功，若调用成功，解析返回值可看到调用之后的结果。 例如： if cli . CheckReceipt ( result ) { fmt . Println ( string ( result . Ret )) }","text_tokens":["fmt","解析","返回","string"," ","调用","看到","返回值","cli","}",")","可以","checkreceipt","之后","结果",".","码","if","(","状态","println","。","是否","获得","后","ret","的","可","，","得到","result","：","例如","成功","若","{","判断"],"title":"2.1.4 返回值解析","title_tokens":["返回值","2.1","解析",".","4","返回"," "]},{"location":"sdk/gosdk/#215","text":"//获取wasm合约字节数组 contract , _ := ioutil . ReadFile ( \"./testdata/example.wasm\" ) //部署合约，获取合约地址 addr , _ := cli . DeployContract ( contract , nil ) //调用合约，获取交易回执 result , _ := cli . InvokeXVMContract ( addr , \"a\" , nil , Int32 ( 1 ), Int32 ( 2 )) //判断合约调用交易成功与否，打印合约调用数据 if cli . CheckReceipt ( result ) { fmt . Println ( string ( result . Ret )) }","text_tokens":["nil",":",",","fmt","数组","contract","字节","\"","部署","string"," ","调用","cli","与否","合约","}","example",")","testdata","回执","checkreceipt","{","数据",".","=","if","/","(","println","addr","打印","ret","a","交易","_","int32","wasm","，","result","ioutil","地址","2","deploycontract","readfile","成功","invokexvmcontract","获取","1","判断"],"title":"2.1.5 完整示例","title_tokens":["2.1","示例",".","完整","5"," "]},{"location":"sdk/gosdk/#22","text":"本示例展示应用链管理流程中的注册、审核以及注销操作。","text_tokens":["注册","流程","注销","操作","。","审核","中","本","以及","示例","应用","管理","链","的","、","展示"],"title":"2.2 应用链管理流程示例","title_tokens":["流程","示例","应用","管理","链","2.2"," "]},{"location":"sdk/gosdk/#221","text":"调用BVM合约的 Register 方法，向BitXHub注册应用链。 例如： args := [] * pb . Arg { rpcx . String ( \"\" ), //validators rpcx . Int32 ( 0 ), //consensus_type rpcx . String ( \"hyperchain\" ), //chain_type rpcx . String ( \"税务链\" ), //name rpcx . String ( \"趣链税务链\" ), //desc rpcx . String ( \"1.8\" ), //version } ret , err := cli . InvokeBVMContract ( constant . InterchainContractAddr . Address (), \"Register\" , nil , args ... ) 获取到成功的交易回执后，解析交易回执内容。 例如： { \"id\" : \"0x5098cc26b0d485145fb8258d2e79c49886cd4662\" , \\\\ 应用链ID \"name\" : \"税务链\" , \"validators\" : \"\" , \"consensus_type\" : 0 , \"status\" : 0 , \"chain_type\" : \"hyperchain\" , \"desc\" : \"趣链税务链\" , \"version\" : \"1.8\" }","text_tokens":["nil","注册",":",",","validators","arg","到","链","解析","args","\"","趣链","bitxhub","["," ","string","register","id","调用","rpcx","]","0","hyperchain","chain","cli","}","合约","constant",")","status","回执","invokebvmcontract",".","=","pb","desc","/","(","bvm","err","。","ret","获取","1.8","方法","的","后","version","int32","_","...","交易","税务","type","，","*","0x5098cc26b0d485145fb8258d2e79c49886cd4662","interchaincontractaddr","：","内容","向","例如","\\","应用","address","成功","consensus","name","{"],"title":"2.2.1 应用链注册","title_tokens":["注册","应用","链",".","2.2","1"," "]},{"location":"sdk/gosdk/#222","text":"调用BVM合约的 Aduit 方法，向BitXHub审核应用链。 例如： args := [] * pb . Arg { rpcx . String ( appchainID ), rpcx . Int32 ( 1 ), //审核通过 rpcx . String ( \"\" ), //desc } ret , err = cli . InvokeBVMContract ( constant . InterchainContractAddr . Address (), \"Aduit\" , nil , args ... )","text_tokens":["nil",":",",","arg","链","审核","args","1","\"","bitxhub","["," ","string","调用","rpcx","]","cli","}","合约","constant",")","通过","invokebvmcontract",".","=","pb","desc","appchainid","/","(","bvm","err","。","ret","方法","的","aduit","int32","...","，","*","interchaincontractaddr","：","向","例如","应用","address","{"],"title":"2.2.2 应用链审核","title_tokens":["2","应用","链","审核",".","2.2"," "]},{"location":"sdk/gosdk/#223","text":"调用BVM合约的 DeleteAppchain 方法，向BitXHub注销应用链。 例如： ret , err = cli . InvokeBVMContract ( constant . InterchainContractAddr . Address (), \"DeleteAppchain\" , nil , rpcx . String ( appchainID ))","text_tokens":["nil","deleteappchain",",","链","\"","bitxhub","string"," ","调用","rpcx","cli","合约","constant",")","invokebvmcontract",".","=","appchainid","(","bvm","err","。","ret","方法","的","，","注销","interchaincontractaddr","：","向","例如","应用","address"],"title":"2.2.3 应用链注销","title_tokens":["3","注销","应用","链",".","2.2"," "]},{"location":"sdk/gosdk/#23","text":"本示例展示验证规则中的注册、审核操作，以及WebAssembly合约示例。","text_tokens":["注册","验证","，","操作","。","合约","规则","本","中","以及","示例","的","审核","、","webassembly","展示"],"title":"2.3 验证规则使用示例","title_tokens":["验证","2.3","使用","规则","示例"," "]},{"location":"sdk/gosdk/#231","text":"调用BVM合约的 RegisterRule 方法，向应用链注册验证规则（WebAssembly合约），这里我们需要先注册应用链和部署验证规则合约，然后获取应用链ID和合约地址。 例如： ret , err = cli . InvokeBVMContract ( constant . RoleContractAddr . Address (), \"RegisterRule\" , nil , rpcx . String ( chainAddr ), rpcx . String ( contractAddr ))","text_tokens":["nil","注册",",","规则","registerrule","链","\"","部署","string"," ","id","调用","rpcx","cli","合约","constant",")","和","invokebvmcontract","webassembly",".","=","(","contractaddr","bvm","需要","我们","err","。","ret","方法","的","验证","，","（","chainaddr","rolecontractaddr","先","然后","向","地址","例如","：","应用","这里","address","）","获取"],"title":"2.3.1 验证规则注册","title_tokens":["注册","验证","2.3","规则",".","1"," "]},{"location":"sdk/gosdk/#232","text":"调用BVM合约的 Aduit 方法，向BitXHub审核验证规则。 例如： args := [] * pb . Arg { rpcx . String ( appchainID ), rpcx . Int32 ( 1 ), //审核通过 rpcx . String ( \"\" ), //desc } ret , err = cli . InvokeBVMContract ( constant . RuleManagerContractAddr . Address (), \"Aduit\" , nil , args ... )","text_tokens":["nil",":",",","规则","arg","1","审核","args","\"","bitxhub","["," ","string","调用","rpcx","]","cli","}","合约","constant",")","通过","invokebvmcontract",".","=","pb","desc","appchainid","/","(","bvm","err","。","ret","方法","的","aduit","rulemanagercontractaddr","int32","...","验证","，","*","：","向","例如","address","{"],"title":"2.3.2 验证规则审核","title_tokens":["验证","2.3","规则","2","审核","."," "]},{"location":"sdk/gosdk/#233-webassembly-fabric","text":"extern crate protobuf ; extern crate sha2 ; use crate :: crypto :: ecdsa ; use crate :: model :: transaction ; use sha2 :: { Digest , Sha256 }; pub fn verify ( proof : & [ u8 ], validator : & [ u8 ]) -> bool { let cap = protobuf :: parse_from_bytes :: < transaction :: ChaincodeActionPayload > ( proof ). expect ( \"error\" ); let cap_act = cap . action . unwrap (); let endorsers = cap_act . endorsements ; let mut digest = Sha256 :: new (); let mut payload = cap_act . proposal_response_payload . to_owned (); payload . extend ( & endorsers [ 0 ]. endorser ); digest . input ( & payload ); let digest_byte = digest . result (); return ecdsa :: verify ( & endorsers [ 0 ]. signature , & digest_byte , & validator , ecdsa :: EcdsaAlgorithmn :: P256 , ); }","text_tokens":["return","act","digest","unwrap",":","crypto",",","pub","response",">","action","-","extend","bool","\"","["," ","crate","0","]","}","to","bytes",")","from","use","sha256",".","&","=","endorser","mut","input","p256","(","extern","chaincodeactionpayload","payload","sha2","protobuf","verify","proof","validator","let","endorsers","model","byte","ecdsaalgorithmn","u8","_","expect","new","owned","fn","<","ecdsa","signature",";","cap","result","parse","endorsements","transaction","error","proposal","{"],"title":"2.3.3 验证规则示例（WebAssembly合约, Fabric实例）","title_tokens":["3","验证","2.3",",","（","合约","规则","fabric","实例","示例","webassembly",".","）"," "]},{"location":"sdk/gosdk/#3-sdk","text":"","text_tokens":[],"title":"3 SDK文档","title_tokens":["sdk","文档","3"," "]},{"location":"sdk/gosdk/#31","text":"","text_tokens":[],"title":"3.1 初始化和启动","title_tokens":["3.1","初始","和","初始化","启动"," "]},{"location":"sdk/gosdk/#311-client","text":"用途：调用该接口获取与中继链交互的Client。 参数： opts 是中继链的网络地址，日志以及密钥的配置。 func New ( opts ... Option ) ( * ChainClient , error )","text_tokens":["func","option",",","接口","以及","交互","client","网络地址","链","chainclient","配置","用途"," ","调用","该",")","网络","日志","opts","(","。","与","的","中继","new","...","密钥","，","*","：","地址","参数","是","error","获取"],"title":"3.1.1 初始化Client","title_tokens":["3.1","初始","client","初始化",".","1"," "]},{"location":"sdk/gosdk/#312-client","text":"用途：调用该接口将与中继链交互的 Client 关闭。 func Stop () error","text_tokens":["func","将","关闭","stop","接口","交互","client","链","用途"," ","调用",")","(","。","与","的","中继","：","error","该"],"title":"3.1.2 停止Client","title_tokens":["3.1","停止","client","2","."," "]},{"location":"sdk/gosdk/#32","text":"","text_tokens":[],"title":"3.2 交易接口","title_tokens":["接口","3.2","交易"," "]},{"location":"sdk/gosdk/#321","text":"用途：调用该接口向中继链发送交易，交易类型包括普通交易、跨链交易和智能合约。 参数： tx 交易实例。 opts 跨链交易nonce。 func SendTransaction ( tx * pb . Transaction , opts * TransactOpts ) ( string , error )","text_tokens":["func",",","接口","普通","链","发送","string","用途"," ","调用","nonce","合约",")","实例","和","跨链","、",".","pb","sendtransaction","opts","(","tx","包括","。","交易类型","中继","交易","类型","，","*","：","向","智能","参数","transaction","transactopts","error","该"],"title":"3.2.1 发送交易","title_tokens":["3.2","发送",".","交易","1"," "]},{"location":"sdk/gosdk/#322","text":"用途：调用该接口向BitXHub查询交易回执。 参数： hash 交易哈希。 func GetReceipt ( hash string ) ( * pb . Receipt , error ) 用例： func TestChainClient_SendTransactionWithReceipt ( t * testing . T ) { // 生成from私钥 privKey , _ := asym . GenerateKeyPair ( crypto . Secp256k1 ) // 生成to私钥 toPrivKey , _ := asym . GenerateKeyPair ( crypto . Secp256k1 ) // 配置Client cli , _ := New ( WithAddrs ( cfg . addrs ), WithLogger ( cfg . logger ), WithPrivateKey ( privKey ), ) // 获取from地址 from , _ := privKey . PublicKey (). Address () // 获取to地址 to , _ := toPrivKey . PublicKey (). Address () // 构建交易体 tx := & pb . Transaction { From : from , To : to , Data : & pb . TransactionData { Amount : 10 , }, Timestamp : time . Now (). UnixNano (), Nonce : rand . Int63 (), } // 用from的私钥签名交易 _ = tx . Sign ( privKey ) // 通过client发送交易 hash , _ := cli . SendTransaction ( tx , nil ) // 获取交易回执，判断交易执行状态 ret , _ := cli . GetReceipt ( hash ) require . Equal ( t , tx . Hash (). String (), ret . TxHash . String ()) // 停止client _ = cli . Stop () }","text_tokens":["time","cfg","用途","t","to","}","通过","data","(","receipt","now","new","_","timestamp","：","withlogger","用","error","address","获取","判断","publickey","asym",":","sign","生成","rand","testchainclient","签名","构建","from","回执","=","pb","/","withprivatekey","tx","unixnano","状态","。","停止","的","交易","参数","func","sendtransactionwithreceipt","nil","stop",",","接口","secp256k1","10","调用","withaddrs","nonce",")","哈希",".","&","sendtransaction","查询","equal","int63","hash","getreceipt","amount","私钥","require","toprivkey","*","transaction","crypto","client","发送","配置","string","bitxhub"," ","generatekeypair","cli","addrs","logger","用例","执行","txhash","ret","testing","privkey","，","transactiondata","向","地址","体","该","{"],"title":"3.2.2 查询交易回执","title_tokens":["3.2","查询","2","回执",".","交易"," "]},{"location":"sdk/gosdk/#323","text":"用途：调用该接口向BitXHub查询交易。 参数： hash 交易哈希。 func GetTransaction ( hash string ) ( * proto . GetTransactionResponse , error )","text_tokens":["func",",","接口","string","bitxhub","用途"," ","调用","proto",")","哈希",".","(","查询","。","hash","gettransaction","交易","*","gettransactionresponse","：","向","参数","error","该"],"title":"3.2.3 查询交易","title_tokens":["3.2","3","查询",".","交易"," "]},{"location":"sdk/gosdk/#33","text":"合约类型： BVM：BitXHub内置合约。 XVM：WebAssembly合约。","text_tokens":["类型","bvm","内置","。","合约","：","webassembly","xvm","bitxhub"," "],"title":"3.3 合约接口","title_tokens":["接口","合约","3.3"," "]},{"location":"sdk/gosdk/#331","text":"用途：调用该接口向BitXHub部署XVM合约，返回合约地址。 参数： contract wasm合约编译后的字节数据。 opts 跨链交易nonce。 func DeployContract ( contract [] byte , opts * TransactOpts ) ( contractAddr * types . Address , err error )","text_tokens":["func",",","编译","接口","contract","字节","xvm","部署","返回","bitxhub","用途"," ","[","调用","address","]","nonce","合约",")","跨链",".","opts","(","contractaddr","err","。","后","的","byte","交易","wasm","，","*","：","向","地址","参数","transactopts","error","deploycontract","types","该","数据"],"title":"3.3.1 部署合约","title_tokens":["合约",".","3.3","部署","1"," "]},{"location":"sdk/gosdk/#332","text":"用途：该接口向中继链调用合约获取交易回执。 参数： vmType 合约类型：BVM和XVM； address 合约地址； method 合约方法； opts 跨链交易nonce； args 合约方法参数。 func InvokeContract ( vmType pb . TransactionData_VMType , address types . Address , method string , opts * TransactOpts , args ...* pb . Arg ) ( * pb . Receipt , error ) 调用XVM合约用例： func TestChainClient_InvokeXVMContract ( t * testing . T ) { privKey , err := asym . GenerateKeyPair ( crypto . Secp256k1 ) require . Nil ( t , err ) cli , err := New ( WithAddrs ( cfg . addrs ), WithLogger ( cfg . logger ), WithPrivateKey ( privKey ), ) require . Nil ( t , err ) contract , err := ioutil . ReadFile ( \"./testdata/example.wasm\" ) require . Nil ( t , err ) addr , err := cli . DeployContract ( contract , nil ) require . Nil ( t , err ) result , err := cli . InvokeXVMContract ( addr , \"a\" , nil , Int32 ( 1 ), Int32 ( 2 )) require . Nil ( t , err ) require . Equal ( t , \"336\" , string ( result . Ret )) } 调用BVM合约用例： func TestChainClient_InvokeBVMContract ( t * testing . T ) { privKey , err := asym . GenerateKeyPair ( crypto . Secp256k1 ) require . Nil ( t , err ) cli , err := New ( WithAddrs ( cfg . addrs ), WithLogger ( cfg . logger ), WithPrivateKey ( privKey ), ) require . Nil ( t , err ) result , err := cli . InvokeBVMContract ( constant . StoreContractAddr . Address (), \"Set\" , nil , String ( \"a\" ), String ( \"10\" )) require . Nil ( t , err ) require . Nil ( t , result . Ret ) res , err := cli . InvokeBVMContract ( constant . StoreContractAddr . Address (), \"Get\" , nil , String ( \"a\" )) require . Nil ( t , err ) require . Equal ( t , string ( res . Ret ), \"10\" ) }","text_tokens":["336","arg","cfg","用途","get","t","；","}","合约","example","invokebvmcontract","(","receipt","中继","new","_","...","类型","：","withlogger","ioutil","error","readfile","address","invokexvmcontract","获取","asym",":","testchainclient","回执","=","pb","/","res","withprivatekey","。","set","invokecontract","交易","wasm","transactopts","参数","func","nil",",","接口","contract","secp256k1","链","\"","10","vmtype","调用","nonce","withaddrs",")",".","opts","err","addr","equal","int32","require","*","result","2","deploycontract","crypto","1","args","xvm","string","generatekeypair"," ","cli","constant","addrs","和","跨链","testdata","logger","用例","bvm","ret","method","testing","方法","privkey","a","storecontractaddr","transactiondata","向","地址","types","该","{"],"title":"3.3.2 调用合约","title_tokens":["调用","合约","2",".","3.3"," "]},{"location":"sdk/gosdk/#34","text":"","text_tokens":[],"title":"3.4 区块接口","title_tokens":["接口","区块","3.4"," "]},{"location":"sdk/gosdk/#341","text":"参数： value 区块高度或者区块哈希。 blockType 查询类型。 GetBlock ( value string , blockType pb . GetBlockRequest_Type ) ( * pb . Block , error )","text_tokens":["blocktype",",","getblockrequest","高度","string"," ","getblock",")","哈希",".","pb","区块","(","查询","。","value","_","类型","type","*","：","或者","参数","block","error"],"title":"3.4.1 查询区块","title_tokens":["查询","3.4",".","区块","1"," "]},{"location":"sdk/gosdk/#342","text":"用途：批量查询区块，返回指定块高度范围（start到end）的区块信息。 参数： start 指定范围的起始区块高度。 end 指定范围的结束区块高度。 func GetBlocks ( start uint64 , end uint64 ) ( * pb . GetBlocksResponse , error )","text_tokens":["func","start",",","高度","信息","到","返回","用途"," ","指定","getblocksresponse","起始","结束",")",".","区块","pb","(","查询","批量","。","的","uint64","块","getblocks","，","*","范围","（","：","参数","error","end","）"],"title":"3.4.2 批量查询区块","title_tokens":["批量","查询","3.4","2",".","区块"," "]},{"location":"sdk/gosdk/#343-meta","text":"用途：返回当前链的高度和区块哈希。 func GetChainMeta () ( * pb . ChainMeta , error )","text_tokens":["func",",","高度","链","返回","用途"," ","getchainmeta",")","和","哈希",".","pb","区块","chainmeta","(","。","当前","的","*","：","error"],"title":"3.4.3 查询区块Meta","title_tokens":["meta","3","查询","3.4",".","区块"," "]},{"location":"sdk/gosdk/#344","text":"用途：返回当前区块链共识的状态（正常或者不正常）。 func GetChainStatus () ( * pb . Response , error )","text_tokens":["func",",","response","getchainstatus","链","返回","用途"," ","不","正常",")",".","区块","pb","(","状态","。","当前","的","*","（","：","或者","error","共识","）"],"title":"3.4.4 查询区块链状态","title_tokens":["查询","状态","3.4","链",".","区块","4"," "]},{"location":"sdk/gosdk/#35","text":"","text_tokens":[],"title":"3.5 订阅接口","title_tokens":["接口","订阅","3.5"," "]},{"location":"sdk/gosdk/#351","text":"用途：调用该接口向中继链发起订阅事件的。 参数： type 事件类型，包含区块事件，区块头事件，跨链交易事件。 func Subscribe ( ctx context . Context , typ pb . SubscriptionRequest_Type , extra [] byte ) ( <- chan interface {}, error ) 用例： func TestChainClient_Subscribe ( t * testing . T ) { privKey , err := asym . GenerateKeyPair ( crypto . Secp256k1 ) require . Nil ( t , err ) from , err := privKey . PublicKey (). Address () require . Nil ( t , err ) cli , err := New ( WithAddrs ( cfg . addrs ), WithLogger ( cfg . logger ), WithPrivateKey ( privKey ), ) require . Nil ( t , err ) ctx , cancel := context . WithCancel ( context . Background ()) defer cancel () c , err := cli . Subscribe ( ctx , pb . SubscriptionRequest_BLOCK , nil ) assert . Nil ( t , err ) go func () { tx := & pb . Transaction { From : from , To : from , Timestamp : time . Now (). UnixNano (), Nonce : rand . Int63 (), } err = tx . Sign ( privKey ) require . Nil ( t , err ) hash , err := cli . SendTransaction ( tx , nil ) require . Nil ( t , err ) require . EqualValues ( t , 66 , len ( hash )) }() for { select { case block := <- c : if block == nil { assert . Error ( t , fmt . Errorf ( \"channel is closed\" )) return } if err := cli . Stop (); err != nil { return } return case <- ctx . Done (): return } } }","text_tokens":["time","包含","cfg","用途","[","select","]","t","!","}","to","事件","is","区块","(","now","中继","new","_","类型","type","timestamp","closed","：","withlogger","error","address","context","return","publickey","asym",":","errorf","sign","typ","rand","testchainclient","case","from","=","pb","if","withprivatekey","withcancel","tx","unixnano","66","chan","len","。","的","交易","<","参数","func","nil","c","stop",",","接口","for","secp256k1","链","\"","调用","background","withaddrs","nonce",")","done",".","&","sendtransaction","cancel","订阅","err","subscriptionrequest","int63","hash","头","byte","require","发起","interface","*",";","transaction","defer","block","crypto","fmt","go","-","equalvalues","generatekeypair"," ","ctx","cli","assert","addrs","跨链","subscribe","logger","用例","channel","testing","privkey","extra","，","向","该","{"],"title":"3.5.1 订阅事件","title_tokens":["订阅","事件",".","3.5","1"," "]},{"location":"sdk/gosdk/#352-merklewrapper","text":"用途：获取指定区块高度范围的MerkleWrapper 参数： pid 应用链ID。 begin 起始区块高度。 end 结束区块高度。 ch Merkle Wrapper的通道。 func GetInterchainTxWrappers ( ctx context . Context , pid string , begin , end uint64 , ch chan <- * pb . InterchainTxWrapper ) error","text_tokens":["pid","func","context",",","interchaintxwrapper","高度","wrapper","-","链","ch","string","用途"," ","指定","id","起始","begin","结束","ctx",")","merkle",".","区块","pb","(","chan","。","的","通道","uint64","getinterchaintxwrappers","<","*","范围","：","merklewrapper","参数","error","应用","end","获取"],"title":"3.5.2 获取MerkleWrapper","title_tokens":["merklewrapper","2",".","获取","3.5"," "]},{"location":"sdk/gosdk/#36","text":"","text_tokens":[],"title":"3.6 其它接口","title_tokens":["3.6","接口","其它"," "]},{"location":"sdk/gosdk/#361","text":"用途：返回当前区块链网络的节点信息。 func GetNetworkMeta () ( * pb . Response , error )","text_tokens":["func",",","response","信息","链","返回","用途"," ","getnetworkmeta",")","节点","网络",".","pb","区块","(","。","当前","的","*","：","error"],"title":"3.6.1 查询节点网络信息","title_tokens":["查询","3.6","节点","信息","网络",".","1"," "]},{"location":"sdk/gosdk/#362","text":"参数： address 地址。 func GetAccountBalance ( address string ) ( * pb . Response , error )","text_tokens":["func","(","*",",","。","response","：",")","地址","参数","getaccountbalance","error","address",".","pb","string"," "],"title":"3.6.2 查询账户余额","title_tokens":["余额","查询","账户","3.6","2","."," "]},{"location":"sdk/gosdk/#363","text":"用途：删除区块链网络中的节点（须往f+1个节点发送请求才可以删除） 参数： pid 节点的pid func DelVPNode ( pid string ) ( * pb . Response , error )","text_tokens":["pid","func",",","response","删除","须往","链","发送","string","用途"," ","+",")","节点","可以","网络","delvpnode",".","区块","pb","(","请求","的","个","*","才","（","：","中","f","参数","error","）","1"],"title":"3.6.3 删除节点","title_tokens":["3","删除","3.6","节点","."," "]},{"location":"sdk/javasdk/","text":"Java SDK 1 前言 此SDK文档面向BitXHub平台的应用开发者，提供BitXHub Java SDK的使用指南。 2 接口使用流程示例 2.1 基础流程示例 为了更好的理解接口的使用，本示例将从初始化Client，部署合约，调用合约和返回值解析这个大致流程作介绍，具体详细接口可参考第三章SDK文档。 2.1.1 初始化Client 使用默认的配置类初始化Grpc Client。 例如： GrpcClient client = new GrpcClientImpl ( Config . defaultConfig ()); 使用定制化的配置类初始化Grpc Client。 例如： Config config = Config . builder () . host ( \"localhost\" ) . port ( 60011 ) . ecKey ( new ECKeyP256 ()) . build (); GrpcClient client = new GrpcClientImpl ( config ); 2.1.2 部署合约 开发者需提供已经编译的 WebAssembly 文件。 例如： byte [] contractBytes = IOUtils . toByteArray ( new FileInputStream ( \"./example.wasm\" )); 通过client部署合约，部署完成后可以获取合约地址 contractAddress 。 例如： String contractAddress = client . deployContract ( contractBytes ); 2.1.3 调用合约 调用合约需传入合约地址、合约方法名和对应的参数。 例如： ReceiptOuterClass . Receipt receipt = client . invokeXVMContract ( contractAddress , \"a\" , Types . i32 ( 1 ), Types . i32 ( 1 )); \\\\ 方法名为a ， 传参1 ， 传参2 2.1.4 返回值解析 得到返回值结果后，获得状态码可以判断是否调用成功，若调用成功，解析返回值可看到调用之后的结果。 例如： if ( receipt . getStatus () == ReceiptOuterClass . Receipt . Status . SUCCESS ) { log . info ( receipt . getRet (). toStringUtf8 ()); } 2.1.5 完整示例 //获取wasm字节数组 byte [] contractBytes = IOUtils . toByteArray ( new FileInputStream ( \"./example.wasm\" )); //部署合约，获取合约地址 String contractAddress = client . deployContract ( contractBytes ); //调用合约，获取交易回执 ReceiptOuterClass . Receipt receipt = client . invokeXVMContract ( contractAddress , \"a\" , Types . i32 ( 1 ), Types . i32 ( 1 )); //判断合约调用交易成功与否，打印合约调用数据 if ( receipt . getStatus () == ReceiptOuterClass . Receipt . Status . SUCCESS ) { log . info ( receipt . getRet (). toStringUtf8 ()); } 2.2 应用链管理流程示例 本示例展示应用链管理流程中的注册、审核以及注销操作。 2.2.1 应用链注册 调用BVM合约的 Register 方法，向BitXHub注册应用链。 例如： ArgOuterClass . Arg [] args = Types . toArgArray ( Types . string ( \"\" ), //validators Types . i32 ( 0 ), //consensus_type Types . string ( \"hyperchain\" ), //chain_type Types . string ( \"税务链\" ), //name Types . string ( \"趣链税务链\" ), //desc Types . string ( \"1.8\" )); //version Types . string ( \"\" )); //public key ReceiptOuterClass . Receipt receipt = client . invokeBVMContract ( BVMAddr . APPCHAIN_MANAGER_CONTRACT_ADDR , \"Register\" , args ); 获取到成功的交易回执后，解析交易回执内容。 例如： { \"id\" : \"0x5098cc26b0d485145fb8258d2e79c49886cd4662\" , \\\\ 应用链ID \"name\" : \"税务链\" , \"validators\" : \"\" , \"consensus_type\" : 0 , \"status\" : 0 , \"chain_type\" : \"hyperchain\" , \"desc\" : \"趣链税务链\" , \"version\" : \"1.8\" , \"public_key\" : \"\" } 2.2.2 应用链审核 调用BVM合约的 Audit 方法，向BitXHub审核应用链。 例如： ArgOuterClass . Arg [] adultArgs = Types . toArgArray ( Types . string ( appchainID ), //应用链ID Types . i32 ( 1 ), //审核通过 Types . string ( \"\" )); //描述信息 ReceiptOuterClass . Receipt adultReceipt = client . invokeBVMContract ( BVMAddr . APPCHAIN_MANAGER_CONTRACT_ADDR , \"Audit\" , adultArgs ); 2.2.3 应用链注销 调用BVM合约的 DeleteAppchain 方法，向BitXHub注销应用链。 例如： ArgOuterClass . Arg [] deleteArgs = Types . toArgArray ( Types . string ( appchainID ); //应用链ID ReceiptOuterClass . Receipt deleteReceipt = client . invokeBVMContract ( BVMAddr . APPCHAIN_MANAGER_CONTRACT_ADDR , \"DeleteAppchain\" , deleteArgs ); 2.3 验证规则使用示例 本示例展示验证规则中的注册、审核操作，以及WebAssembly合约示例。 2.3.1 验证规则注册 调用BVM合约的 RegisterRule 方法，向应用链注册验证规则（WebAssembly合约），这里我们需要先注册应用链和部署验证规则合约，然后获取应用链ID和合约地址。 例如： ArgOuterClass . Arg [] ruleArgs = Types . toArgArray ( Types . string ( appchainID ), Types . string ( contractAddress )); ReceiptOuterClass . Receipt ruleReceipt = client . invokeBVMContract ( BVMAddr . RULE_MANAGER_CONTRACT_ADDR , \"RegisterRule\" , ruleArgs ); 2.3.2 验证规则审核 调用BVM合约的 Audit 方法，向BitXHub审核验证规则。 例如： ArgOuterClass . Arg [] adultArgs = Types . toArgArray ( Types . string ( contractAddress ), //验证规则的合约地址 Types . i32 ( 1 ), //审核通过 Types . string ( \"\" )); //描述信息 ReceiptOuterClass . Receipt adultReceipt = client . invokeBVMContract ( BVMAddr . RULE_MANAGER_CONTRACT_ADDR , \"Audit\" , adultArgs ); 2.3.3 验证规则示例（WebAssembly合约, Fabric实例） extern crate protobuf ; extern crate sha2 ; use crate :: crypto :: ecdsa ; use crate :: model :: transaction ; use sha2 :: { Digest , Sha256 }; pub fn verify ( proof : & [ u8 ], validator : & [ u8 ]) -> bool { let cap = protobuf :: parse_from_bytes :: < transaction :: ChaincodeActionPayload > ( proof ). expect ( \"error\" ); let cap_act = cap . action . unwrap (); let endorsers = cap_act . endorsements ; let mut digest = Sha256 :: new (); let mut payload = cap_act . proposal_response_payload . to_owned (); payload . extend ( & endorsers [ 0 ]. endorser ); digest . input ( & payload ); let digest_byte = digest . result (); return ecdsa :: verify ( & endorsers [ 0 ]. signature , & digest_byte , & validator , ecdsa :: EcdsaAlgorithmn :: P256 , ); } 3 SDK文档 3.1 初始化 3.1.1 初始化Client 用途：调用该接口获取与BitXHub交互的Client。 GrpcClient client = new GrpcClientImpl ( Config . defaultConfig ()); 入参： Config 是BitXHub的网络地址, 端口以及密钥的配置。 返回值：与BitXHub交互的 Client 。 3.1.2 停止Client 用途：调用该接口将与BitXHub交互的 Client 关闭。 public void stop () throws InterruptedException 3.2 交易接口 3.2.1 发送交易 用途：调用该接口向BitXHub发送交易，交易类型包括普通交易、跨链交易和智能合约交易。 参数： transaction 交易。 opts 跨链交易nonce。 public String sendTransaction ( TransactionOuterClass . Transaction transaction , TransactOpts opts ); 用例： public void sendTransaction () { TransactionOuterClass . Transaction unsignedTx = TransactionOuterClass . Transaction . newBuilder () . setFrom ( ByteString . copyFrom ( from )) . setTo ( ByteString . copyFrom ( to )) . setTimestamp ( Utils . genTimestamp ()) . setPayload ( TransactionOuterClass . TransactionData . newBuilder (). setAmount ( 100000L ). build (). toByteString ()) . build (); TransactionOuterClass . Transaction signedTx = SignUtils . sign ( unsignedTx , config . getEcKey ()); String txHash = client . sendTransaction ( signedTx , null ); } 3.2.2 查询交易回执 参数： hash 交易哈希。 ReceiptOuterClass . Receipt getReceipt ( String hash ); 3.2.3 查询交易 参数： hash 交易哈希。 Broker . GetTransactionResponse getTransaction ( String hash ); 3.3 合约接口 合约类型： BVM：BitXHub内置合约 XVM：WebAssembly合约 3.3.1 部署合约 用途：调用该接口向BitXHub部署XVM合约。 参数： contract 合约数据。 String deployContract ( byte [] contract ); 3.3.2 调用合约 用途：调用该接口向BitXHub调用BVM或者XVM合约。 参数： vmType 合约类型：BVM和XVM。 contractAddress 合约地址。 method 合约方法； args 合约方法参数。 ReceiptOuterClass . Receipt invokeContract ( TransactionOuterClass . TransactionData . VMType vmType , String contractAddress , String method , ArgOuterClass . Arg ... args ); 用例： public void invokeContract () throws IOException { byte [] contractBytes = IOUtils . toByteArray ( new FileInputStream ( \"./example.wasm\" )); String contractAddress = client . deployContract ( contractBytes ); ReceiptOuterClass . Receipt receipt = client . invokeContract ( TransactionOuterClass . TransactionData . VMType . XVM , contractAddress , \"a\" , Types . i32 ( 1 ), Types . i32 ( 1 )); } 3.4 区块接口 3.4.1 查询区块 参数： value 区块高度或者区块哈希。 type 查询类型。 type类型 。 BlockOuterClass . Block getBlock ( String value , Broker . GetBlockRequest . Type type ); 3.4.2 批量查询区块 用途：批量查询区块，返回指定块高度范围（start到end）的区块信息。 参数： start 指定范围的起始区块高度。 end 指定范围的结束区块高度。 Broker . GetBlocksResponse getBlocks ( Long start , Long end ); 3.4.3 查询区块Meta 用途：返回当前链的高度和区块哈希。 Chain . ChainMeta getChainMeta (); 3.4.4 查询区块链状态 用途：返回当前区块链共识的状态（正常或者不正常）。 Broker . Response getChainStatus (); 3.5 订阅接口 3.5.1 订阅事件 用途：调用该接口向BitXHub发起订阅事件。 参数： streamObserver 事件通道。 type 事件类型。 用例： void subscribe ( Broker . SubscriptionRequest . Type type , StreamObserver < Broker . Response > observer ); public void subscribe () throws InterruptedException { CountDownLatch asyncLatch = new CountDownLatch ( 1 ); StreamObserver < Broker . Response > observer = new StreamObserver < Broker . Response > () { @Override public void onNext ( Broker . Response response ) { ByteString data = response . getData (); BlockOuterClass . Block block = null ; try { block = BlockOuterClass . Block . parseFrom ( data ); } catch ( InvalidProtocolBufferException e ) { e . printStackTrace (); } } @Override public void onError ( Throwable throwable ) { throwable . printStackTrace (); asyncLatch . countDown (); } @Override public void onCompleted () { asyncLatch . countDown (); } }; client . subscribe ( Broker . SubscriptionRequest . Type . BLOCK , observer ); asyncLatch . await (); } 3.6 其它接口 3.6.1 查询节点网络信息 用途：返回当前区块链网络的节点信息。 Broker . Response getNetworkMeta (); 3.6.2 查询账户余额 参数： address 地址。 Broker . Response getAccountBalance ( String address );","text_tokens":["2.3","普通","信息","throwable","端口","不","argouterclass","合约","utils","区块","new","_","settimestamp","需","rule","理解","return","操作","adultreceipt","趣链","log","回执","void","=","blockouterclass","onerror","。","停止","可","wasm","入参","ecdsa","默认","或者","例如","asynclatch","digest","关闭","类","编译","接口",",","countdown","字节","完成","返回","receiptouterclass","webassembly","p256","sendtransaction","tobytestring","setto","开发","ecdsaalgorithmn","发起",";","中","block","eckeyp256","deleteappchain","start","unwrap","以及","validators","client","-","signedtx","xvm","bitxhub","string"," ","3","起始","和","sha256","之后","subscribe","key","名为","2.2","密钥","注销","interruptedexception","（","gettransactionresponse","管理","newbuilder","若","账户","getdata","broker","getchainstatus","2.1","到","registerrule","使用指南","sdk","部署","[","toargarray","register","流程","getaccountbalance","data","endorser","批量","其它","文档","contractbytes","let","signature","：","定制","是","这里","gentimestamp","成功",":","sign","规则","action","第三","geteckey","指定","ioutils","0","指南","from","sha2","3.4","后","的","与","交易","unsignedtx","余额","对应","cap","为了","使用","先","end","name","signutils","stop","audit","response",">","info","调用","返回值","await","nonce","内置","本","哈希","appchainid","mut","包括","传参","获得","当前","subscriptionrequest","endorsers","config","范围","内容","deploycontract","crypto","try","getblockrequest","streamobserver","解析","配置","getblocksresponse","bytes","grpc","override","deleteargs","getret","method","proof","方法","validator","oncompleted","这个","long","a","3.1","然后","向","地址","初始化","consensus","1","前言","arg","用途","id","to","事件","具体","desc","chainmeta","是否","verify","contractaddress","version","作","expect","类型","fn","ioexception","验证","3.5","endorsements","bvmaddr","error","共识","address","countdownlatch","invokexvmcontract","获取","）","判断","public","网络地址","getchainmeta","描述","码","/","面向","host","化","状态","invokecontract","通道","setpayload","value","展示","owned","传入","invalidprotocolbufferexception","act","介绍","appchain","已经","parsefrom","extend","链","bool","\"","看到",")","实例","status","文件","&","catch","opts","订阅","查询","onnext","deletereceipt","hash","getreceipt","提供","byte","基础","gettransaction","adultargs","e","result","getstatus","注册","printstacktrace","args","发送","4","tostringutf8","defaultconfig","chain","结束","可以","3.6","input","用例","bvm","需要","success","txhash","打印","manager","三章","transactionouterclass","transactiondata","得到","参考","应用","types","ruleargs","observer","throws","示例","eckey","crate","]","；","}","第三章","example","通过","invokebvmcontract","(","extern","chaincodeactionpayload","receipt","1.8","完整","5","...","type","getblocks","详细","proposal","将","高度","3.2","与否","getblock","节点","use","port","结果","rulereceipt","if","localhost","payload","交易类型","bytestring","model","@","税务","<","智能","transactopts","fileinputstream","参数","从","pub","名","contract","审核","vmtype","getnetworkmeta","fabric",".","null","3.3","build","meta","addr","protobuf","copyfrom","块","平台","parse","setfrom","transaction","2","\\","i32","setamount","grpcclient","数组","交互","tobytearray","大致","hyperchain","java","正常","跨链","grpcclientimpl","网络","此","更好","、","builder","初始","我们","60011","u8","100000l","，","0x5098cc26b0d485145fb8258d2e79c49886cd4662","开发者","该","{","数据"],"title":"JavaSDK使用","title_tokens":["javasdk","使用"]},{"location":"sdk/javasdk/#java-sdk","text":"","text_tokens":[],"title":"Java SDK","title_tokens":["sdk","java"," "]},{"location":"sdk/javasdk/#1","text":"此SDK文档面向BitXHub平台的应用开发者，提供BitXHub Java SDK的使用指南。","text_tokens":["，","平台","指南"," ","。","java","使用","文档","的","应用","使用指南","提供","此","开发","开发者","sdk","bitxhub","面向"],"title":"1 前言","title_tokens":["前言","1"," "]},{"location":"sdk/javasdk/#2","text":"","text_tokens":[],"title":"2 接口使用流程示例","title_tokens":["流程","接口","使用","2","示例"," "]},{"location":"sdk/javasdk/#21","text":"为了更好的理解接口的使用，本示例将从初始化Client，部署合约，调用合约和返回值解析这个大致流程作介绍，具体详细接口可参考第三章SDK文档。","text_tokens":["将","介绍","接口","client","示例","第三","解析","sdk","部署","返回","大致","调用","流程","返回值","合约","第三章","本","和","具体","更好","初始","。","文档","的","这个","可","三章","作","，","为了","使用","详细","参考","初始化","从","理解"],"title":"2.1 基础流程示例","title_tokens":["流程","示例","2.1","基础"," "]},{"location":"sdk/javasdk/#211-client","text":"使用默认的配置类初始化Grpc Client。 例如： GrpcClient client = new GrpcClientImpl ( Config . defaultConfig ()); 使用定制化的配置类初始化Grpc Client。 例如： Config config = Config . builder () . host ( \"localhost\" ) . port ( 60011 ) . ecKey ( new ECKeyP256 ()) . build (); GrpcClient client = new GrpcClientImpl ( config );","text_tokens":["eckeyp256","类","grpcclient","client","配置","\"","eckey"," ","defaultconfig",")","grpcclientimpl","port",".","=","grpc","localhost","build","builder","(","host","初始","化","。","的","60011","new","config",";","默认","使用","：","例如","定制","初始化"],"title":"2.1.1 初始化Client","title_tokens":["初始","client","2.1","初始化",".","1"," "]},{"location":"sdk/javasdk/#212","text":"开发者需提供已经编译的 WebAssembly 文件。 例如： byte [] contractBytes = IOUtils . toByteArray ( new FileInputStream ( \"./example.wasm\" )); 通过client部署合约，部署完成后可以获取合约地址 contractAddress 。 例如： String contractAddress = client . deployContract ( contractBytes );","text_tokens":["已经","编译","client","完成","\"","部署","["," ","tobytearray","ioutils","string","]","合约","example",")","可以","通过","webassembly",".","文件","=","/","(","。","后","的","contractbytes","提供","byte","开发","contractaddress","new","wasm","，",";","：","例如","地址","需","fileinputstream","deploycontract","开发者","获取"],"title":"2.1.2 部署合约","title_tokens":["合约","2","2.1",".","部署"," "]},{"location":"sdk/javasdk/#213","text":"调用合约需传入合约地址、合约方法名和对应的参数。 例如： ReceiptOuterClass . Receipt receipt = client . invokeXVMContract ( contractAddress , \"a\" , Types . i32 ( 1 ), Types . i32 ( 1 )); \\\\ 方法名为a ， 传参1 ， 传参2","text_tokens":[",","名","client","1","\""," ","调用","合约","receiptouterclass",")","和",".","、","=","(","。","receipt","传参","方法","的","名为","contractaddress","a","，","对应","传入",";","：","例如","地址","需","参数","\\","2","types","invokexvmcontract","i32"],"title":"2.1.3 调用合约","title_tokens":["调用","3","合约","2.1","."," "]},{"location":"sdk/javasdk/#214","text":"得到返回值结果后，获得状态码可以判断是否调用成功，若调用成功，解析返回值可看到调用之后的结果。 例如： if ( receipt . getStatus () == ReceiptOuterClass . Receipt . Status . SUCCESS ) { log . info ( receipt . getRet (). toStringUtf8 ()); }","text_tokens":["info","解析","返回"," ","调用","tostringutf8","看到","返回值","}",")","可以","receiptouterclass","status","log","之后","结果",".","=","码","if","(","状态","。","success","getret","是否","receipt","获得","后","的","可","，",";","得到","：","例如","getstatus","成功","若","{","判断"],"title":"2.1.4 返回值解析","title_tokens":["返回值","2.1","解析",".","4","返回"," "]},{"location":"sdk/javasdk/#215","text":"//获取wasm字节数组 byte [] contractBytes = IOUtils . toByteArray ( new FileInputStream ( \"./example.wasm\" )); //部署合约，获取合约地址 String contractAddress = client . deployContract ( contractBytes ); //调用合约，获取交易回执 ReceiptOuterClass . Receipt receipt = client . invokeXVMContract ( contractAddress , \"a\" , Types . i32 ( 1 ), Types . i32 ( 1 )); //判断合约调用交易成功与否，打印合约调用数据 if ( receipt . getStatus () == ReceiptOuterClass . Receipt . Status . SUCCESS ) { log . info ( receipt . getRet (). toStringUtf8 ()); }","text_tokens":[",","数组","client","字节","info","1","\"","部署","[","tobytearray"," ","ioutils","string","调用","tostringutf8","]","与否","}","合约","example",")","receiptouterclass","log","status","回执","{","数据",".","=","if","/","(","success","getret","打印","receipt","contractbytes","byte","contractaddress","a","new","交易","wasm","，",";","地址","fileinputstream","getstatus","deploycontract","types","成功","invokexvmcontract","获取","i32","判断"],"title":"2.1.5 完整示例","title_tokens":["2.1","示例",".","完整","5"," "]},{"location":"sdk/javasdk/#22","text":"本示例展示应用链管理流程中的注册、审核以及注销操作。","text_tokens":["注册","流程","注销","操作","。","审核","中","本","以及","示例","应用","管理","链","的","、","展示"],"title":"2.2 应用链管理流程示例","title_tokens":["流程","示例","应用","管理","链","2.2"," "]},{"location":"sdk/javasdk/#221","text":"调用BVM合约的 Register 方法，向BitXHub注册应用链。 例如： ArgOuterClass . Arg [] args = Types . toArgArray ( Types . string ( \"\" ), //validators Types . i32 ( 0 ), //consensus_type Types . string ( \"hyperchain\" ), //chain_type Types . string ( \"税务链\" ), //name Types . string ( \"趣链税务链\" ), //desc Types . string ( \"1.8\" )); //version Types . string ( \"\" )); //public key ReceiptOuterClass . Receipt receipt = client . invokeBVMContract ( BVMAddr . APPCHAIN_MANAGER_CONTRACT_ADDR , \"Register\" , args ); 获取到成功的交易回执后，解析交易回执内容。 例如： { \"id\" : \"0x5098cc26b0d485145fb8258d2e79c49886cd4662\" , \\\\ 应用链ID \"name\" : \"税务链\" , \"validators\" : \"\" , \"consensus_type\" : 0 , \"status\" : 0 , \"chain_type\" : \"hyperchain\" , \"desc\" : \"趣链税务链\" , \"version\" : \"1.8\" , \"public_key\" : \"\" }","text_tokens":["注册","public","appchain",":",",","validators","client","arg","contract","到","链","解析","args","\"","趣链","bitxhub","["," ","toargarray","register","string","调用","0","]","hyperchain","chain","id","argouterclass","}","合约",")","receiptouterclass","status","回执","invokebvmcontract","{",".","=","desc","/","(","bvm","。","addr","receipt","key","获取","1.8","方法","的","后","manager","version","_","交易","税务","type","，",";","0x5098cc26b0d485145fb8258d2e79c49886cd4662","：","内容","向","例如","\\","bvmaddr","应用","types","成功","consensus","name","i32"],"title":"2.2.1 应用链注册","title_tokens":["注册","应用","链",".","2.2","1"," "]},{"location":"sdk/javasdk/#222","text":"调用BVM合约的 Audit 方法，向BitXHub审核应用链。 例如： ArgOuterClass . Arg [] adultArgs = Types . toArgArray ( Types . string ( appchainID ), //应用链ID Types . i32 ( 1 ), //审核通过 Types . string ( \"\" )); //描述信息 ReceiptOuterClass . Receipt adultReceipt = client . invokeBVMContract ( BVMAddr . APPCHAIN_MANAGER_CONTRACT_ADDR , \"Audit\" , adultArgs );","text_tokens":["appchain",",","audit","client","arg","信息","contract","链","审核","1","adultreceipt","\"","bitxhub","["," ","toargarray","string","id","调用","]","argouterclass","合约","描述",")","receiptouterclass","通过","invokebvmcontract",".","=","appchainid","/","(","bvm","。","addr","receipt","方法","的","manager","adultargs","_","，",";","：","向","例如","bvmaddr","应用","types","i32"],"title":"2.2.2 应用链审核","title_tokens":["2","应用","链","审核",".","2.2"," "]},{"location":"sdk/javasdk/#223","text":"调用BVM合约的 DeleteAppchain 方法，向BitXHub注销应用链。 例如： ArgOuterClass . Arg [] deleteArgs = Types . toArgArray ( Types . string ( appchainID ); //应用链ID ReceiptOuterClass . Receipt deleteReceipt = client . invokeBVMContract ( BVMAddr . APPCHAIN_MANAGER_CONTRACT_ADDR , \"DeleteAppchain\" , deleteArgs );","text_tokens":["deleteappchain","appchain",",","client","arg","contract","链","\"","bitxhub","["," ","toargarray","string","id","调用","]","argouterclass","合约",")","receiptouterclass","invokebvmcontract",".","=","appchainid","/","(","bvm","deleteargs","。","addr","receipt","方法","的","deletereceipt","manager","_","，","注销",";","：","向","例如","bvmaddr","应用","types"],"title":"2.2.3 应用链注销","title_tokens":["3","注销","应用","链",".","2.2"," "]},{"location":"sdk/javasdk/#23","text":"本示例展示验证规则中的注册、审核操作，以及WebAssembly合约示例。","text_tokens":["注册","验证","，","操作","。","合约","规则","本","中","以及","示例","的","审核","、","webassembly","展示"],"title":"2.3 验证规则使用示例","title_tokens":["验证","2.3","使用","规则","示例"," "]},{"location":"sdk/javasdk/#231","text":"调用BVM合约的 RegisterRule 方法，向应用链注册验证规则（WebAssembly合约），这里我们需要先注册应用链和部署验证规则合约，然后获取应用链ID和合约地址。 例如： ArgOuterClass . Arg [] ruleArgs = Types . toArgArray ( Types . string ( appchainID ), Types . string ( contractAddress )); ReceiptOuterClass . Receipt ruleReceipt = client . invokeBVMContract ( BVMAddr . RULE_MANAGER_CONTRACT_ADDR , \"RegisterRule\" , ruleArgs );","text_tokens":["注册",",","规则","client","arg","contract","registerrule","链","\"","部署","["," ","toargarray","id","string","调用","]","argouterclass","合约",")","receiptouterclass","和","invokebvmcontract","webassembly",".","=","rulereceipt","appchainid","(","bvm","需要","我们","。","addr","receipt","方法","的","manager","contractaddress","_","验证","，",";","（","先","然后","向","地址","例如","：","bvmaddr","应用","这里","rule","types","）","获取","ruleargs"],"title":"2.3.1 验证规则注册","title_tokens":["注册","验证","2.3","规则",".","1"," "]},{"location":"sdk/javasdk/#232","text":"调用BVM合约的 Audit 方法，向BitXHub审核验证规则。 例如： ArgOuterClass . Arg [] adultArgs = Types . toArgArray ( Types . string ( contractAddress ), //验证规则的合约地址 Types . i32 ( 1 ), //审核通过 Types . string ( \"\" )); //描述信息 ReceiptOuterClass . Receipt adultReceipt = client . invokeBVMContract ( BVMAddr . RULE_MANAGER_CONTRACT_ADDR , \"Audit\" , adultArgs );","text_tokens":[",","audit","规则","client","arg","信息","contract","1","审核","adultreceipt","\"","bitxhub","["," ","toargarray","string","调用","]","argouterclass","合约","描述",")","receiptouterclass","通过","invokebvmcontract",".","=","/","(","bvm","。","addr","receipt","方法","的","manager","contractaddress","adultargs","_","验证","，",";","：","向","例如","地址","bvmaddr","rule","types","i32"],"title":"2.3.2 验证规则审核","title_tokens":["验证","2.3","规则","2","审核","."," "]},{"location":"sdk/javasdk/#233-webassembly-fabric","text":"extern crate protobuf ; extern crate sha2 ; use crate :: crypto :: ecdsa ; use crate :: model :: transaction ; use sha2 :: { Digest , Sha256 }; pub fn verify ( proof : & [ u8 ], validator : & [ u8 ]) -> bool { let cap = protobuf :: parse_from_bytes :: < transaction :: ChaincodeActionPayload > ( proof ). expect ( \"error\" ); let cap_act = cap . action . unwrap (); let endorsers = cap_act . endorsements ; let mut digest = Sha256 :: new (); let mut payload = cap_act . proposal_response_payload . to_owned (); payload . extend ( & endorsers [ 0 ]. endorser ); digest . input ( & payload ); let digest_byte = digest . result (); return ecdsa :: verify ( & endorsers [ 0 ]. signature , & digest_byte , & validator , ecdsa :: EcdsaAlgorithmn :: P256 , ); }","text_tokens":["return","act","digest","unwrap",":","crypto",",","pub","response",">","action","-","extend","bool","\"","["," ","crate","0","]","}","to","bytes",")","from","use","sha256",".","&","=","endorser","mut","input","p256","(","extern","chaincodeactionpayload","payload","sha2","protobuf","verify","proof","validator","let","endorsers","model","byte","ecdsaalgorithmn","u8","_","expect","new","owned","fn","<","ecdsa","signature",";","cap","result","parse","endorsements","transaction","error","proposal","{"],"title":"2.3.3 验证规则示例（WebAssembly合约, Fabric实例）","title_tokens":["3","验证","2.3",",","（","合约","规则","fabric","实例","示例","webassembly",".","）"," "]},{"location":"sdk/javasdk/#3-sdk","text":"","text_tokens":[],"title":"3 SDK文档","title_tokens":["sdk","文档","3"," "]},{"location":"sdk/javasdk/#31","text":"","text_tokens":[],"title":"3.1 初始化","title_tokens":["3.1","初始","初始化"," "]},{"location":"sdk/javasdk/#311-client","text":"用途：调用该接口获取与BitXHub交互的Client。 GrpcClient client = new GrpcClientImpl ( Config . defaultConfig ()); 入参： Config 是BitXHub的网络地址, 端口以及密钥的配置。 返回值：与BitXHub交互的 Client 。","text_tokens":[",","接口","grpcclient","以及","交互","client","网络地址","端口","配置","bitxhub","用途"," ","返回","调用","defaultconfig","返回值","该",")","grpcclientimpl","网络",".","=","(","。","与","的","new","config","入参","密钥",";","：","是","地址","获取"],"title":"3.1.1 初始化Client","title_tokens":["3.1","初始","client","初始化",".","1"," "]},{"location":"sdk/javasdk/#312-client","text":"用途：调用该接口将与BitXHub交互的 Client 关闭。 public void stop () throws InterruptedException","text_tokens":["将","关闭","public","stop","接口","throws","交互","client","bitxhub","用途"," ","调用",")","void","(","。","与","的","interruptedexception","：","该"],"title":"3.1.2 停止Client","title_tokens":["3.1","停止","client","2","."," "]},{"location":"sdk/javasdk/#32","text":"","text_tokens":[],"title":"3.2 交易接口","title_tokens":["接口","3.2","交易"," "]},{"location":"sdk/javasdk/#321","text":"用途：调用该接口向BitXHub发送交易，交易类型包括普通交易、跨链交易和智能合约交易。 参数： transaction 交易。 opts 跨链交易nonce。 public String sendTransaction ( TransactionOuterClass . Transaction transaction , TransactOpts opts ); 用例： public void sendTransaction () { TransactionOuterClass . Transaction unsignedTx = TransactionOuterClass . Transaction . newBuilder () . setFrom ( ByteString . copyFrom ( from )) . setTo ( ByteString . copyFrom ( to )) . setTimestamp ( Utils . genTimestamp ()) . setPayload ( TransactionOuterClass . TransactionData . newBuilder (). setAmount ( 100000L ). build (). toByteString ()) . build (); TransactionOuterClass . Transaction signedTx = SignUtils . sign ( unsignedTx , config . getEcKey ()); String txHash = client . sendTransaction ( signedTx , null ); }","text_tokens":["setamount","signutils","public",",","接口","sign","普通","client","signedtx","发送","bitxhub","用途"," ","string","geteckey","调用","nonce","to","合约","}",")","from","和","跨链","utils","、",".","void","=","null","build","sendtransaction","opts","(","用例","tobytestring","包括","setto","。","txhash","交易类型","bytestring","copyfrom","setpayload","交易","config","unsignedtx","类型","transactionouterclass","settimestamp","100000l","，","transactiondata",";","：","setfrom","向","智能","参数","transaction","transactopts","gentimestamp","newbuilder","该","{"],"title":"3.2.1 发送交易","title_tokens":["3.2","发送",".","交易","1"," "]},{"location":"sdk/javasdk/#322","text":"参数： hash 交易哈希。 ReceiptOuterClass . Receipt getReceipt ( String hash );","text_tokens":["(",";","。","：","receipt","receiptouterclass",")","参数","hash","哈希","getreceipt",".","交易","string"," "],"title":"3.2.2 查询交易回执","title_tokens":["3.2","查询","2","回执",".","交易"," "]},{"location":"sdk/javasdk/#323","text":"参数： hash 交易哈希。 Broker . GetTransactionResponse getTransaction ( String hash );","text_tokens":["(","broker","gettransaction",";","。","gettransactionresponse","：",")","参数","hash","哈希",".","交易","string"," "],"title":"3.2.3 查询交易","title_tokens":["3.2","3","查询",".","交易"," "]},{"location":"sdk/javasdk/#33","text":"合约类型： BVM：BitXHub内置合约 XVM：WebAssembly合约","text_tokens":["类型","bvm","内置","合约","：","webassembly","xvm","bitxhub"," "],"title":"3.3 合约接口","title_tokens":["接口","合约","3.3"," "]},{"location":"sdk/javasdk/#331","text":"用途：调用该接口向BitXHub部署XVM合约。 参数： contract 合约数据。 String deployContract ( byte [] contract );","text_tokens":["接口","contract","xvm","部署","string","bitxhub","用途"," ","[","调用","]","合约",")","(","。","byte",";","：","向","参数","deploycontract","该","数据"],"title":"3.3.1 部署合约","title_tokens":["合约",".","3.3","部署","1"," "]},{"location":"sdk/javasdk/#332","text":"用途：调用该接口向BitXHub调用BVM或者XVM合约。 参数： vmType 合约类型：BVM和XVM。 contractAddress 合约地址。 method 合约方法； args 合约方法参数。 ReceiptOuterClass . Receipt invokeContract ( TransactionOuterClass . TransactionData . VMType vmType , String contractAddress , String method , ArgOuterClass . Arg ... args ); 用例： public void invokeContract () throws IOException { byte [] contractBytes = IOUtils . toByteArray ( new FileInputStream ( \"./example.wasm\" )); String contractAddress = client . deployContract ( contractBytes ); ReceiptOuterClass . Receipt receipt = client . invokeContract ( TransactionOuterClass . TransactionData . VMType . XVM , contractAddress , \"a\" , Types . i32 ( 1 ), Types . i32 ( 1 )); }","text_tokens":["public",",","接口","throws","client","arg","1","args","\"","xvm","bitxhub","用途"," ","vmtype","string","[","调用","ioutils","]","tobytearray","；","argouterclass","}","合约","example","receiptouterclass",")","和","i32",".","void","=","/","(","用例","bvm","。","receipt","method","invokecontract","方法","contractbytes","byte","contractaddress","a","new","ioexception","...","类型","transactionouterclass","wasm","transactiondata",";","：","或者","向","地址","参数","fileinputstream","deploycontract","types","该","{"],"title":"3.3.2 调用合约","title_tokens":["调用","合约","2",".","3.3"," "]},{"location":"sdk/javasdk/#34","text":"","text_tokens":[],"title":"3.4 区块接口","title_tokens":["接口","区块","3.4"," "]},{"location":"sdk/javasdk/#341","text":"参数： value 区块高度或者区块哈希。 type 查询类型。 type类型 。 BlockOuterClass . Block getBlock ( String value , Broker . GetBlockRequest . Type type );","text_tokens":["broker",",","getblockrequest","高度","string"," ","getblock",")","哈希",".","区块","blockouterclass","(","查询","。","value","类型","type",";","：","或者","参数","block"],"title":"3.4.1 查询区块","title_tokens":["查询","3.4",".","区块","1"," "]},{"location":"sdk/javasdk/#342","text":"用途：批量查询区块，返回指定块高度范围（start到end）的区块信息。 参数： start 指定范围的起始区块高度。 end 指定范围的结束区块高度。 Broker . GetBlocksResponse getBlocks ( Long start , Long end );","text_tokens":["start","broker",",","高度","信息","到","返回","用途"," ","指定","getblocksresponse","起始","结束",")",".","区块","(","查询","批量","。","的","long","块","getblocks","，",";","范围","（","：","参数","end","）"],"title":"3.4.2 批量查询区块","title_tokens":["批量","查询","3.4","2",".","区块"," "]},{"location":"sdk/javasdk/#343-meta","text":"用途：返回当前链的高度和区块哈希。 Chain . ChainMeta getChainMeta ();","text_tokens":["高度","链","返回","用途"," ","chain","getchainmeta",")","和","哈希",".","chainmeta","区块","(","。","当前","的",";","："],"title":"3.4.3 查询区块Meta","title_tokens":["meta","3","查询","3.4",".","区块"," "]},{"location":"sdk/javasdk/#344","text":"用途：返回当前区块链共识的状态（正常或者不正常）。 Broker . Response getChainStatus ();","text_tokens":["broker","response","getchainstatus","链","返回","用途"," ","不","正常",")",".","区块","(","状态","。","当前","的",";","（","：","或者","共识","）"],"title":"3.4.4 查询区块链状态","title_tokens":["查询","状态","3.4","链",".","区块","4"," "]},{"location":"sdk/javasdk/#35","text":"","text_tokens":[],"title":"3.5 订阅接口","title_tokens":["接口","订阅","3.5"," "]},{"location":"sdk/javasdk/#351","text":"用途：调用该接口向BitXHub发起订阅事件。 参数： streamObserver 事件通道。 type 事件类型。 用例： void subscribe ( Broker . SubscriptionRequest . Type type , StreamObserver < Broker . Response > observer ); public void subscribe () throws InterruptedException { CountDownLatch asyncLatch = new CountDownLatch ( 1 ); StreamObserver < Broker . Response > observer = new StreamObserver < Broker . Response > () { @Override public void onNext ( Broker . Response response ) { ByteString data = response . getData (); BlockOuterClass . Block block = null ; try { block = BlockOuterClass . Block . parseFrom ( data ); } catch ( InvalidProtocolBufferException e ) { e . printStackTrace (); } } @Override public void onError ( Throwable throwable ) { throwable . printStackTrace (); asyncLatch . countDown (); } @Override public void onCompleted () { asyncLatch . countDown (); } }; client . subscribe ( Broker . SubscriptionRequest . Type . BLOCK , observer ); asyncLatch . await (); }","text_tokens":["asynclatch","getdata","broker","observer","public",",","try","接口","response",">","throws","parsefrom","countdown","streamobserver","client","printstacktrace","1","throwable","bitxhub","用途"," ","调用","await","}",")","事件","void",".","=","subscribe","data","null","blockouterclass","catch","订阅","用例","(","override","onerror","onnext","。","bytestring","subscriptionrequest","通道","oncompleted","new","@","e","类型","<","type","发起",";","interruptedexception","：","向","参数","block","invalidprotocolbufferexception","countdownlatch","该","{"],"title":"3.5.1 订阅事件","title_tokens":["订阅","事件",".","3.5","1"," "]},{"location":"sdk/javasdk/#36","text":"","text_tokens":[],"title":"3.6 其它接口","title_tokens":["3.6","接口","其它"," "]},{"location":"sdk/javasdk/#361","text":"用途：返回当前区块链网络的节点信息。 Broker . Response getNetworkMeta ();","text_tokens":["broker","response","信息","链","返回","用途"," ","getnetworkmeta",")","节点","网络",".","区块","(","。","当前","的",";","："],"title":"3.6.1 查询节点网络信息","title_tokens":["查询","3.6","节点","信息","网络",".","1"," "]},{"location":"sdk/javasdk/#362","text":"参数： address 地址。 Broker . Response getAccountBalance ( String address );","text_tokens":["(","broker",";","。","response","：",")","地址","参数","getaccountbalance","address",".","string"," "],"title":"3.6.2 查询账户余额","title_tokens":["余额","查询","账户","3.6","2","."," "]},{"location":"sdk/jssdk/","text":"Js SDK 1 前言 此SDK文档面向BitXHub平台的应用开发者，提供BitXHub JS SDK的使用指南。 2 接口使用流程示例 为了更好的理解接口的使用，本示例将从初始化Client，部署合约，调用合约和返回值解析这个大致流程作介绍，具体详细接口可参考第三章SDK文档。 2.1 基本流程 2.1.1 安装并初始化Client 可以通过npm安装JS SDK并引入到JS的项目中 npm install @meshplus/js-bitxhub-client@1.5.0 JS SDK分为几个磨块供用户分开进行调用，分别为：Client, PbType, Config, Transaction, Block, TripleDES以及AES。 用户在调用JS SDK与BitXHub进行交互时，主要是需要使用Client, PbType和Config这三个模块。 用户引入JS SDK的库以后首先需要配置网络地址和接口。 例如： import { Config } from '@meshplus/js-bitxhub-client' ; Config . setHosts ([ \"localhost\" ]); Config . setPorts ([ \"9091\" ]); 初始化Client，所有操作将通过该对象与BitXHub交互。 例如： import { Client } from '@meshplus/js-bitxhub-client' ; let client = new Client ( privateKey ); 2.1.2 部署合约 开发者需提供已经编译的 WebAssembly 文件。 例如： import { fs } from 'fs' ; let contract = fs . readFileSync ( \"./testdata/example.wasm\" ); 通过client部署合约，部署完成后可以获取合约地址 addr 。 例如： let address = await cli . DeployContract ( contract ) 2.1.3 调用合约 调用合约需传入合约地址、合约方法名和对应的参数。 例如： result = cli . InvokeContract ( 0 , address , \"a\" , PbType . pbInt32 ( 1 ), PbType . pbInt32 ( 2 )) //第一个参数指定调用XVM合约还是BVM合约，第二个参数是合约地址， 方法名为a，传参1，传参2 2.1.4 完整示例 import { fs } from 'fs' ; import { Client } from '@meshplus/js-bitxhub-client' ; let contract = fs . readFileSync ( \"./testdata/example.wasm\" ); let client = new Client ( privateKey ); //部署合约，获取合约地址 let address = await cli . DeployContract ( contract ); //调用合约，获取交易回执 result = cli . InvokeContract ( 1 , address , \"a\" , PbType . pbInt32 ( 1 ), PbType . pbInt32 ( 2 )); //打印合约返回数据 console . log ( result ); 2.2 应用链管理流程示例 本示例展示应用链管理流程中的注册、审核以及注销操作。 2.2.1 应用链注册 调用BVM合约的 Register 方法，向BitXHub注册应用链。 例如： let ret = cli . InvokeContract ( 0 , InterchainContractAddr , \"Register\" , PbType . pbString ( validator ), PbType . pbInt32 ( 0 ), PbType . pbString ( chainType ), PbType . pbString ( name ), PbType . pbString ( desc ), PbType . pbString ( version ), PbType . pbString ( pubKey ) ); 获取到成功的交易回执后，得到交易回执内容。 例如： { \"id\" : \"0x5098cc26b0d485145fb8258d2e79c49886cd4662\" , \\\\ 应用链ID \"name\" : \"税务链\" , \"validators\" : \"\" , \"consensus_type\" : 0 , \"status\" : 0 , \"chain_type\" : \"hyperchain\" , \"desc\" : \"趣链税务链\" , \"version\" : \"1.8\" } 2.2.2 应用链审核 调用BVM合约的 Aduit 方法，向BitXHub审核应用链。 例如： let ret = cli . InvokeContract ( 0 , InterchainContractAddr , \"Aduit\" , PbType . pbString ( address ), PbType . pbInt32 ( 1 ), PbType . pbString ( desc ) ); 2.2.3 应用链注销 调用BVM合约的 DeleteAppchain 方法，向BitXHub注销应用链。 例如： let ret = cli . InvokeContract ( 0 , InterchainContractAddr , \"DeleteAppchain\" , PbType . pbString ( address )); 2.3 验证规则使用示例 本示例展示验证规则中的注册、审核操作，以及WebAssembly合约示例。 2.3.1 验证规则注册 调用BVM合约的 RegisterRule 方法，向应用链注册验证规则（WebAssembly合约），这里我们需要先注册应用链和部署验证规则合约，然后获取应用链ID和合约地址。 例如： let ret = cli . InvokeContract ( 0 , RoleContractAddr , \"RegisterRule\" , PbType . pbString ( chainAddr ), PbType . pbString ( contractAddr )); 2.3.2 验证规则审核 调用BVM合约的 Aduit 方法，向BitXHub审核验证规则。 例如： let ret = cli . InvokeContract ( 0 , RoleContractAddr , \"Aduit\" , PbType . pbString ( chainAddr ), PbType . pbInt32 ( 1 ), PbType . pbString ( desc ) ); 2.3.3 验证规则示例（WebAssembly合约, Fabric实例） extern crate protobuf ; extern crate sha2 ; use crate :: crypto :: ecdsa ; use crate :: model :: transaction ; use sha2 :: { Digest , Sha256 }; pub fn verify ( proof : & [ u8 ], validator : & [ u8 ]) -> bool { let cap = protobuf :: parse_from_bytes :: < transaction :: ChaincodeActionPayload > ( proof ). expect ( \"error\" ); let cap_act = cap . action . unwrap (); let endorsers = cap_act . endorsements ; let mut digest = Sha256 :: new (); let mut payload = cap_act . proposal_response_payload . to_owned (); payload . extend ( & endorsers [ 0 ]. endorser ); digest . input ( & payload ); let digest_byte = digest . result (); return ecdsa :: verify ( & endorsers [ 0 ]. signature , & digest_byte , & validator , ecdsa :: EcdsaAlgorithmn :: P256 , ); } 3 SDK文档 3.1 交易接口 3.1.1 发送交易 用途：调用该接口向中继链发送交易，交易类型包括普通交易、跨链交易和智能合约。 参数： tx 交易实例。 function SendTransaction ( transaction ) 3.1.2 查询交易回执 用途：调用该接口向BitXHub查询交易回执。 参数： hash 交易哈希。 function GetReceipt ( hash ) 3.1.3 查询交易 用途：调用该接口向BitXHub查询交易。 参数： hash 交易哈希。 function GetTransaction ( hash ) 3.2 合约接口 合约类型： BVM：BitXHub内置合约。 XVM：WebAssembly合约。 3.2.1 部署合约 用途：调用该接口向BitXHub部署XVM合约，返回合约地址。 参数： ctx wasm合约编译后的字节数据。 function DeployContract ( ctx ) 3.2.2 调用合约 用途：该接口向中继链调用合约获取交易回执。 参数： vmType 合约类型：BVM和XVM； address 合约地址； method 合约方法； args 合约方法参数。 function InvokeContract ( vmType , address , method , ... args ) 3.3 区块接口 3.3.1 查询区块 参数： value 区块高度或者区块哈希。 type 查询类型。 function GetBlock ( type , value ) 3.3.2 批量查询区块 用途：批量查询区块，返回指定块高度范围（start到end）的区块信息。 参数： start 指定范围的起始区块高度。 end 指定范围的结束区块高度。 function GetBlocks ( start , end )","text_tokens":["2.3","普通","信息","为","合约","区块","供","contractaddr","中继","new","_","setports","需","并","理解","return","操作","趣链","log","回执","=","pbint32","tx","。","'","可","wasm","ecdsa","chainaddr","第二","或者","例如","库","digest",",","编译","接口","字节","完成","返回","分开","webassembly","引入","p256","import","sendtransaction","开发","ecdsaalgorithmn",";","中","block","deleteappchain","start","unwrap","以及","validators","client","-","xvm","bitxhub"," ","3","起始","和","sha256","名为","2.2","pubkey","注销","（","rolecontractaddr","管理","这","2.1","到","registerrule","使用指南","sdk","部署","[","用户","register","流程","chaintype","endorser","批量","文档","aes","let","signature","：","是","这里","成功","js",":","规则","action","第三","在","指定","0","指南","from","fs","sha2","后","的","与","交易","对应","分别","cap","为了","使用","先","end","二个","name","一个","response",">","调用","返回值","await","内置","本","哈希","mut","包括","9091","传参","三个","endorsers","config","首先","范围","内容","deploycontract","crypto","解析","配置","cli","bytes","testdata","method","proof","方法","validator","aduit","这个","项目","a","分为","3.1","interchaincontractaddr","然后","向","地址","初始化","consensus","1","前言","用途","id","to","具体","desc","verify","几个","version","作","expect","类型","fn","验证","endorsements","error","address","）","获取","第二个","网络地址","对象","sethosts","磨块","console","/","面向","invokecontract","value","展示","owned","传入","第一个","act","介绍","已经","extend","链","bool","\"",")","实例","status","还是","pbtype","文件","&","查询","hash","getreceipt","提供","byte","gettransaction","result","function","npm","注册","args","发送","4","chain","ctx","结束","可以","主要","input","bvm","时","需要","打印","ret","三章","基本","得到","参考","应用","模块","示例","crate","]","；","}","1.5","第三章","example","通过","(","extern","chaincodeactionpayload","所有","1.8","完整","...","type","getblocks","tripledes","privatekey","详细","proposal","将","高度","3.2","getblock","use","localhost","payload","交易类型","model","@","readfilesync","税务","<","智能","参数","从","pub","名","contract","审核","vmtype","fabric","进行",".","3.3","以后","安装","第一","pbstring","addr","protobuf","块","平台","parse","transaction","2","\\","交互","meshplus","大致","hyperchain","跨链","网络","此","更好","、","初始","install","我们","u8","，","0x5098cc26b0d485145fb8258d2e79c49886cd4662","开发者","该","{","数据"],"title":"JsSDK使用文档","title_tokens":["文档","jssdk","使用"]},{"location":"sdk/jssdk/#js-sdk","text":"","text_tokens":[],"title":"Js SDK","title_tokens":["sdk","js"," "]},{"location":"sdk/jssdk/#1","text":"此SDK文档面向BitXHub平台的应用开发者，提供BitXHub JS SDK的使用指南。","text_tokens":["，","平台","js","指南"," ","。","使用","文档","的","应用","使用指南","提供","此","开发","开发者","sdk","bitxhub","面向"],"title":"1 前言","title_tokens":["前言","1"," "]},{"location":"sdk/jssdk/#2","text":"为了更好的理解接口的使用，本示例将从初始化Client，部署合约，调用合约和返回值解析这个大致流程作介绍，具体详细接口可参考第三章SDK文档。","text_tokens":["将","介绍","接口","client","示例","第三","解析","sdk","部署","返回","大致","调用","流程","返回值","合约","第三章","本","和","具体","更好","初始","。","文档","的","这个","可","三章","作","，","为了","使用","详细","参考","初始化","从","理解"],"title":"2 接口使用流程示例","title_tokens":["流程","接口","使用","2","示例"," "]},{"location":"sdk/jssdk/#21","text":"","text_tokens":[],"title":"2.1 基本流程","title_tokens":["基本","2.1","流程"," "]},{"location":"sdk/jssdk/#211-client","text":"可以通过npm安装JS SDK并引入到JS的项目中 npm install @meshplus/js-bitxhub-client@1.5.0 JS SDK分为几个磨块供用户分开进行调用，分别为：Client, PbType, Config, Transaction, Block, TripleDES以及AES。 用户在调用JS SDK与BitXHub进行交互时，主要是需要使用Client, PbType和Config这三个模块。 用户引入JS SDK的库以后首先需要配置网络地址和接口。 例如： import { Config } from '@meshplus/js-bitxhub-client' ; Config . setHosts ([ \"localhost\" ]); Config . setPorts ([ \"9091\" ]); 初始化Client，所有操作将通过该对象与BitXHub交互。 例如： import { Client } from '@meshplus/js-bitxhub-client' ; let client = new Client ( privateKey );","text_tokens":["这","模块","到","为","sdk","[","用户","]","}","1.5","通过","供","(","所有","aes","let","几个","new","setports","tripledes","privatekey","：","是","并","js","将","操作","网络地址","在","对象","sethosts","磨块","0","from","=","/","localhost","。","的","与","'","@","分别","使用","例如","库",",","接口","\"","调用","分开",")","进行",".","pbtype","以后","引入","安装","import","9091","三个","config","首先",";","中","transaction","block","npm","以及","client","-","交互","配置","bitxhub","meshplus"," ","可以","和","网络","主要","初始","install","时","需要","项目","分为","，","地址","初始化","该","{"],"title":"2.1.1 安装并初始化Client","title_tokens":["初始"," ","client","2.1","初始化",".","并","1","安装"]},{"location":"sdk/jssdk/#212","text":"开发者需提供已经编译的 WebAssembly 文件。 例如： import { fs } from 'fs' ; let contract = fs . readFileSync ( \"./testdata/example.wasm\" ); 通过client部署合约，部署完成后可以获取合约地址 addr 。 例如： let address = await cli . DeployContract ( contract )","text_tokens":["已经","编译","client","contract","完成","\"","部署"," ","await","cli","}","合约","example",")","可以","from","testdata","通过","webassembly",".","文件","fs","=","/","import","(","。","addr","后","的","let","'","提供","开发","readfilesync","wasm","，",";","：","例如","地址","需","deploycontract","address","开发者","获取","{"],"title":"2.1.2 部署合约","title_tokens":["合约","2","2.1",".","部署"," "]},{"location":"sdk/jssdk/#213","text":"调用合约需传入合约地址、合约方法名和对应的参数。 例如： result = cli . InvokeContract ( 0 , address , \"a\" , PbType . pbInt32 ( 1 ), PbType . pbInt32 ( 2 )) //第一个参数指定调用XVM合约还是BVM合约，第二个参数是合约地址， 方法名为a，传参1，传参2","text_tokens":["第二个",",","一个","名","\"","xvm"," ","指定","调用","0","cli","合约",")","和","还是","、","=",".","pbtype","pbint32","/","(","bvm","第一","。","传参","invokecontract","方法","的","名为","a","，","对应","传入","result","：","第二","例如","地址","需","参数","2","是","二个","address","1","第一个"],"title":"2.1.3 调用合约","title_tokens":["调用","3","合约","2.1","."," "]},{"location":"sdk/jssdk/#214","text":"import { fs } from 'fs' ; import { Client } from '@meshplus/js-bitxhub-client' ; let contract = fs . readFileSync ( \"./testdata/example.wasm\" ); let client = new Client ( privateKey ); //部署合约，获取合约地址 let address = await cli . DeployContract ( contract ); //调用合约，获取交易回执 result = cli . InvokeContract ( 1 , address , \"a\" , PbType . pbInt32 ( 1 ), PbType . pbInt32 ( 2 )); //打印合约返回数据 console . log ( result );","text_tokens":[",","client","-","contract","1","\"","bitxhub","meshplus"," ","部署","返回","调用","await","cli","}","合约","example",")","log","from","testdata","console","回执",".","=","fs","pbtype","pbint32","/","import","(","打印","invokecontract","let","'","a","@","readfilesync","new","交易","wasm","，","privatekey",";","result","地址","2","deploycontract","address","获取","js","{","数据"],"title":"2.1.4 完整示例","title_tokens":[" ","2.1","示例",".","4","完整"]},{"location":"sdk/jssdk/#22","text":"本示例展示应用链管理流程中的注册、审核以及注销操作。","text_tokens":["注册","流程","注销","操作","。","审核","中","本","以及","示例","应用","管理","链","的","、","展示"],"title":"2.2 应用链管理流程示例","title_tokens":["流程","示例","应用","管理","链","2.2"," "]},{"location":"sdk/jssdk/#221","text":"调用BVM合约的 Register 方法，向BitXHub注册应用链。 例如： let ret = cli . InvokeContract ( 0 , InterchainContractAddr , \"Register\" , PbType . pbString ( validator ), PbType . pbInt32 ( 0 ), PbType . pbString ( chainType ), PbType . pbString ( name ), PbType . pbString ( desc ), PbType . pbString ( version ), PbType . pbString ( pubKey ) ); 获取到成功的交易回执后，得到交易回执内容。 例如： { \"id\" : \"0x5098cc26b0d485145fb8258d2e79c49886cd4662\" , \\\\ 应用链ID \"name\" : \"税务链\" , \"validators\" : \"\" , \"consensus_type\" : 0 , \"status\" : 0 , \"chain_type\" : \"hyperchain\" , \"desc\" : \"趣链税务链\" , \"version\" : \"1.8\" }","text_tokens":["注册",":",",","validators","到","链","\"","趣链","bitxhub"," ","register","id","调用","0","chain","hyperchain","cli","}","合约",")","chaintype","status","回执",".","=","pbtype","pbint32","desc","(","bvm","pbstring","。","ret","invokecontract","获取","方法","的","let","validator","后","1.8","version","交易","_","税务","type","，","pubkey",";","interchaincontractaddr","得到","0x5098cc26b0d485145fb8258d2e79c49886cd4662","：","内容","向","例如","\\","应用","成功","consensus","name","{"],"title":"2.2.1 应用链注册","title_tokens":["注册","应用","链",".","2.2","1"," "]},{"location":"sdk/jssdk/#222","text":"调用BVM合约的 Aduit 方法，向BitXHub审核应用链。 例如： let ret = cli . InvokeContract ( 0 , InterchainContractAddr , \"Aduit\" , PbType . pbString ( address ), PbType . pbInt32 ( 1 ), PbType . pbString ( desc ) );","text_tokens":[",","链","审核","\"","bitxhub"," ","调用","0","cli","合约",")",".","=","pbtype","pbint32","desc","(","bvm","pbstring","。","ret","invokecontract","方法","的","let","aduit","，",";","interchaincontractaddr","：","向","例如","应用","address","1"],"title":"2.2.2 应用链审核","title_tokens":["2","应用","链","审核",".","2.2"," "]},{"location":"sdk/jssdk/#223","text":"调用BVM合约的 DeleteAppchain 方法，向BitXHub注销应用链。 例如： let ret = cli . InvokeContract ( 0 , InterchainContractAddr , \"DeleteAppchain\" , PbType . pbString ( address ));","text_tokens":["deleteappchain",",","链","\"","bitxhub"," ","调用","0","cli","合约",")",".","=","pbtype","(","bvm","pbstring","。","ret","invokecontract","方法","的","let","，","注销",";","interchaincontractaddr","：","向","例如","应用","address"],"title":"2.2.3 应用链注销","title_tokens":["3","注销","应用","链",".","2.2"," "]},{"location":"sdk/jssdk/#23","text":"本示例展示验证规则中的注册、审核操作，以及WebAssembly合约示例。","text_tokens":["注册","验证","，","操作","。","合约","规则","本","中","以及","示例","的","审核","、","webassembly","展示"],"title":"2.3 验证规则使用示例","title_tokens":["验证","2.3","使用","规则","示例"," "]},{"location":"sdk/jssdk/#231","text":"调用BVM合约的 RegisterRule 方法，向应用链注册验证规则（WebAssembly合约），这里我们需要先注册应用链和部署验证规则合约，然后获取应用链ID和合约地址。 例如： let ret = cli . InvokeContract ( 0 , RoleContractAddr , \"RegisterRule\" , PbType . pbString ( chainAddr ), PbType . pbString ( contractAddr ));","text_tokens":["注册",",","规则","registerrule","链","\"","部署"," ","id","调用","0","cli","合约",")","和","webassembly",".","=","pbtype","(","contractaddr","bvm","pbstring","需要","我们","。","ret","invokecontract","方法","的","let","验证","，",";","（","chainaddr","rolecontractaddr","先","然后","向","地址","例如","：","应用","这里","）","获取"],"title":"2.3.1 验证规则注册","title_tokens":["注册","验证","2.3","规则",".","1"," "]},{"location":"sdk/jssdk/#232","text":"调用BVM合约的 Aduit 方法，向BitXHub审核验证规则。 例如： let ret = cli . InvokeContract ( 0 , RoleContractAddr , \"Aduit\" , PbType . pbString ( chainAddr ), PbType . pbInt32 ( 1 ), PbType . pbString ( desc ) );","text_tokens":[",","规则","审核","\"","bitxhub"," ","调用","0","cli","合约",")",".","=","pbtype","pbint32","desc","(","bvm","pbstring","。","ret","invokecontract","方法","的","let","aduit","验证","，",";","chainaddr","rolecontractaddr","：","向","例如","1"],"title":"2.3.2 验证规则审核","title_tokens":["验证","2.3","规则","2","审核","."," "]},{"location":"sdk/jssdk/#233-webassembly-fabric","text":"extern crate protobuf ; extern crate sha2 ; use crate :: crypto :: ecdsa ; use crate :: model :: transaction ; use sha2 :: { Digest , Sha256 }; pub fn verify ( proof : & [ u8 ], validator : & [ u8 ]) -> bool { let cap = protobuf :: parse_from_bytes :: < transaction :: ChaincodeActionPayload > ( proof ). expect ( \"error\" ); let cap_act = cap . action . unwrap (); let endorsers = cap_act . endorsements ; let mut digest = Sha256 :: new (); let mut payload = cap_act . proposal_response_payload . to_owned (); payload . extend ( & endorsers [ 0 ]. endorser ); digest . input ( & payload ); let digest_byte = digest . result (); return ecdsa :: verify ( & endorsers [ 0 ]. signature , & digest_byte , & validator , ecdsa :: EcdsaAlgorithmn :: P256 , ); }","text_tokens":["return","act","digest","unwrap",":","crypto",",","pub","response",">","action","-","extend","bool","\"","["," ","crate","0","]","}","to","bytes",")","from","use","sha256",".","&","=","endorser","mut","input","p256","(","extern","chaincodeactionpayload","payload","sha2","protobuf","verify","proof","validator","let","endorsers","model","byte","ecdsaalgorithmn","u8","_","expect","new","owned","fn","<","ecdsa","signature",";","cap","result","parse","endorsements","transaction","error","proposal","{"],"title":"2.3.3 验证规则示例（WebAssembly合约, Fabric实例）","title_tokens":["3","验证","2.3",",","（","合约","规则","fabric","实例","示例","webassembly",".","）"," "]},{"location":"sdk/jssdk/#3-sdk","text":"","text_tokens":[],"title":"3 SDK文档","title_tokens":["sdk","文档","3"," "]},{"location":"sdk/jssdk/#31","text":"","text_tokens":[],"title":"3.1 交易接口","title_tokens":["3.1","接口","交易"," "]},{"location":"sdk/jssdk/#311","text":"用途：调用该接口向中继链发送交易，交易类型包括普通交易、跨链交易和智能合约。 参数： tx 交易实例。 function SendTransaction ( transaction )","text_tokens":["接口","普通","链","发送","用途"," ","调用","合约",")","实例","和","跨链","、","sendtransaction","(","tx","包括","。","交易类型","中继","交易","类型","，","：","向","智能","参数","transaction","function","该"],"title":"3.1.1 发送交易","title_tokens":["3.1","发送",".","交易","1"," "]},{"location":"sdk/jssdk/#312","text":"用途：调用该接口向BitXHub查询交易回执。 参数： hash 交易哈希。 function GetReceipt ( hash )","text_tokens":["接口","bitxhub","用途"," ","调用",")","回执","哈希","(","查询","。","hash","getreceipt","交易","：","向","参数","function","该"],"title":"3.1.2 查询交易回执","title_tokens":["3.1","查询","2","回执",".","交易"," "]},{"location":"sdk/jssdk/#313","text":"用途：调用该接口向BitXHub查询交易。 参数： hash 交易哈希。 function GetTransaction ( hash )","text_tokens":["(","调用","交易","查询","接口","。","：","向",")","参数","hash","哈希","function","gettransaction","该","bitxhub","用途"," "],"title":"3.1.3 查询交易","title_tokens":["3.1","3","查询",".","交易"," "]},{"location":"sdk/jssdk/#32","text":"合约类型： BVM：BitXHub内置合约。 XVM：WebAssembly合约。","text_tokens":["类型","bvm","内置","。","合约","：","webassembly","xvm","bitxhub"," "],"title":"3.2 合约接口","title_tokens":["合约","3.2","接口"," "]},{"location":"sdk/jssdk/#321","text":"用途：调用该接口向BitXHub部署XVM合约，返回合约地址。 参数： ctx wasm合约编译后的字节数据。 function DeployContract ( ctx )","text_tokens":["编译","接口","字节","xvm","部署","返回","bitxhub","用途"," ","调用","ctx","合约",")","(","。","后","的","wasm","，","：","向","地址","参数","function","deploycontract","该","数据"],"title":"3.2.1 部署合约","title_tokens":["3.2","合约",".","部署","1"," "]},{"location":"sdk/jssdk/#322","text":"用途：该接口向中继链调用合约获取交易回执。 参数： vmType 合约类型：BVM和XVM； address 合约地址； method 合约方法； args 合约方法参数。 function InvokeContract ( vmType , address , method , ... args )","text_tokens":[",","接口","链","args","xvm","用途"," ","vmtype","调用","；","合约","该",")","和","回执","(","bvm","。","method","invokecontract","方法","中继","交易","...","类型","：","向","地址","参数","function","address","获取"],"title":"3.2.2 调用合约","title_tokens":["3.2","调用","合约","2","."," "]},{"location":"sdk/jssdk/#33","text":"","text_tokens":[],"title":"3.3 区块接口","title_tokens":["接口","区块","3.3"," "]},{"location":"sdk/jssdk/#331","text":"参数： value 区块高度或者区块哈希。 type 查询类型。 function GetBlock ( type , value )","text_tokens":["类型","(","type","查询",",","。","getblock","：","或者","高度",")","参数","哈希","function","value","区块"," "],"title":"3.3.1 查询区块","title_tokens":["查询",".","区块","3.3","1"," "]},{"location":"sdk/jssdk/#332","text":"用途：批量查询区块，返回指定块高度范围（start到end）的区块信息。 参数： start 指定范围的起始区块高度。 end 指定范围的结束区块高度。 function GetBlocks ( start , end )","text_tokens":["start",",","高度","信息","到","返回","用途"," ","指定","起始","结束",")","区块","(","查询","批量","。","的","块","getblocks","，","范围","（","：","参数","end","function","）"],"title":"3.3.2 批量查询区块","title_tokens":["批量","查询","2",".","区块","3.3"," "]}]}